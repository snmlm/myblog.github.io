<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>常用数据结构 | snmlm</title><meta name="description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先给出Java集合框架的基本接口&#x2F;类层次结构： java.util.Collection [I]    +--java.util.List [I]       +--java.util.ArrayList [C]           +--java.util.LinkedList [C]"><meta name="keywords" content="数据结构"><meta name="author" content="snmlm"><meta name="copyright" content="snmlm"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://snmlm.github.io/dataStructure/20190502/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="常用数据结构"><meta property="og:url" content="https://snmlm.github.io/dataStructure/20190502/"><meta property="og:site_name" content="snmlm"><meta property="og:description" content="&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;首先给出Java集合框架的基本接口&#x2F;类层次结构： java.util.Collection [I]    +--java.util.List [I]       +--java.util.ArrayList [C]           +--java.util.LinkedList [C]"><meta property="og:image" content="https://snmlm.github.io/img/head.gif"><meta property="article:published_time" content="2020-05-24T16:00:00.000Z"><meta property="article:modified_time" content="2020-09-04T03:58:33.640Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-04 11:58:33'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.1.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/head.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">75</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">47</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">常用数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">5.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">6.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">散列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.1.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.2.</span> <span class="toc-text">满二叉树、完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">8.3.</span> <span class="toc-text">二叉查找树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.4.</span> <span class="toc-text">平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">9.</span> <span class="toc-text">堆</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/head.gif)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">snmlm</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">常用数据结构</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-24T16:00:00.000Z" title="发表于 2020-05-25 00:00:00">2020-05-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-04T03:58:33.640Z" title="更新于 2020-09-04 11:58:33">2020-09-04</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先给出Java集合框架的基本接口/类层次结构：<a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.util.Collection [I]</span><br><span class="line">    +--java.util.List [I]</span><br><span class="line">       +--java.util.ArrayList [C]    </span><br><span class="line">       +--java.util.LinkedList [C]  </span><br><span class="line">       +--java.util.Vector [C]    &#x2F;&#x2F;线程安全</span><br><span class="line">          +--java.util.Stack [C]  &#x2F;&#x2F;线程安全</span><br><span class="line">    +--java.util.Set [I]                   </span><br><span class="line">       +--java.util.HashSet [C]      </span><br><span class="line">       +--java.util.SortedSet [I]    </span><br><span class="line">          +--java.util.TreeSet [C]    </span><br><span class="line">    +--Java.util.Queue[I]</span><br><span class="line">        +--java.util.Deque[I]   </span><br><span class="line">        +--java.util.PriorityQueue[C]  </span><br><span class="line">java.util.Map [I]</span><br><span class="line">    +--java.util.SortedMap [I]</span><br><span class="line">       +--java.util.TreeMap [C]</span><br><span class="line">    +--java.util.Hashtable [C]   &#x2F;&#x2F;线程安全</span><br><span class="line">    +--java.util.HashMap [C]</span><br><span class="line">    +--java.util.LinkedHashMap [C]</span><br><span class="line">    +--java.util.WeakHashMap [C]</span><br><span class="line"></span><br><span class="line">[I]：接口</span><br><span class="line">[C]：类</span><br></pre></td></tr></table></figure>
<h3 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h3><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/qrYRX93.jpg"></p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组是相同数据类型的元素按一定顺序排列的集合，是一块连续的内存空间。数组的优点是：get和set操作时间上都是O(1)的；缺点是：add和remove操作时间上都是O(N)的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中，Array就是数组，此外，ArrayList使用了数组Array作为其实现基础,它和一般的Array相比，最大的好处是，我们在添加元素时不必考虑越界，元素超出数组容量时，它会自动扩张保证容量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector和ArrayList相比，主要差别就在于多了一个线程安全性，但是效率比较低下。如今java.util.concurrent包提供了许多线程安全的集合类（比如 LinkedBlockingQueue），所以不必再使用Vector了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] ints &#x3D; new int[10];</span><br><span class="line">ints[0] &#x3D; 5;&#x2F;&#x2F;set</span><br><span class="line">int a &#x3D; ints[2];&#x2F;&#x2F;get</span><br><span class="line">int len &#x3D; ints.length;&#x2F;&#x2F;数组长度</span><br></pre></td></tr></table></figure>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表是一种非连续、非顺序的结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，链表由一系列结点组成。链表的优点是：add和remove操作时间上都是O(1)的；缺点是：get和set操作时间上都是O(N)的，而且需要额外的空间存储指向其他数据地址的项。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找操作对于未排序的数组和链表时间上都是O(N)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中，LinkedList 使用链表作为其基础实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;String&gt; linkedList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">linkedList.add(&quot;addd&quot;);&#x2F;&#x2F;add</span><br><span class="line">linkedList.set(0,&quot;s&quot;);&#x2F;&#x2F;set，必须先保证 linkedList中已经有第0个元素</span><br><span class="line">String s &#x3D;  linkedList.get(0);&#x2F;&#x2F;get</span><br><span class="line">linkedList.contains(&quot;s&quot;);&#x2F;&#x2F;查找</span><br><span class="line">linkedList.remove(&quot;s&quot;);&#x2F;&#x2F;删除</span><br></pre></td></tr></table></figure>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，亦即所谓的先进先出（FIFO）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中，LinkedList实现了Deque，可以做为双向队列（自然也可以用作单向队列）。另外PriorityQueue实现了带优先级的队列，亦即队列的每一个元素都有优先级，且元素按照优先级排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; integerDeque &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F; 尾部入队，区别在于如果失败了</span><br><span class="line">&#x2F;&#x2F; add方法会抛出一个IllegalStateException异常，而offer方法返回false</span><br><span class="line">integerDeque.offer(122);</span><br><span class="line">integerDeque.add(122);</span><br><span class="line">&#x2F;&#x2F; 头部出队,区别在于如果失败了</span><br><span class="line">&#x2F;&#x2F; remove方法抛出一个NoSuchElementException异常，而poll方法返回false</span><br><span class="line">int head &#x3D; integerDeque.poll();&#x2F;&#x2F;返回第一个元素，并在队列中删除</span><br><span class="line">head &#x3D; integerDeque.remove();&#x2F;&#x2F;返回第一个元素，并在队列中删除</span><br><span class="line">&#x2F;&#x2F; 头部出队，区别在于如果失败了</span><br><span class="line">&#x2F;&#x2F; element方法抛出一个NoSuchElementException异常，而peek方法返回null。</span><br><span class="line">head &#x3D; integerDeque.peek();&#x2F;&#x2F;返回第一个元素，不删除</span><br><span class="line">head &#x3D; integerDeque.element();&#x2F;&#x2F;返回第一个元素，不删除</span><br></pre></td></tr></table></figure>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。它体现了后进先出（LIFO）的特点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中，Stack实现了这种特性，但是Stack也继承了Vector，所以具有线程安全线和效率低下两个特性，最新的JDK8中，推荐用Deque来实现栈，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack &#x3D; new ArrayDeque&lt;Integer&gt;();</span><br><span class="line">stack.push(12);&#x2F;&#x2F;尾部入栈</span><br><span class="line">stack.push(16);&#x2F;&#x2F;尾部入栈</span><br><span class="line">int tail &#x3D; stack.pop();&#x2F;&#x2F;尾部出栈，并删除该元素</span><br><span class="line">tail &#x3D; stack.peek();&#x2F;&#x2F;尾部出栈，不删除该元素</span><br></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集合是指具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素，其主要特性是元素不可重复。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java中，HashSet 体现了这种数据结构，而HashSet是在MashMap的基础上构建的。LinkedHashSet继承了HashSet，使用HashCode确定在集合中的位置，使用链表的方式确定位置，所以有顺序。TreeSet实现了SortedSet 接口，是排好序的集合（在TreeMap 基础之上构建），因此查找操作比普通的Hashset要快（log(N)）；插入操作要慢（log（N））,因为要维护有序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; integerHashSet &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">integerHashSet.add(12121);&#x2F;&#x2F;添加</span><br><span class="line">integerHashSet.contains(121);&#x2F;&#x2F;是否包含</span><br><span class="line">integerHashSet.size();&#x2F;&#x2F;集合大小</span><br><span class="line">integerHashSet.isEmpty();&#x2F;&#x2F;是否为空</span><br></pre></td></tr></table></figure>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;散列表也叫哈希表，是根据关键键值(Keyvalue)进行访问的数据结构，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中HashMap实现了散列表，而Hashtable比它多了一个线程安全性，但是由于使用了全局锁导致其性能较低，所以现在一般用ConcurrentHashMap来实现线程安全的HashMap（类似的，以上的数据结构在最新的java.util.concurrent的包中几乎都有对应的高性能的线程安全的类）。TreeMap实现SortMap接口，能够把它保存的记录按照键排序。LinkedHashMap保留了元素插入的顺序。WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收，而不需要我们手动删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; integerHashSet &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">integerHashSet.add(12121);&#x2F;&#x2F;添加</span><br><span class="line">integerHashSet.contains(121);&#x2F;&#x2F;是否包含</span><br><span class="line">integerHashSet.size();&#x2F;&#x2F;集合大小</span><br><span class="line">integerHashSet.isEmpty();&#x2F;&#x2F;是否为空</span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树（tree）是包含n（n&gt;0）个节点的有穷集合，其中：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个元素称为节点（node）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一个特定的节点被称为根节点或树根（root）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除根节点之外的其余数据元素被分为m（m≥0）个互不相交的结合T1，T2，……Tm-1，其中每一个集合Ti（1&lt;=i&lt;=m）本身也是一棵树，被称作原树的子树（subtree）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树这种数据结构在计算机世界中有广泛的应用，比如操作系统中用到了红黑树，数据库用到了B+树，编译器中的语法树，内存管理用到了堆（本质上也是树），信息论中的哈夫曼编码等等等等，在Java中TreeSet和TreeMap用到了树来排序（二分查找提高检索速度），不过一般都需要程序员自己去定义一个树的类，并实现相关性质，而没有现成的API。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面用Java来实现各种常见的树:</p>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉树是一种基础而且重要的数据结构，其每个结点至多只有二棵子树，二叉树有左右子树之分，第i层至多有2^(i-1)个结点（i从1开始）；深度为k的二叉树至多有2^(k)-1)个结点，对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉树的性质：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在非空二叉树中，第i层的结点总数不超过2^(i-1), i&gt;=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;深度为h的二叉树最多有2^h-1个结点(h&gt;=1)，最少有h个结点;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具有n个结点的完全二叉树的深度为log2(n+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若I为结点编号则 如果I&gt;1，则其父结点的编号为I/2； 如果2I&lt;=N，则其左儿子（即左子树的根结点）的编号为2I；若2I&gt;N，则无左儿子； 如果2I+1&lt;=N，则其右儿子的结点编号为2I+1；若2I+1&gt;N，则无右儿子。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i。</p>
<h4 id="满二叉树、完全二叉树"><a href="#满二叉树、完全二叉树" class="headerlink" title="满二叉树、完全二叉树"></a>满二叉树、完全二叉树</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;满二叉树是完全二叉树的一个特例。</p>
<h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉查找树，又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;左、右子树也分别为二叉排序树；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有键值相等的节点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。 二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡二叉树设计的初衷。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉查找树可以这样表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    private Node root;             &#x2F;&#x2F; 根节点</span><br><span class="line"> </span><br><span class="line">    private class Node &#123;</span><br><span class="line">        private Key key;           &#x2F;&#x2F; 排序的间</span><br><span class="line">        private Value val;         &#x2F;&#x2F; 相应的值</span><br><span class="line">        private Node left, right;  &#x2F;&#x2F; 左子树，右子树</span><br><span class="line">        private int size;          &#x2F;&#x2F; 以该节点为根的树包含节点数量</span><br><span class="line"> </span><br><span class="line">        public Node(Key key, Value val, int size) &#123;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.val &#x3D; val;</span><br><span class="line">            this.size &#x3D; size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public BST() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    public int size() &#123;&#x2F;&#x2F;获得该二叉树节点数量</span><br><span class="line">        return size(root);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private int size(Node x) &#123;获得以该节点为根的树包含节点数量</span><br><span class="line">        if (x &#x3D;&#x3D; null) return 0;</span><br><span class="line">        else return x.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Value get(Key key) &#123;</span><br><span class="line">    return get(root, key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private Value get(Node x, Key key) &#123;&#x2F;&#x2F;在以x节点为根的树中查找key</span><br><span class="line">    if (x &#x3D;&#x3D; null) return null;</span><br><span class="line">    int cmp &#x3D; key.compareTo(x.key);</span><br><span class="line">    if(cmp &lt; 0) </span><br><span class="line">        return get(x.left, key);&#x2F;&#x2F;递归左子树查找</span><br><span class="line">    else if (cmp &gt; 0) </span><br><span class="line">        return get(x.right, key);&#x2F;&#x2F;递归右子树查找</span><br><span class="line">    else              </span><br><span class="line">        return x.val;&#x2F;&#x2F;找到了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void put(Key key, Value val) &#123;</span><br><span class="line">    root &#x3D; put(root, key, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private Node put(Node x, Key key, Value val) &#123;在以x节点为根的树中查找key，val</span><br><span class="line">    if (x &#x3D;&#x3D; null) </span><br><span class="line">        return new Node(key, val, 1);</span><br><span class="line">    int cmp &#x3D; key.compareTo(x.key);</span><br><span class="line">    if(cmp &lt; 0) </span><br><span class="line">        x.left  &#x3D; put(x.left,  key, val);&#x2F;&#x2F;递归左子树插入</span><br><span class="line">    else if (cmp &gt; 0) </span><br><span class="line">        x.right &#x3D; put(x.right, key, val);&#x2F;&#x2F;递归右子树插入</span><br><span class="line">    else              </span><br><span class="line">        x.val   &#x3D; val;</span><br><span class="line">    x.size &#x3D; 1 + size(x.left) + size(x.right);</span><br><span class="line">    return x;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Key min() &#123;</span><br><span class="line">    return min(root).key;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">private Node min(Node x) &#123; </span><br><span class="line">    if (x.left &#x3D;&#x3D; null) </span><br><span class="line">        return x; </span><br><span class="line">    else                </span><br><span class="line">        return min(x.left); </span><br><span class="line"> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public void deleteMin() &#123;</span><br><span class="line">    root &#x3D; deleteMin(root);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private Node deleteMin(Node x) &#123;&#x2F;&#x2F;删除以x为根节点的子树最小值</span><br><span class="line">    if (x.left &#x3D;&#x3D; null) </span><br><span class="line">        return x.right;</span><br><span class="line">    x.left &#x3D; deleteMin(x.left);</span><br><span class="line">    x.size &#x3D; size(x.left) + size(x.right) + 1;</span><br><span class="line">    return x;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void delete(Key key) &#123;</span><br><span class="line">     root &#x3D; delete(root, key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private Node delete(Node x, Key key) &#123;</span><br><span class="line">    if (x &#x3D;&#x3D; null) </span><br><span class="line">        return null;</span><br><span class="line"> </span><br><span class="line">    int cmp &#x3D; key.compareTo(x.key);</span><br><span class="line">    if(cmp &lt; 0) </span><br><span class="line">        x.left  &#x3D; delete(x.left,  key);&#x2F;&#x2F;递归删除左子树</span><br><span class="line">    else if (cmp &gt; 0) </span><br><span class="line">        x.right &#x3D; delete(x.right, key);&#x2F;&#x2F;递归删除右子树</span><br><span class="line">    else &#123; &#x2F;&#x2F;该节点就是所要删除的节点</span><br><span class="line">        if (x.right &#x3D;&#x3D; null) </span><br><span class="line">            return x.left;&#x2F;&#x2F;没有右子树，把左子树挂在原节点父节点上</span><br><span class="line">        if (x.left  &#x3D;&#x3D; null) </span><br><span class="line">            return x.right;&#x2F;&#x2F;没有左子树，，把右子树挂在原节点父节点上</span><br><span class="line">        Node t &#x3D; x;&#x2F;&#x2F;用右子树中最小的节点来替代被删除的节点，仍然保证树的有序性</span><br><span class="line">        x &#x3D; min(t.right);</span><br><span class="line">        x.right &#x3D; deleteMin(t.right);</span><br><span class="line">        x.left &#x3D; t.left;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    x.size &#x3D; size(x.left) + size(x.right) + 1;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平衡二叉树又被称为AVL树，具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。它的出现就是解决二叉查找树不平衡导致查找效率退化为线性的问题，因为在删除和插入之时会维护树的平衡，使得查找时间保持在O(logn)，比二叉查找树更稳定。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ALLTree 的 Node 由 BST 的 Node 加上 private int height; 节点高度属性即可，这是为了便于判断树是否平衡。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;维护树的平衡关键就在于旋转。对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2，容易看出，这种不平衡出现在下面四种情况：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单旋转是针对于左左和右右这两种情况，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为使树恢复平衡，我们把k1变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。 代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int height(Node t)&#123;  </span><br><span class="line">    return t &#x3D;&#x3D; null ? -1 : t.height;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;左左情况单旋转  </span><br><span class="line">private Node rotateWithLeftChild(Node k2)&#123;  </span><br><span class="line">    Node k1 &#x3D; k2.left;  </span><br><span class="line">    k2.left &#x3D; k1.right;       </span><br><span class="line">    k1.right &#x3D; k2;        </span><br><span class="line">    k1.size &#x3D; k2.size;</span><br><span class="line">    k2.size &#x3D; size(k2.right)+size(k2.left)+1;</span><br><span class="line">    k2.height &#x3D; Math.max(height(k2.left), height(k2.right)) + 1;  </span><br><span class="line">    k1.height &#x3D; Math.max(height(k1.left), k2.height) + 1;         </span><br><span class="line">    return k1;      &#x2F;&#x2F;返回新的根  </span><br><span class="line">&#125;     </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;右右情况单旋转  </span><br><span class="line">private Node rotateWithRightChild(Node k2)&#123;  </span><br><span class="line">    Node k1 &#x3D; k2.right;  </span><br><span class="line">    k2.right &#x3D; k1.left;  </span><br><span class="line">    k1.left &#x3D; k2;  </span><br><span class="line">    k1.size &#x3D; k2.size;</span><br><span class="line">    k2.size &#x3D; size(k2.right)+size(k2.left)+1;       </span><br><span class="line">    k2.height &#x3D; Math.max(height(k2.left), height(k2.right)) + 1;  </span><br><span class="line">    k1.height &#x3D; Math.max(height(k1.right), k2.height) + 1;        </span><br><span class="line">    return k1;      &#x2F;&#x2F;返回新的根   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双旋转是针对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树树。 代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;左右情况  </span><br><span class="line">private Node doubleWithLeftChild(Node k3)&#123;        </span><br><span class="line">    try&#123;  </span><br><span class="line">        k3.left &#x3D; rotateWithRightChild(k3.left);  </span><br><span class="line">    &#125;catch(NullPointerException e)&#123;  </span><br><span class="line">        System.out.println(&quot;k.left.right为：&quot;+k3.left.right);  </span><br><span class="line">        throw e;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return rotateWithLeftChild(k3);       </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;右左情况  </span><br><span class="line">private Node doubleWithRightChild(Node k3)&#123;  </span><br><span class="line">    try&#123;  </span><br><span class="line">        k3.right &#x3D; rotateWithLeftChild(k3.right);  </span><br><span class="line">    &#125;catch(NullPointerException e)&#123;  </span><br><span class="line">        System.out.println(&quot;k.right.left为：&quot;+k3.right.left);  </span><br><span class="line">        throw e;  </span><br><span class="line">    &#125;         </span><br><span class="line">    return rotateWithRightChild(k3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AVL查找操作与BST相同，AVL的删除与插入操作在BST基础之上需要检查是否平衡，如果不平衡就要使用旋转操作来维持平衡：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Node balance(Node x) &#123;</span><br><span class="line">    if (balanceFactor(x) &lt; -1) &#123;&#x2F;&#x2F;右边高</span><br><span class="line">        if (balanceFactor(x.right) &gt; 0) &#123;&#x2F;&#x2F;右左</span><br><span class="line">            x.right &#x3D; rotateWithLeftChild(x.right);</span><br><span class="line">        &#125;</span><br><span class="line">        x &#x3D; rotateWithRightChild(x);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (balanceFactor(x) &gt; 1) &#123;&#x2F;&#x2F;左边高</span><br><span class="line">        if (balanceFactor(x.left) &lt; 0) &#123;&#x2F;&#x2F;左右</span><br><span class="line">            x.left &#x3D; rotateWithRightChild(x.left);</span><br><span class="line">        &#125;</span><br><span class="line">        x &#x3D; rotateWithLeftChild(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private int balanceFactor(Node x) &#123;</span><br><span class="line">    return height(x.left) - height(x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆是一颗完全二叉树，在这棵树中，所有父节点都满足大于等于其子节点的堆叫大根堆，所有父节点都满足小于等于其子节点的堆叫小根堆。堆虽然是一颗树，但是通常存放在一个数组中，父节点和孩子节点的父子关系通过数组下标来确定。如下面的小根堆及存储它的数组：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值：7,8,9,12,13,11<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组索引：0,1,2,3,4,5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过一个节点在数组中的索引怎么计算出它的父节点及左右孩子节点的索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int left(int i) &#123;</span><br><span class="line">     return (i + 1) * 2 - 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public int right(int i) &#123;</span><br><span class="line">    return (i + 1) * 2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public int parent(int i) &#123;</span><br><span class="line">    &#x2F;&#x2F; i为根结点</span><br><span class="line">    if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return (i - 1) &#x2F; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;维护大根堆的性质：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void heapify(T[] a, int i, int heapLength) &#123;</span><br><span class="line">    int l &#x3D; left(i);</span><br><span class="line">    int r &#x3D; right(i);</span><br><span class="line">    int largest &#x3D; -1;</span><br><span class="line">    &#x2F;&#x2F;寻找根节点及其左右子节点，三个元素中的最大值</span><br><span class="line">    if (l &lt; heapLength &amp;&amp; a[i].compareTo(a[l]) &lt; 0) &#123;</span><br><span class="line">        largest &#x3D; l;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        largest &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    if (r &lt; heapLength &amp;&amp; a[largest].compareTo(a[r]) &lt; 0) &#123;</span><br><span class="line">        largest &#x3D; r;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 如果i处元素不是最大的，就把i处的元素与最大处元素交换，使得i处元素变为最大的</span><br><span class="line">    if (i !&#x3D; largest) &#123;</span><br><span class="line">        T temp &#x3D; a[i];</span><br><span class="line">        a[i] &#x3D; a[largest];</span><br><span class="line">        a[largest] &#x3D; temp;</span><br><span class="line">        &#x2F;&#x2F; 交换元素后，以a[i]为根的树可能不在满足大根堆性质，于是递归调用该方法</span><br><span class="line">        heapify(a, largest, heapLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造堆：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void buildHeap(T[] a, int heapLength) &#123;</span><br><span class="line">    &#x2F;&#x2F;从后往前看lengthParent处的元素是第一个有子节点的元素，所以从它开始，进行堆得维护</span><br><span class="line">    int lengthParent &#x3D; parent(heapLength - 1);</span><br><span class="line">    for(int i &#x3D; lengthParent; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">        heapify(a, i, heapLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆的用途：堆排序，优先级队列。此外由于调整代价较小，也适合实时类型的排序与变更。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">snmlm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://snmlm.github.io/dataStructure/20190502/">https://snmlm.github.io/dataStructure/20190502/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://snmlm.github.io" target="_blank">snmlm</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/head.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/dataStructure/20200525/"><img class="prev-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">红黑树</div></div></a></div><div class="next-post pull-right"><a href="/java/basics/20200508/"><img class="next-cover" src="/null" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java基础类型</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/dataStructure/20200525/" title="红黑树"><img class="cover" src="/null"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-25</div><div class="title">红黑树</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2020 By snmlm</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>