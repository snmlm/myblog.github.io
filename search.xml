<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>工作日志202009</title>
      <link href="/workLog/202009/"/>
      <url>/workLog/202009/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><a id="more"></a><h4 id="01"><a href="#01" class="headerlink" title="01"></a>01</h4><ul><li>月结</li><li>保单验真数据查验</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工作日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作日志202008</title>
      <link href="/workLog/202008/"/>
      <url>/workLog/202008/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><a id="more"></a><h4 id="03"><a href="#03" class="headerlink" title="03"></a>03</h4><ul><li>请假</li></ul><h4 id="04"><a href="#04" class="headerlink" title="04"></a>04</h4><ul><li>信保京东产品开发</li></ul><h4 id="05"><a href="#05" class="headerlink" title="05"></a>05</h4><ul><li>信保京东产品联调<ul><li>文档是多久没维护了啊</li></ul></li></ul><h4 id="06"><a href="#06" class="headerlink" title="06"></a>06</h4><ul><li>信保京东产品联调<ul><li>文档排版</li><li>生产升级</li></ul></li><li>SHENGCHAN-3849</li></ul><h4 id="07"><a href="#07" class="headerlink" title="07"></a>07</h4><ul><li>保单验真二期，有个接口超时，查找原因</li></ul><h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><ul><li>保单验真二期，有个接口超时，查找原因</li></ul><h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><ul><li>保单验真二期，有个接口超时，查找原因<ul><li>接口超时，调用方20s返回超时</li><li>数据库表里没索引，速度有显著的提升</li></ul></li></ul><h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><ul><li>反洗钱问题处理<ul><li>冗余数据的删除</li></ul></li></ul><h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><ul><li>反洗钱问题处理<ul><li>修改黑名单sql的字段问题。</li></ul></li></ul><h4 id="14"><a href="#14" class="headerlink" title="14"></a>14</h4><ul><li>请假</li></ul><h4 id="17"><a href="#17" class="headerlink" title="17"></a>17</h4><ul><li>查数据，2019-12-24丢失数据情况<ul><li>应是服务器oom导致消费失败。</li></ul></li></ul><h4 id="18"><a href="#18" class="headerlink" title="18"></a>18</h4><ul><li>SHENGCHAN-3901</li><li>SHENGCHAN-3849<ul><li>修改费用比例修改dubbo，增加送收付</li></ul></li></ul><h4 id="19"><a href="#19" class="headerlink" title="19"></a>19</h4><ul><li>SHENGCHAN-3849<ul><li>修改费用比例修改dubbo，增加送收付</li></ul></li><li>查询数据</li></ul><h4 id="20"><a href="#20" class="headerlink" title="20"></a>20</h4><ul><li>SHENGCHAN-3849<ul><li>修改费用比例修改dubbo，增加送收付</li><li>修改费用比例单独的程序，增加送收付</li></ul></li></ul><h4 id="21"><a href="#21" class="headerlink" title="21"></a>21</h4><ul><li>SHENGCHAN-3849<ul><li>修改费用比例修改dubbo，增加送收付</li><li>修改费用比例单独的程序，增加送收付</li></ul></li></ul><h4 id="24"><a href="#24" class="headerlink" title="24"></a>24</h4><ul><li>SHENGCHAN-3849<ul><li>修改费用比例修改dubbo，增加送收付</li><li>修改费用比例单独的程序，增加送收付</li></ul></li></ul><h4 id="25"><a href="#25" class="headerlink" title="25"></a>25</h4><ul><li>SHENGCHAN-3849<ul><li>修改费用比例修改dubbo，增加送收付</li><li>修改费用比例单独的程序，增加送收付</li></ul></li></ul><h4 id="26"><a href="#26" class="headerlink" title="26"></a>26</h4><ul><li>SHENGCHAN-3849<ul><li>修改费用比例修改dubbo，增加送收付</li><li>修改费用比例单独的程序，增加送收付</li></ul></li></ul><h4 id="27"><a href="#27" class="headerlink" title="27"></a>27</h4><ul><li>SHEGCHAN-3849<ul><li>需求变更</li></ul></li></ul><h4 id="28"><a href="#28" class="headerlink" title="28"></a>28</h4><ul><li>SHEGCHAN-3849<ul><li>需求变更</li></ul></li></ul><h4 id="31"><a href="#31" class="headerlink" title="31"></a>31</h4><ul><li>查数据，190期数据，核心没有，中台有</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工作日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作日志202007</title>
      <link href="/workLog/202007/"/>
      <url>/workLog/202007/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><a id="more"></a>#### 6* 反洗钱数据整理 * CustomerIdv 数据重复问题。是存过中日期写死导致。方案：需修改存过，重新执行存过，日期从2019-08-23至今。 * 可疑数据的丢失，中间表数据有，业务表数据没有。由于定时的时间问题，抽取在数据进入之前执行的。方案：修改抽取定时和推数定时，重新抽取，日期从2019-11-02至今，刨除2020-03-01。* COREPRPALL-1090，auto上uat出现了问题，mongodb配置加载不上，写死之后，启动出现内存溢出问题，仍未解决。<h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><ul><li>COREPRPALL-1090，auto上uat出现了问题，mongodb配置加载不上，写死之后，启动出现内存溢出问题，仍未解决。</li><li>分期退保，剩余期次的税不足保单总税的时候，缴费计划表中会出现正值的税。原因：代码中未考虑这个情况。方案：把不足的地方在最后一期上修正。</li><li>SHENGCHAN-3800 数据修正。</li><li>发现bug，计算时，少除100</li></ul><h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><ul><li>COREPRPALL-1090，auto上uat出现了问题，mongodb配置加载不上，写死之后，启动出现内存溢出问题，仍未解决。</li><li>昨日没有除100的bug，检查生产数据，数据没问题，有16条数据有问题，但是都是冷数据，大部分都是退保或过期的。代码不是我这里修改。</li><li>销管代码本地部署完成。</li><li>SHENGCHAN-3809 提数</li></ul><h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><ul><li>COREPRPALL-1090，auto上uat出现了问题，mongodb配置加载不上，写死之后，启动出现内存溢出问题，仍未解决。</li><li>SHENGCHAN-3809 提数</li><li>梳理销管信息技术费结算代码。</li></ul><h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><ul><li>梳理销管信息技术费结算代码。</li></ul><h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><ul><li>报工，赠险标志，mongodb</li><li>反洗钱数据治理，重新抽取客户信息，大额和可疑信息。</li></ul><h4 id="14"><a href="#14" class="headerlink" title="14"></a>14</h4><ul><li>反洗钱数据治理，重新抽取客户信息，大额和可疑信息。<ul><li>发现数据中，人员代码有些问题，中间表数据就不对，销管送的数据有问题。</li></ul></li></ul><h4 id="15"><a href="#15" class="headerlink" title="15"></a>15</h4><ul><li>反洗钱数据治理，重新抽取客户信息，大额和可疑信息。</li><li>开发销管信息技术费追加结算功能。<ul><li>certino改为Z0001开头，后续不变</li><li>prpjcommplan_xxjsf追加新条数，用于存放追加数据。</li><li>prpjcommplan_xxjsfhis, 追加新条数（无所谓了）</li><li>查询是拿已结算的信息技术费？要拿最新的结算的东西吗？</li></ul></li><li>构思报文校验功能（大报文，多层嵌套，空值必传数值校验，模板化，可配置）<ul><li>逐个字段比对？</li><li>比对模板，什么样子的？</li></ul></li><li>博客 显示pdf，插件可以同，本地显示可以，远程显示就不行了，而且加载很慢。（pdf太大了？已放弃）</li></ul><h4 id="16"><a href="#16" class="headerlink" title="16"></a>16</h4><ul><li>开发销管信息技术费追加结算功能。<ul><li>今天没工夫弄，22号之前弄完，23号提测</li></ul></li><li>COREPRPALL-1090生产升级<ul><li>加个字段，后方3个系统都要。。。。升级好麻烦</li><li>common打包</li><li>承保应用打包升级</li><li>auto-dubbo打包升级</li><li>common-dubbo</li><li>异步转发系统打包升级</li><li>reins-dubbo打包升级</li></ul></li><li>升级好麻烦，打算弄个自动升级的<ul><li>有现成的自动化部署的中间件，没研究过</li><li>自己写一个？有构思</li></ul></li></ul><h4 id="20"><a href="#20" class="headerlink" title="20"></a>20</h4><ul><li>开发销管信息技术费追加结算功能。</li></ul><h4 id="21"><a href="#21" class="headerlink" title="21"></a>21</h4><ul><li>开发销管信息技术费追加结算功能。<ul><li>先查出已结算的。排序，分组</li><li>设置费率。计算信息技术费</li><li>尾差处理。前面已经排完序，有多少处理多少，子表，一条直接处理，多条，处理前两条。</li></ul></li><li>发现数据库死锁问题<ul><li>事务很大，事务中有删除，插入。</li><li>在并发情况下，多事务同事提交，删除一方会因为锁膨胀的原因，持有更多的行锁，导致其他事务插入时无法拿到全部的行锁，进而相互持有，相互等待。</li><li>在事务中，尽量不要去进行数据交互，因为事务是否成功，不会影响数据的交互，进而会发生数据交互完毕，而事务落库失败。</li><li>这里有一个事务什么时候提交的衍生问题。</li><li>show ENGINE INNODB STATUS 查看innodb中的状态，可以看到报错。</li></ul></li></ul><h4 id="22"><a href="#22" class="headerlink" title="22"></a>22</h4><ul><li>开发销管信息技术费追加结算功能。</li></ul><h4 id="23"><a href="#23" class="headerlink" title="23"></a>23</h4><ul><li>开发销管信息技术费追加结算功能。</li><li>单点登录<ul><li>session共享问题？访问连接是持续的？</li></ul></li></ul><h4 id="24"><a href="#24" class="headerlink" title="24"></a>24</h4><ul><li>开发销管信息技术费追加结算功能。继续扣</li><li>填写报工系统<ul><li>coreprpall-1090 到16号 </li><li>coreprpall-1165 7.16-24 健康告知</li><li>z 7-24</li></ul></li></ul><h4 id="27"><a href="#27" class="headerlink" title="27"></a>27</h4><ul><li>开发销管信息技术费追加结算功能。开发完了。。真费劲</li><li>月结东西用kettel，放到服务器上。（未做）</li></ul><h4 id="28"><a href="#28" class="headerlink" title="28"></a>28</h4><ul><li>开发销管信息技术费追加结算功能。修改bug<ul><li>js找了一天</li><li>回调函数传没问题，例子方法有问题，只用了第一个字段</li></ul></li></ul><h4 id="29"><a href="#29" class="headerlink" title="29"></a>29</h4><ul><li>开发销管信息技术费追加结算功能。修改bug<ul><li>重构全部sql，当初怎么写的。</li><li>BigDecimal初始化问题，一万个都注意了，就漏了一个，导致算费不准确。</li></ul></li></ul><h4 id="30"><a href="#30" class="headerlink" title="30"></a>30</h4><ul><li>redis 分布式锁的归纳和整理</li><li>开发销管信息技术费追加结算功能。继续跟进测试</li><li>反洗钱数据治理，好坑</li></ul><h4 id="31"><a href="#31" class="headerlink" title="31"></a>31</h4><ul><li>反洗钱数据治理，好坑</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 工作日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字大小写</title>
      <link href="/tools/20190307/"/>
      <url>/tools/20190307/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h2 id="数字大小写"><a href="#数字大小写" class="headerlink" title="数字大小写"></a>数字大小写</h2><h3 id="小写转大写"><a href="#小写转大写" class="headerlink" title="小写转大写"></a>小写转大写</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;硬性拆分</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public  String digitUppercase(String num) throws Exception&#123;  </span><br><span class="line">        String fraction[] &#x3D; &#123;&quot;角&quot;, &quot;分&quot;&#125;;  </span><br><span class="line">        String digit[] &#x3D; &#123; &quot;零&quot;, &quot;壹&quot;, &quot;贰&quot;, &quot;叁&quot;, &quot;肆&quot;, &quot;伍&quot;, &quot;陆&quot;, &quot;柒&quot;, &quot;捌&quot;, &quot;玖&quot; &#125;;</span><br><span class="line">        String unit1[] &#x3D; &#123;&quot;&quot;, &quot;拾&quot;, &quot;佰&quot;, &quot;仟&quot;&#125;;&#x2F;&#x2F;把钱数分成段,每四个一段,实际上得到的是一个二维数组  </span><br><span class="line">        String unit2[] &#x3D; &#123;&quot;元&quot;, &quot;万&quot;, &quot;亿&quot;,&quot;万亿&quot;&#125;; &#x2F;&#x2F;把钱数分成段,每四个一段,实际上得到的是一个二维数组  </span><br><span class="line">        BigDecimal bigDecimal &#x3D;  new BigDecimal(num);  </span><br><span class="line">        bigDecimal&#x3D;bigDecimal.multiply(new BigDecimal(100));  </span><br><span class="line">        String strVal &#x3D; String.valueOf(bigDecimal.toBigInteger());  </span><br><span class="line">        if(&quot;0&quot;.equals(strVal))&#123;</span><br><span class="line">        strVal &#x3D; &quot;000&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        String head &#x3D; strVal.substring(0,strVal.length()-2);         &#x2F;&#x2F;整数部分  </span><br><span class="line">        String end &#x3D; strVal.substring(strVal.length()-2);              &#x2F;&#x2F;小数部分  </span><br><span class="line">        String endMoney&#x3D;&quot;&quot;;  </span><br><span class="line">        String headMoney &#x3D; &quot;&quot;;  </span><br><span class="line">        if(&quot;00&quot;.equals(end))&#123;  </span><br><span class="line">            endMoney &#x3D; &quot;整&quot;;  </span><br><span class="line">        &#125;else&#123;  </span><br><span class="line">            if(!end.substring(0,1).equals(&quot;0&quot;))&#123;  </span><br><span class="line">                endMoney+&#x3D;digit[Integer.valueOf(end.substring(0,1))]+&quot;角&quot;;  </span><br><span class="line">            &#125;else if(end.substring(0,1).equals(&quot;0&quot;) &amp;&amp; !end.substring(1,2).equals(&quot;0&quot;))&#123;  </span><br><span class="line">                endMoney+&#x3D; &quot;零&quot;;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if(!end.substring(1,2).equals(&quot;0&quot;))&#123;  </span><br><span class="line">                endMoney+&#x3D;digit[Integer.valueOf(end.substring(1,2))]+&quot;分&quot;;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        char[] chars &#x3D; head.toCharArray();  </span><br><span class="line">        Map&lt;String,Boolean&gt; map &#x3D; new HashMap&lt;String,Boolean&gt;();&#x2F;&#x2F;段位置是否已出现zero  </span><br><span class="line">        boolean zeroKeepFlag &#x3D; false;&#x2F;&#x2F;0连续出现标志  </span><br><span class="line">        int vidxtemp &#x3D; 0;  </span><br><span class="line">        for(int i&#x3D;0;i&lt;chars.length;i++)&#123;  </span><br><span class="line">            int idx &#x3D; (chars.length-1-i)%4;&#x2F;&#x2F;段内位置  unit1  </span><br><span class="line">            int vidx &#x3D; (chars.length-1-i)&#x2F;4;&#x2F;&#x2F;段位置 unit2  </span><br><span class="line">            String s &#x3D; digit[Integer.valueOf(String.valueOf(chars[i]))];  </span><br><span class="line">            if(!&quot;零&quot;.equals(s))&#123;  </span><br><span class="line">                headMoney +&#x3D; s +unit1[idx]+unit2[vidx];  </span><br><span class="line">                zeroKeepFlag &#x3D; false;  </span><br><span class="line">            &#125;else if(i&#x3D;&#x3D;chars.length-1 || map.get(&quot;zero&quot;+vidx)!&#x3D;null)&#123;  </span><br><span class="line">                headMoney +&#x3D; &quot;&quot; ;  </span><br><span class="line">            &#125;else&#123;  </span><br><span class="line">                headMoney +&#x3D; s;  </span><br><span class="line">                zeroKeepFlag &#x3D; true;  </span><br><span class="line">                map.put(&quot;zero&quot;+vidx,true);&#x2F;&#x2F;该段位已经出现0；  </span><br><span class="line">            &#125;  </span><br><span class="line">            if(vidxtemp!&#x3D;vidx || i&#x3D;&#x3D;chars.length-1)&#123;  </span><br><span class="line">                headMoney &#x3D; headMoney.replaceAll(unit2[vidx],&quot;&quot;);  </span><br><span class="line">                headMoney+&#x3D;unit2[vidx];  </span><br><span class="line">            &#125;  </span><br><span class="line">            if(zeroKeepFlag &amp;&amp; (chars.length-1-i)%4&#x3D;&#x3D;0)&#123;  </span><br><span class="line">                headMoney &#x3D; headMoney.replaceAll(&quot;零&quot;,&quot;&quot;);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        return &quot;元整&quot;.equals(headMoney+endMoney)?&quot;零元整&quot;:headMoney+endMoney;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目</title>
      <link href="/project/20190110/"/>
      <url>/project/20190110/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />### 承保系统项目架构图（太大，不好画）<a id="more"></a><ul><li>登陆用单点系统，做到集群下，多个系统，不需要重复登陆<ul><li>使用acegi security安全框架处理，应用请求先通过acegi security的拦截器，判断是否已经登陆，在redis进行查询，集群或多系统配置，需要对系统进行重命名。</li><li>请求时，先经过拦截器，多个拦截器，登出，登陆，匿名处理，异常处理，安全处理。</li><li>登陆之后，sessionid放到redis中，生成cookie存放到浏览器。</li><li>登出时候，销毁cookie和redis中的数据，抛弃当前session。</li><li>超时或异常时，重定向，销毁cookie和redis中的数据，抛弃当前session。</li></ul></li><li>jsp（struts2的自定义标签。重redis中获取数据）+js</li><li>spring（事务）+struts2+hibernate（连接池）</li><li>mysql（分库分表，读写分离？）+redis（存放不宜改变的，不用多次查询数据库，不作为数据缓冲）</li><li>侧面有dubbo（服务模块化，水平拓展，支持高并发。中间连带垂直拓展，由于业务性质导致，数据表比较多）+zookeeper（注册中心集群，1主2辅，2n+1的模式，防脑裂，节省资源）</li><li>activitymq降低并发，处理实时性不高的业务。</li><li>服务接口有servlet和webservice，webservice框架用的axis2-1.4.1版本。<ul><li>axis2版本之间兼容性比较差，自定义类型在反射的时候，类型有可能会变化。接口定义的时候，如果传输的是对象，注意序列化问题。List没有序列化，ArrayList有序列化，另外，泛型的转换的问题。</li></ul></li><li>文件解析用的poi</li></ul><h3 id="异步系统"><a href="#异步系统" class="headerlink" title="异步系统"></a>异步系统</h3><ul><li>没有页面</li><li>maven管理项目包,springboot+Mybatis</li><li>activitymq消费，直连dubbo，仅仅做数据的转发。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值的整数次方</title>
      <link href="/offer/Offer_12/"/>
      <url>/offer/Offer_12/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</li><li>保证base和exponent不同时为0。<a id="more"></a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>考虑exponent是正负的情况。10^1011=10^1000*10^0010*10^0001;指数&gt;&gt;1，底数^2，结果是一样的，exponent&amp;1==1只有位值为1的才计算，底数并翻倍了。</code></pre><h3 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public double Power(double base, int exponent) &#123;</span><br><span class="line">        double result &#x3D; 1;</span><br><span class="line">        int a &#x3D; exponent;</span><br><span class="line">        if(base &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(exponent &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(exponent &lt; 0)&#123;</span><br><span class="line">            exponent &#x3D; -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        while (exponent!&#x3D;0) &#123;</span><br><span class="line">            if((exponent&amp;1)&#x3D;&#x3D;1)&#123;</span><br><span class="line">                result*&#x3D;base;</span><br><span class="line">            &#125;</span><br><span class="line">            base*&#x3D;base;</span><br><span class="line">            exponent &gt;&gt;&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return a &gt; 0?result:1&#x2F;result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制中1的个数</title>
      <link href="/offer/Offer_11/"/>
      <url>/offer/Offer_11/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<a id="more"></a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>先区分正负数，正数，正常二进制，数数即可。            负数，正常二进制的补码（最高位为标记位，1代表负数，剩下位取反后加1）。java中int是4字节，32位，需要注意。在底层，正负数的确是是以二进制的方式存在的，并且负数就是补码的形式.&amp;的方式，可以检验出数据中是否含有0，如果有0， 那么返回就是0。n!=0;那么起码有1个1;(n - 1) &amp; n;&amp;的方式，可以保留左侧相同的部分留下，右侧数值都是1的。并缩减了比较次数。</code></pre><h3 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int NumberOf1(int n) &#123;</span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        while(n !&#x3D; 0)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            n &#x3D; (n - 1) &amp; n;</span><br><span class="line">        &#125;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩形覆盖</title>
      <link href="/offer/Offer_10/"/>
      <url>/offer/Offer_10/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。</li><li>请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？<a id="more"></a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>target=1,f(1)=1;target=2,f(2)=2;target=3,f(3)=f(1)+f(2);....target=n-1,当剩最后一块：f(n-1)=f(n-2);                  当剩最后两块：f(n-1)=2f(n-3);target=n,当剩最后一块：f(n)=f(n-1)(竖);         当剩最后两块：f(n)=f(n-2)(横)+f(n-2)(竖);有一种情况包含了f(n-1)(竖),         那么两个公式可以合并为f(n)=f(n-2)+f(n-1);</code></pre><h3 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int RectCover(int target) &#123;</span><br><span class="line">        int a &#x3D; 1;</span><br><span class="line">        int b &#x3D; 2;</span><br><span class="line">        int c &#x3D; 0;</span><br><span class="line">        if(target&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else if(target&#x3D;&#x3D;2)&#123;</span><br><span class="line">            return 2;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            for (int i &#x3D; 3; i &lt;&#x3D; target; i++) &#123;</span><br><span class="line">                c &#x3D; a + b;</span><br><span class="line">                a &#x3D; b;</span><br><span class="line">                b &#x3D; c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变态跳台阶</title>
      <link href="/offer/Offer_09/"/>
      <url>/offer/Offer_09/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。</li><li>求该青蛙跳上一个n级的台阶总共有多少种跳法。<a id="more"></a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>逆推思想，最后一次能跳几级。当n=1时，一次能跳1级，最后一次能跳1级，那么f（1）=f（1-1）=1。当n=2时，一次能跳1、2级，最后一次能跳1级，那么f（2）=f（2-1）。                  最有一次能跳2级，那么f（2）=f（2-2）。                  f（2）=f（2-1）+f（2-2）。当n=3时，一次能跳1、2、3级，最后一次能跳1级，那么f（3）=f（3-1）。                             最有一次能跳2级，那么f（3）=f（3-2）。                             最有一次能跳2级，那么f（3）=f（3-3）。当n=n时，一次能跳1、2、3.....n-2、n-1、n,那么f（n）=f（n-1）+f（n-2）+f（n-3）.......+f（n-（n-2））+f（n-（n-1））+f（n-n）。简化为f（n）=f（0）+f（1）+f（2）+......+f（n-2）+f（n-1）。f（n-1）=f（0）+f（1）+f（2）+......+f（n-2）。那么f（n）=f（n-1）+f（n-1）=2*f（n-1）。1,2,4,8,16.....</code></pre><h3 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloorII(int target) &#123;</span><br><span class="line">        int a &#x3D; 1;</span><br><span class="line">        if(target&#x3D;&#x3D;0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else if(target&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for (int i &#x3D; 2; i &lt;&#x3D; target; i++) &#123;</span><br><span class="line">                a &#x3D; a&lt;&lt;1;</span><br><span class="line">            &#125;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳台阶</title>
      <link href="/offer/Offer_08/"/>
      <url>/offer/Offer_08/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>一只青蛙一次可以跳上1级台阶，也可以跳上2级。</li><li>求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<a id="more"></a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>限定了青蛙一次只能有两种跳法，用逆推方式去思考如果最后一次跳1级，那么一共有f（n-1）种跳法。如果最后一次跳2级，那么一共有f（n-2）种跳法。那么，f（n）=f（n-1）+f（n-2）。当n=0时，f（0）=0。当n=1时，只有一种f（1）=1。当n=2时，有两种情况f（2）=2。当n=3时，就符合f（n）=f（n-1）+f（n-2）。可以想到是斐波那契数列的变形。0,1,2,3,5,8...</code></pre><h3 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int JumpFloor(int target) &#123;</span><br><span class="line">        int a &#x3D; 0;</span><br><span class="line">        int b &#x3D; 1;</span><br><span class="line">        int c &#x3D; 0;</span><br><span class="line">        if(target&lt;0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for (int i &#x3D; 1; i &lt;&#x3D; target; i++) &#123;</span><br><span class="line">                c &#x3D; a + b;</span><br><span class="line">                a &#x3D; b;</span><br><span class="line">                b &#x3D; c;</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契数列</title>
      <link href="/offer/Offer_07/"/>
      <url>/offer/Offer_07/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</li><li>n&lt;=39<a id="more"></a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>纯粹的斐波那契数列，0,1,1,2,3,5,8....n=0时，an=-1;n=1时，an=a1=0;n=2时，an=a2=1;n&gt;2时，an=an-2+an-1;</code></pre><h3 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        int a &#x3D; 0;</span><br><span class="line">        int b &#x3D; 1;</span><br><span class="line">        int c &#x3D; 0;</span><br><span class="line">        if(n &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return a;</span><br><span class="line">        &#125;else if(n &#x3D;&#x3D; 1)&#123;</span><br><span class="line">            return b;</span><br><span class="line">        &#125;else if(n &gt; 1)&#123;</span><br><span class="line">            for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">                c &#x3D; a + b;</span><br><span class="line">                a &#x3D; b;</span><br><span class="line">                b &#x3D; c;</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转数组的最小数字</title>
      <link href="/offer/Offer_06/"/>
      <url>/offer/Offer_06/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</li><li>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</li><li>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</li><li>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<a id="more"></a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><pre><code>二分法，时间复杂度O（logn）遍历，O（n）在没有重复项的时候，可以用二分法进行。在于缩小查询范围。数量级比较大的时候，可以考虑多线程，进行分段检索。</code></pre><h3 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int minNumberInRotateArray(int [] array) &#123;</span><br><span class="line">        return min(array,0,array.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int min(int [] array,int leftIndex,int length)&#123;</span><br><span class="line">        if(length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(length&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return array[leftIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        if(length&#x3D;&#x3D;2)&#123;</span><br><span class="line">            return array[leftIndex]&gt;array[leftIndex+1]?array[leftIndex+1]:array[leftIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        int midIndex;</span><br><span class="line">        boolean flag &#x3D; length % 2 &gt; 0 ;&#x2F;&#x2F;偶数</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            midIndex &#x3D; length &#x2F; 2 + leftIndex;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            midIndex &#x3D; length &#x2F; 2 + leftIndex - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(array[midIndex] &lt; array[midIndex-1])&#123;</span><br><span class="line">            return array[midIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        if(array[midIndex] &gt; array[midIndex+1])&#123;</span><br><span class="line">            return array[midIndex+1];</span><br><span class="line">        &#125;</span><br><span class="line">        int left;</span><br><span class="line">        int right;</span><br><span class="line">        if(flag)&#123;</span><br><span class="line">            length &#x3D; length &#x2F; 2;</span><br><span class="line">            left &#x3D; min(array,midIndex - length,length);</span><br><span class="line">            right &#x3D; min(array,midIndex + 1,length);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            length &#x3D; length &#x2F; 2;</span><br><span class="line">            left &#x3D; min(array,midIndex - length + 1,length - 1);</span><br><span class="line">            right &#x3D; min(array,midIndex + 1,length);</span><br><span class="line">        &#125;</span><br><span class="line">        if(left &#x3D;&#x3D; 0 &amp;&amp; right &#x3D;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(left !&#x3D; 0 &amp;&amp; right !&#x3D; 0)</span><br><span class="line">            return left&gt;right?right:left;</span><br><span class="line">        return 0;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用两个栈实现队列</title>
      <link href="/offer/Offer_05/"/>
      <url>/offer/Offer_05/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<a id="more"></a></li></ul><blockquote><p>栈：后进先出（LIFO-last in first out）<br>队列：现进先出（FIFO-first in first out）</p></blockquote><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><pre><code>stack1为入口，stack2为出口。push的时候，只压入stack1。pop的时候，stack2没有数据，就从stack1中数据导入，stack1弹出，stack2压入。pop的时候，stack2有数据的时候，直接弹出。</code></pre><h3 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class Solution &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        if(stack2.empty()&amp;&amp;!stack1.empty())&#123;</span><br><span class="line">            while(!stack1.empty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重建二叉树</title>
      <link href="/offer/Offer_04/"/>
      <url>/offer/Offer_04/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都<code>不含重复</code>的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<a id="more"></a></li></ul><blockquote><ul><li>前序遍历：<ul><li>访问根节点 </li><li>前序遍历左子树 </li><li>前序遍历右子树</li></ul></li><li>中序遍历：<ul><li>中序遍历左子树 </li><li>访问根节点 </li><li>中序遍历右子树</li></ul></li><li>后序遍历：<ul><li>后序遍历左子树 </li><li>后序遍历右子树 </li><li>访问根节点</li></ul></li></ul></blockquote><ul><li>思路：<br>   1<br> 2   3<br>4 5 6 8<br>7</li></ul><h3 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123;</span><br><span class="line">        TreeNode root &#x3D; reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span><br><span class="line">    public TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn)&#123;</span><br><span class="line">         if(startPre&gt;endPre||startIn&gt;endIn)</span><br><span class="line">            return null;</span><br><span class="line">        TreeNode root&#x3D;new TreeNode(pre[startPre]);</span><br><span class="line">         </span><br><span class="line">        for(int i&#x3D;startIn;i&lt;&#x3D;endIn;i++)</span><br><span class="line">            if(in[i]&#x3D;&#x3D;pre[startPre])&#123;</span><br><span class="line">                root.left&#x3D;reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1);</span><br><span class="line">                root.right&#x3D;reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn);</span><br><span class="line">            &#125;</span><br><span class="line">                 </span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从尾到头打印链表</title>
      <link href="/offer/Offer_03/"/>
      <url>/offer/Offer_03/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。<a id="more"></a></li><li>思路：</li><li>正常思路：利用递归，循环到最后，进行插入</li><li>C++ vector的特性，可以插入特定位置</li><li>java arraylist有Collections工具类，可以直接插入，然后反转</li></ul><h3 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; vr;</span><br><span class="line">        if (head !&#x3D; NULL)&#123;</span><br><span class="line">            vr.insert(vr.begin(), head-&gt;val);</span><br><span class="line">while (head-&gt;next !&#x3D; NULL)&#123;</span><br><span class="line">                head &#x3D; head-&gt;next;</span><br><span class="line">vr.insert(vr.begin(), head-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        return vr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">*    public class ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        ListNode next &#x3D; null;</span><br><span class="line">*</span><br><span class="line">*        ListNode(int val) &#123;</span><br><span class="line">*            this.val &#x3D; val;</span><br><span class="line">*        &#125;</span><br><span class="line">*    &#125;</span><br><span class="line">*</span><br><span class="line">*&#x2F;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123;</span><br><span class="line">        if(listNode !&#x3D; null)&#123;</span><br><span class="line">            if(listNode.next!&#x3D;null)&#123;</span><br><span class="line">                list &#x3D; printListFromTailToHead(listNode.next);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>替换空格</title>
      <link href="/offer/Offer_02/"/>
      <url>/offer/Offer_02/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<a id="more"></a></li><li>思路：</li><li>用另一个字符串去存储，思路简单，但消耗内存</li><li>用同一个字符串做处理，都需要先获取空格的个数，两种方式，但耗时间，做两次循环<ul><li>从前向后移动字符串，空格后的字符每次都要移动，消耗时间比第二种更多</li><li>从后向前移动字符串，字符只移动一次</li></ul></li><li>这里只给从后向前的方式</li></ul><h3 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void replaceSpace(char *str,int length) &#123;</span><br><span class="line">        int spaceNum &#x3D; 0;</span><br><span class="line">        int pIndexOld &#x3D; 0;</span><br><span class="line">        while (str[pIndexOld] !&#x3D; &#39;\0&#39;)&#x2F;&#x2F;char * 有&#39;\0&#39;结尾，string没有</span><br><span class="line">        &#123;</span><br><span class="line">            if (str[pIndexOld++] &#x3D;&#x3D; &#39; &#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                spaceNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int pIndexNew &#x3D; pIndexOld + spaceNum * 2;</span><br><span class="line">        if(pIndexNew&gt;length)&#x2F;&#x2F;length作用的猜想，应该是str的长度</span><br><span class="line">        &#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        while (pIndexNew !&#x3D; pIndexOld)</span><br><span class="line">        &#123;</span><br><span class="line">            if (str[pIndexOld] &#x3D;&#x3D; &#39; &#39;)</span><br><span class="line">            &#123;</span><br><span class="line">                str[pIndexNew--] &#x3D; &#39;0&#39;;</span><br><span class="line">                str[pIndexNew--] &#x3D; &#39;2&#39;;</span><br><span class="line">                str[pIndexNew] &#x3D; &#39;%&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                str[pIndexNew] &#x3D; str[pIndexOld];</span><br><span class="line">            &#125;</span><br><span class="line">            pIndexNew--;</span><br><span class="line">            pIndexOld--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java 1.8"></a>Java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public String replaceSpace(StringBuffer str) &#123;</span><br><span class="line">        int spaceNum &#x3D; 0;&#x2F;&#x2F;字符串中空格的个数</span><br><span class="line">        for (int i &#x3D; 0; i &lt; str.length(); i++) &#123;</span><br><span class="line">        if(str.charAt(i) &#x3D;&#x3D; &#39; &#39;)&#123;</span><br><span class="line">        spaceNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int indexOld &#x3D; str.length()-1;&#x2F;&#x2F;原长度下，最有一个字符的下标</span><br><span class="line">        &#x2F;&#x2F;重设StringBuffer长度，不然会有空指针，空格换%20，多空格的2倍长度</span><br><span class="line">        str.setLength(str.length()+spaceNum*2);</span><br><span class="line">        int indexNew &#x3D; str.length()-1;&#x2F;&#x2F;新长度下，最有一个字符的下标</span><br><span class="line">        &#x2F;&#x2F;当indexNew和indexOld相等时，说明前面就没有空格了，即可退出</span><br><span class="line">        while (indexNew !&#x3D; indexOld) &#123;</span><br><span class="line">        if(str.charAt(indexOld) &#x3D;&#x3D; &#39; &#39;)&#123;</span><br><span class="line">        str.setCharAt(indexNew--, &#39;0&#39;);</span><br><span class="line">        str.setCharAt(indexNew--, &#39;2&#39;);</span><br><span class="line">        str.setCharAt(indexNew--, &#39;%&#39;);</span><br><span class="line">        </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">        str.setCharAt(indexNew--, str.charAt(indexOld));</span><br><span class="line">        &#125;</span><br><span class="line">        indexOld--;</span><br><span class="line">        &#125;</span><br><span class="line">        return str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维数组中的查找</title>
      <link href="/offer/Offer_01/"/>
      <url>/offer/Offer_01/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>在一个二维数组中<code>（每个一维数组的长度相同）</code>，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<a id="more"></a></li></ul><ul><li>思路：从左下角开始，向右变大（x++），向上变小（y–）</li><li>1 2 3 4</li><li>2 3 4 5</li><li>3 4 5 6</li><li>4 5 6 7</li></ul><h3 id="C-11"><a href="#C-11" class="headerlink" title="C++ 11"></a>C++ 11</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array)</span><br><span class="line">&#123;</span><br><span class="line">        &#x2F;&#x2F;标志是否存在</span><br><span class="line">    bool isExist &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;纵向长度</span><br><span class="line">        int lenghtY &#x3D; array.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; array[0].size();)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;lenghtY-1 是数组纵向长度坐标，小于0退出</span><br><span class="line">            &#x2F;&#x2F;array[0].lenght 一维数组的长度，每个一维数组的长度相同，那不相等的呢</span><br><span class="line">            if (lenghtY - 1 &lt; 0 || i &gt; array[0].size())</span><br><span class="line">            &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if (target &gt; array[lenghtY - 1][i])&#x2F;&#x2F;大于右移</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (target &lt; array[lenghtY - 1][i])</span><br><span class="line">            &#123;</span><br><span class="line">                lenghtY--;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (target &#x3D;&#x3D; array[lenghtY - 1][i])</span><br><span class="line">            &#123;</span><br><span class="line">                isExist &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return isExist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="java-1-8"><a href="#java-1-8" class="headerlink" title="java 1.8"></a>java 1.8</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean Find(int target, int [][] array) &#123;</span><br><span class="line">        &#x2F;&#x2F;标志是否存在</span><br><span class="line">        boolean isExist &#x3D; false;</span><br><span class="line">        &#x2F;&#x2F;纵向长度</span><br><span class="line">        int lenghtY &#x3D; array.length;</span><br><span class="line">        for (int i &#x3D; 0;i &lt; array[0].lenght)&#123;</span><br><span class="line">            &#x2F;&#x2F;lenghtY-1 是数组纵向长度坐标，小于0退出</span><br><span class="line">            &#x2F;&#x2F;array[0].lenght 一维数组的长度，每个一维数组的长度相同，那不相等的呢</span><br><span class="line">            if(lenghtY - 1 &lt; 0 || i &gt; array[0].lenght)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            if(target &gt; array[lenghtY - 1][i])&#123;&#x2F;&#x2F;大于右移</span><br><span class="line">                i++;</span><br><span class="line">            &#125;else if(target &lt; array[lenghtY - 1][i])&#123;</span><br><span class="line">                lenghtY--;</span><br><span class="line">            &#125;else if(target &#x3D;&#x3D; array[lenghtY - 1][i])&#123;</span><br><span class="line">                isExist &#x3D; true;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return isExist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer 汇总</title>
      <link href="/offer/Offer_00/"/>
      <url>/offer/Offer_00/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="剑指offer-汇总"><a href="#剑指offer-汇总" class="headerlink" title="剑指offer 汇总"></a>剑指offer 汇总</h3><p>我在github上也有创建项目，<a href="https://github.com/snmlm/Sword-means-Offer">地址</a></p><a id="more"></a><a href="/offer/Offer_01/" title="01、二维数组中的查找">01、二维数组中的查找</a><a href="/offer/Offer_02/" title="02、替换空格">02、替换空格</a><a href="/offer/Offer_03/" title="03、从尾到头打印链表">03、从尾到头打印链表</a><a href="/offer/Offer_04/" title="04、重建二叉树">04、重建二叉树</a><a href="/offer/Offer_05/" title="05、用两个栈实现队列">05、用两个栈实现队列</a><a href="/offer/Offer_06/" title="06、旋转数组的最小数字">06、旋转数组的最小数字</a><a href="/offer/Offer_07/" title="07、斐波那契数列">07、斐波那契数列</a><a href="/offer/Offer_08/" title="08、跳台阶">08、跳台阶</a><a href="/offer/Offer_09/" title="09、变态跳台阶">09、变态跳台阶</a><a href="/offer/Offer_10/" title="10、矩形覆盖">10、矩形覆盖</a><a href="/offer/Offer_11/" title="11、二进制中1的个数">11、二进制中1的个数</a><a href="/offer/Offer_12/" title="12、数值的整数次方">12、数值的整数次方</a>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rest与rpc区别</title>
      <link href="/network/20200612/"/>
      <url>/network/20200612/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />#### OSI网络七层模型* 第一层：应用层。定义了用于在网络中进行通信和传输数据的接口；* 第二层：表示层。定义不同的系统中数据的传输格式，编码和解码规范等；* 第三层：会话层。管理用户的会话，控制用户间逻辑连接的建立和中断；* 第四层：传输层。管理着网络中的端到端的数据传输；* 第五层：网络层。定义网络设备间如何传输数据；* 第六层：链路层。将上面的网络层的数据包封装成数据帧，便于物理层传输；* 第七层：物理层。这一层主要就是传输这些二进制数据<a id="more"></a><p>实际应用过程中，五层协议结构里面是没有表示层和会话层的。应该说它们和应用层合并了。我们应该将重点放在应用层和传输层这两个层面，因为RPC主要是基于TCP/IP协议（传输层协议），HTTP主要是基于HTTP协议（应用层协议）。</p><h4 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h4><p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。<br>REST是一种架构风格，指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。REST规范把所有内容都视为资源，网络上一切皆资源。REST并没有创造新的技术，组件或服务，只是使用Web的现有特征和能力。 </p><h5 id="资源（Resources）"><a href="#资源（Resources）" class="headerlink" title="资源（Resources）"></a>资源（Resources）</h5><p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。<br>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><h5 id="表现层（Representation）"><a href="#表现层（Representation）" class="headerlink" title="表现层（Representation）"></a>表现层（Representation）</h5><p>“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。<br>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。<br>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><h5 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h5><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。<br>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。<br>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</p><p>HTTP动词与REST风格CRUD对应关系：</p><table><thead><tr><th>Method</th><th>CRUD</th></tr></thead><tbody><tr><td>POST</td><td>create/update/delete</td></tr><tr><td>GET</td><td>read</td></tr><tr><td>PUT</td><td>update/create</td></tr><tr><td>DELETE</td><td>delete</td></tr><tr><td>综合上面的解释，我们总结一下什么是RESTful架构：</td><td></td></tr></tbody></table><ul><li>每一个URI代表一种资源；</li><li>客户端和服务器之间，传递这种资源的某种表现层；</li><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。</li></ul><h4 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h4><p>必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致API构架的流行，甚至出现”API First”的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>REST本身并没有创造新的技术、组件或服务，而隐藏在RESTful背后的理念就是使用Web的现有特征和能力， 更好地使用现有Web标准中的一些准则和约束。虽然REST本身受Web技术的影响很深， 但是理论上REST架构风格并不是绑定在HTTP上，只不过目前HTTP是唯一与REST相关的实例。 所以上面描述的REST也是通过HTTP实现的REST。</p><h4 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h4><p>RPC（Remote Procedure Call），即远程过程调用，是一个分布式系统间通信的必备技术。RPC 最核心要解决的问题就是在分布式系统间，如何执行另外一个地址空间上的函数、方法，就仿佛在本地调用一样。</p><h4 id="dubbo与rpc"><a href="#dubbo与rpc" class="headerlink" title="dubbo与rpc"></a>dubbo与rpc</h4><p>tcp、udp是传输层。<br>http在应用层。<br>http协议基于tcp实现。<br>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，才能使用TCP/IP协议。<br>socket可以实现tcp和udp协议。<br>rpc是基于socket实现的。<br>dubbo基于netty实现socket通信。<br>所以说dubbo是一个高性能和透明化的RPC远程服务调用方案<br>grpc是http2实现的。</p><h5 id="传输（Transport）"><a href="#传输（Transport）" class="headerlink" title="传输（Transport）"></a>传输（Transport）</h5><p>TCP 协议是 RPC 的 基石，一般来说通信是建立在 TCP 协议之上的，而且 RPC 往往需要可靠的通信，因此不采用 UDP。<br>RPC 传输的 message 也就是 TCP body 中的数据，这个 message 也同样可以包含 header+body。body 也经常叫做 payload。<br>TCP 协议栈存在端口的概念，端口是进程获取数据的渠道。</p><h5 id="I-O-模型（I-O-Model）"><a href="#I-O-模型（I-O-Model）" class="headerlink" title="I/O 模型（I/O Model）"></a>I/O 模型（I/O Model）</h5><p>做一个高性能 /scalable 的 RPC，需要能够满足：</p><ul><li>服务端尽可能多的处理并发请求</li><li>同时尽可能短的处理完毕。</li></ul><p>Socket I/O 可以看做是二者之间的桥梁，如何更好地协调二者，去满足前面说的两点要求，有一些模式（pattern）是可以应用的。RPC 框架可选择的 I/O 模型严格意义上有 5 种，这里不讨论基于信号驱动的I/O（Signal Driven I/O）。它们分别是：</p><ul><li>传统的阻塞 I/O（Blocking I/O）BIO/IO</li><li>非阻塞 I/O（Non-blocking I/O）NIO</li><li>I/O 多路复用（I/O multiplexing）</li><li>异步 I/O（Asynchronous I/O）AIO</li></ul><p>这里不细说每种I/O模型。这里举一个形象的例子，读者就可以领会这四种I/O的区别，就用银行办业务 这个生活的场景描述。</p><h6 id="传统的阻塞-I-O模型"><a href="#传统的阻塞-I-O模型" class="headerlink" title="传统的阻塞 I/O模型"></a>传统的阻塞 I/O模型</h6><p>一个柜员服务所有客户，可见当客户填写单据的时候也就是发生网络I/O的时候，柜员(也就是宝贵的线程或者进程)就会被阻塞，白白浪费了 CPU 资源，无法服务后面的请求。<br>如果一个柜员不够，那么就并发处理，对应采用线程池或者多进程方案，一个客户对应一个柜员，这明显加大了并发度，在并发不高的情况下性能够用，但是仍然存在柜员被 I/O 阻塞的可能。</p><h6 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h6><p>存在一个大堂经理，相当于代理，它来负责所有的客户，只有当客户写好单据后，才把客户分配一个柜员处理，可以想象柜员不用阻塞在 I/O 读写上，这样柜员效率会非常高，这也就是 I/O 多路复用的精髓。</p><blockquote><p>基于内核，建立在epoll或者kqueue上实现，I/O多路复用最大的优势是用户可以在一个线程内同时处理多个Socket的I/O请求。通过一个线程监听全部的TCP连接，有任何事件发生就通知用户态处理即可。</p></blockquote><h6 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h6><p>完全不存在大堂经理，银行有一个天然的“高级的分配机器”，柜员注册自己负责的业务类型，例如 I/O 可读，那么由这个“高级的机器”负责I/O读，当可读时候，通过回调机制，把客户已经填写完毕的单据主动交给柜员，回调其函数完成操作。</p><blockquote><p>这里重点说下同步 I/O 和异步I/O，理论上前三种模型都叫做同步I/O，同步是指用户线程发起I/O请求后需要等待或者轮询内核I/O完成后再继续，而异步是指用户线程发起I/O请求直接退出，当内核I/O操作完成后会通知用户线程来调用其回调函数。</p></blockquote><blockquote><p>I/O 多路复用往往对应 Reactor 模式，异步 I/O 往往对应 Proactor。<br>Reactor 一般使用epoll+事件驱动的经典模式，通过分治的手段，把耗时的网络连接、安全认证、编码等工作交给专门的线程池或者进程去完成，然后再去调用真正的核心业务逻辑层，这在 <em>nix 系统中被广泛使用。<br>著名的 Redis、Nginx、Node.js 的 Socket I/O 都用的这个，而 Java 的 NIO 框架 Netty 也是，Spark 2.0 RPC 所依赖的同样采用了 Reactor 模式。<br>Proactor在</em>nix中没有很好的实现，但是在Windows上大放异彩（例如 IOCP 模型）。<br>说个具体的例子，Thrift 作为一个融合了 序列化+RPC 的框架，提供了很多种 Server 的构建选项。</p></blockquote><blockquote><p>在Reactor中实现读：</p></blockquote><ul><li>注册读就绪事件和相应的事件处理器</li><li>事件分离器等待事件</li><li>事件到来，激活分离器，分离器调用事件对应的处理器。</li><li>事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。</li></ul><blockquote><p>在Proactor中实现读：</p></blockquote><ul><li>处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。</li><li>事件分离器等待操作完成事件</li><li>在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。</li><li>事件分离器呼唤处理器。</li><li>事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。</li></ul><blockquote><p>可以看出，两个模式的相同点，都是对某个IO事件的事件通知(即告诉某个模块，这个IO操作可以进行或已经完成)。在结构上，两者也有相同点：demultiplexor负责提交IO操作(异步)、查询设备是否可操作(同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下(Proactor)，当回调handler时，表示IO操作已经完成；同步情况下(Reactor)，回调handler时，表示IO设备可以进行某个操作(can read or can write)。</p></blockquote><h5 id="Schema-和序列化（Schema-amp-Data-Serialization）"><a href="#Schema-和序列化（Schema-amp-Data-Serialization）" class="headerlink" title="Schema 和序列化（Schema &amp; Data Serialization）"></a>Schema 和序列化（Schema &amp; Data Serialization）</h5><p>序列化和反序列化，是做对象到二进制数据的转换。<br>程序是可以理解对象的，对象一般含有schema或者结构，基于这些语义来做特定的业务逻辑处理。<br>考察一个序列化框架一般会关注以下几点：</p><ul><li>Encoding format。是 human readable 还是 binary。</li><li>Schema declaration。也叫作契约声明，基于 IDL，比如 Protocol Buffers/Thrift，还是自描述的，比如 JSON、XML。另外还需要看是否是强类型的。</li><li>语言平台的中立性。比如 Java 的 Native Serialization 就只能自己玩，而 Protocol Buffers 可以跨各种语言和平台。</li><li>新老契约的兼容性。比如 IDL 加了一个字段，老数据是否还可以反序列化成功。</li><li>和压缩算法的契合度。跑benchmark和实际应用都会结合各种压缩算法，例如 gzip、snappy。</li><li>性能。这是最重要的，序列化、反序列化的时间，序列化后数据的字节大小是考察重点。</li></ul><p>序列化方式非常多，常见的有 Protocol Buffers， Avro，Thrift，XML，JSON，MessagePack，Kyro，Hessian，Protostuff，Java Native Serialize，FST。</p><h5 id="协议结构（Wire-Protocol）"><a href="#协议结构（Wire-Protocol）" class="headerlink" title="协议结构（Wire Protocol）"></a>协议结构（Wire Protocol）</h5><p>TCP 只是 binary stream 通道，是binary数据的可靠搬用工，它不懂 RPC 里面包装的是什么。而在一个通道上传输 message，势必涉及 message 的识别。<br>举个例子，正如下图中的例子，ABC+DEF+GHI 分 3 个 message，也就是分 3 个 Frame 发送出去，而接收端分四次收到 4 个 Frame。<br>Socket I/O 的工作完成得很好，可靠地传输过去，这是 TCP 协议保证的，但是接收到的是 4 个 Frame，不是原本发送的 3 个 message 对应的 3 个 Frame。<br>这种情况叫做发生了 TCP 粘包和半包 现象，AB、H、I 的情况叫做半包，CDEFG的情况叫做粘包。虽然顺序是对的，但是分组完全和之前对应不上。<br>这时候应用层如何做语义级别的 message 识别是个问题，只有做好了协议的结构，才能把一整个数据片段做序列化或者反序列化处理。<br>比如：memcache的换行符、http中的固定长度头。</p><h5 id="可靠性（Reliability）"><a href="#可靠性（Reliability）" class="headerlink" title="可靠性（Reliability）"></a>可靠性（Reliability）</h5><p>RPC 框架不光要处理 Network I/O、序列化、协议栈。还有很多不确定性问题要处理，这里的不确定性就是由 网络的不可靠 带来的麻烦。<br>例如如何保持长连接心跳？网络闪断怎么办？重连、重传？连接超时？这些都非常的细碎和麻烦，所以说开发好一个稳定的 RPC 类库是一个非常系统和细心的工程。<br>但是好在工业界有一群人就致力于提供平台似的解决方案，例如 Java 中的 Netty，它是一个强大的异步、事件驱动的网络 I/O 库，使用 I/O 多路复用的模型，做好了上述的麻烦处理。<br>它是面向对象设计模式的集大成者，使用方只需要会使用 Netty 的各种类，进行扩展、组合、插拔，就可以完成一个高性能、可靠的 RPC 框架。<br>著名的 gRPC Java 版本、Twitter 的 Finagle 框架、阿里巴巴的 Dubbo、新浪微博的 Motan、Spark 2.0 RPC 的网络层（可以参考 kraps-rpc：<a href="https://github.com/neoremind/kraps-rpc%EF%BC%89%E9%83%BD%E9%87%87%E7%94%A8%E4%BA%86%E8%BF%99%E4%B8%AA%E7%B1%BB%E5%BA%93%E3%80%82">https://github.com/neoremind/kraps-rpc）都采用了这个类库。</a></p><h5 id="易用性（Ease-of-use）"><a href="#易用性（Ease-of-use）" class="headerlink" title="易用性（Ease of use）"></a>易用性（Ease of use）</h5><p>RPC 是需要让上层写业务逻辑来实现功能的，如何优雅地启停一个 server，注入 endpoint，客户端怎么连，重试调用，超时控制，同步异步调用，SDK 是否需要交换等等，都决定了基于 RPC 构建服务，甚至 SOA 的工程效率与生产力高低。这里不做展开，看各种 RPC 的文档就知道他们的易用性如何了。</p><h5 id="工业界的-RPC-框架一览"><a href="#工业界的-RPC-框架一览" class="headerlink" title="工业界的 RPC 框架一览"></a>工业界的 RPC 框架一览</h5><p>国内</p><ul><li>Dubbo。来自阿里巴巴 <a href="http://dubbo.i/O/">http://dubbo.I/O/</a></li><li>Motan。新浪微博自用 <a href="https://github.com/weibocom/motan">https://github.com/weibocom/motan</a></li><li>Dubbox。当当基于dubbo的<a href="https://github.com/dangdangdotcom/dubbox">https://github.com/dangdangdotcom/dubbox</a></li><li>rpcx。基于 Golang 的 <a href="https://github.com/smallnest/rpcx">https://github.com/smallnest/rpcx</a></li><li>Navi &amp; Navi-pbrpc。作者开源的 <a href="https://github.com/neoremind/navi">https://github.com/neoremind/navi</a> <a href="https://github.com/neoremind/navi-pbrpc">https://github.com/neoremind/navi-pbrpc</a></li></ul><p>国外</p><ul><li>Thrift from facebook <a href="https://thrift.apache.org/">https://thrift.apache.org</a></li><li>Avro from hadoop <a href="https://avro.apache.org/">https://avro.apache.org</a></li><li>Finagle by twitter <a href="https://twitter.github.i/O/finagle">https://twitter.github.I/O/finagle</a></li><li>gRPC by Google <a href="http://www.grpc.i/O">http://www.grpc.I/O</a> (Google inside use Stuppy)</li><li>Hessian from cuacho <a href="http://hessian.caucho.com/">http://hessian.caucho.com</a></li><li>Coral Service inside amazon (not open sourced)</li></ul><p>上述列出来的都是现在互联网企业常用的解决方案，暂时不考虑传统的 SOAP，XML-RPC 等。这些是有网络资料的，实际上很多公司内部都会针对自己的业务场景，以及和公司内的平台相融合（比如监控平台等），自研一套框架，但是殊途同归，都逃不掉刚刚上面所列举的 RPC 的要考虑的各个部分。</p><h5 id="既然有-HTTP-请求，为什么还要用-RPC-调用"><a href="#既然有-HTTP-请求，为什么还要用-RPC-调用" class="headerlink" title="既然有 HTTP 请求，为什么还要用 RPC 调用"></a>既然有 HTTP 请求，为什么还要用 RPC 调用</h5><p>http好比普通话，rpc好比团伙内部黑话。讲普通话，好处就是谁都听得懂，谁都会讲。<br>讲黑话，好处是可以更精简、更加保密、更加可定制，坏处就是要求“说”黑话的那一方（client端）也要懂，而且一旦大家都说一种黑话了，换黑话就困难了。</p><h4 id="言归正传"><a href="#言归正传" class="headerlink" title="言归正传"></a>言归正传</h4><p>这个问题其实是有理解误区的，首先 http 和 rpc 并不是一个并行概念。rpc是远端过程调用，其调用协议通常包含传输协议和编码协议。<br>传输协议包含: 如著名的 [gRPC](grpc / grpc.io) 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。编码协议包含: 如基于文本编码的 xml json，也有二进制编码的 protobuf binpack 等。<br>因此问题应该是：为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？<br>要解决这个问题就应该搞清楚 http 使用的 tcp 协议，和我们自定义的 tcp 协议在报文上的区别。首先要否认一点 http 协议相较于自定义tcp报文协议，增加的开销在于连接的建立与断开。<br>http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。另外要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。<br>通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下:</p><blockquote><p>HTTP/1.0 200 OK<br>Content-Type: text/plain<br>Content-Length: 137582<br>Expires: Thu, 05 Dec 1997 16:00:00 GMT<br>Last-Modified: Wed, 5 August 1996 15:55:28 GMT<br>Server: Apache 0.84</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;Hello World&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>即使编码协议也就是body是使用二进制编码协议，报文元数据也就是header头的键值对却用了文本编码，非常占字节数。如上图所使用的报文中有效字节数仅仅占约 30%，也就是70%的时间用于传输元数据废编码。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。<br>自定义tcp协议可以极大地简化传输头内容。<br>所谓的效率优势是针对http1.1协议来讲的，http2.0协议已经优化编码效率问题，像grpc这种rpc库使用的就是http2.0协议。这么来说吧http容器的性能测试单位通常是kqps，自定义tpc协议则通常是以10kqps到100kqps为基准简单来说成熟的rpc库相对http容器，<br>更多的是封装了“服务发现”，”错误重试”一类面向服务的高级特性。可以这么理解，rpc框架是面向服务的更高级的封装。如果把一个http server容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tcp-ip</title>
      <link href="/network/20190311/"/>
      <url>/network/20190311/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />想了解tcp-ip协议的，或者说想了解互联网的，一定绕不过tcp-ip详解这本书https://github.com/snmlm/tcp-ip<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> tcp-ip </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux CTRL+Z和CTRL+C区别</title>
      <link href="/liunx/20190410/"/>
      <url>/liunx/20190410/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />### Linux CTRL+Z和CTRL+C区别#### ctrl+c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( kill foreground process ) 发送 SIGINT 信号给前台进程组中的所有进程，强制终止程序的执行；<a id="more"></a>#### ctrl+z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( suspend foreground process ) 发送 SIGTSTP 信号给前台进程组中的所有进程，常用于挂起一个进程，而并非结束进程，用户可以使用使用fg/bg操作恢复执行前台或后台的进程。fg命令在前台恢复执行被挂起的进程，此时可以使用ctrl+z再次挂起该进程，bg命令在后台恢复执行被挂起的进程，而此时将无法使用ctrl+z再次挂起该进程；<ul><li>CTRL+Z停止进程并放入后台</li><li>jobs 显示当前暂停的进程</li><li>bg %N 使第N个任务在后台运行（%前有空格）</li><li>fg %N 使第N个任务在前台运行</li><li>默认bg，fg不带%N时表示对最后一个进程操作！</li></ul><blockquote><p>一个比较常用的功能：<br>正在使用vi编辑一个文件时，需要执行shell命令查询一些需要的信息，可以使用ctrl-z挂起vi，等执行完shell命令后再使用fg恢复vi继续编辑你的文件（当然，也可以在vi中使用！command方式执行shell命令，但是没有该方法方便）。</p></blockquote><h4 id="ctrl-d"><a href="#ctrl-d" class="headerlink" title="ctrl+d:"></a>ctrl+d:</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;( Terminate input, or exit shell ) 一个特殊的二进制值，表示 EOF，作用相当于在终端中输入exit后回车；</p><h4 id="ctrl"><a href="#ctrl" class="headerlink" title="ctrl+/"></a>ctrl+/</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发送 SIGQUIT 信号给前台进程组中的所有进程，终止前台进程并生成 core 文件</p><h4 id="ctrl-s"><a href="#ctrl-s" class="headerlink" title="ctrl+s"></a>ctrl+s</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中断控制台输出</p><h4 id="ctrl-q"><a href="#ctrl-q" class="headerlink" title="ctrl+q"></a>ctrl+q</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;恢复控制台输出</p><h4 id="ctrl-l"><a href="#ctrl-l" class="headerlink" title="ctrl+l"></a>ctrl+l</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;清屏</p><h4 id="查看配置"><a href="#查看配置" class="headerlink" title="查看配置"></a>查看配置</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，控制字符都是可以通过stty命令更改的，可在终端中输入命令”stty -a”查看终端配置</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper知识点</title>
      <link href="/java/zookeeper/20190926/"/>
      <url>/java/zookeeper/20190926/</url>
      
        <content type="html"><![CDATA[<h4 id="zookeeper是什么"><a href="#zookeeper是什么" class="headerlink" title="zookeeper是什么"></a>zookeeper是什么</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zookeeper是基于Google Chubby论文的开源实现，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、配置管理 等等。 由于Hadoop生态系统中很多项目都依赖于zookeeper，如Pig，Hive等， 似乎很像一个动物园管理员，于是取名为Zookeeper。<a id="more"></a></p><h4 id="zookeeper提供了什么"><a href="#zookeeper提供了什么" class="headerlink" title="zookeeper提供了什么"></a>zookeeper提供了什么</h4><ul><li>文件系统</li><li>通知机制<h4 id="zookeeper文件系统"><a href="#zookeeper文件系统" class="headerlink" title="zookeeper文件系统"></a>zookeeper文件系统</h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zookeeper提供一个类似unix文件系统目录的多层级节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。<h4 id="zookeeper通知机制"><a href="#zookeeper通知机制" class="headerlink" title="zookeeper通知机制"></a>zookeeper通知机制</h4>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client端会对某个znode建立一个watcher事件，当该znode发生变化时，zk会主动通知watch这个znode的client，然后client根据znode的变化来做出业务上的改变等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;watcher的特点：</li><li>轻量级：一个callback函数。</li><li>异步性：不会block正常的读写请求。</li><li>主动推送：Watch被触发时，由Zookeeper服务端主动将更新推送给客户端。</li><li>一次性：数据变化时，Watch只会被触发一次。如果客户端想得到后续更新的通知，必须要在 Watch 被触发后重新注册一个 Watch。</li><li>仅通知：仅通知变更类型，不附带变更后的结果。</li><li>顺序性：如果多个更新触发了多个Watch，那 Watch 被触发的顺序与更新顺序一致。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用watch的注意事项：</li><li>由于watcher是一次性的，所以需要自己去实现永久watch</li><li>如果被watch的节点频繁更新，会出现“丢数据”的情况</li><li>watcher数量过多会导致性能下降<h4 id="zookeeper有哪些应用场景"><a href="#zookeeper有哪些应用场景" class="headerlink" title="zookeeper有哪些应用场景"></a>zookeeper有哪些应用场景</h4></li><li>名字服务</li><li>配置管理</li><li>集群管理</li><li>分布式锁</li><li>队列管理</li><li>消息订阅</li></ul><h4 id="zk的命名服务"><a href="#zk的命名服务" class="headerlink" title="zk的命名服务"></a>zk的命名服务</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</p><h4 id="zk的配置管理"><a href="#zk的配置管理" class="headerlink" title="zk的配置管理"></a>zk的配置管理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。</p><h4 id="zookeeper集群管理"><a href="#zookeeper集群管理" class="headerlink" title="zookeeper集群管理"></a>zookeeper集群管理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓集群管理无在乎两点：是否有机器退出和加入、选举master。 对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。 新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</p><h4 id="zookeeper分布式锁"><a href="#zookeeper分布式锁" class="headerlink" title="zookeeper分布式锁"></a>zookeeper分布式锁</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。 对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。 对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获取分布式锁的流程<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/Nlms57L.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode方法在locker下创建临时顺序节点， 然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。客户端获取到所有的子节点path之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/jSkhsaA.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码的实现主要是基于互斥锁，获取分布式锁的重点逻辑在于BaseDistributedLock，实现了基于Zookeeper实现分布式锁的细节。</p><h4 id="zk队列管理"><a href="#zk队列管理" class="headerlink" title="zk队列管理"></a>zk队列管理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两种类型的队列： 1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。 2、队列按照 FIFO 方式进行入队和出队操作。 第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。 第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL节点，创建成功时Watcher通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。</p><h4 id="zk数据复制"><a href="#zk数据复制" class="headerlink" title="zk数据复制"></a>zk数据复制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处： 1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作； 2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力； 3、提高性能：让客户端本地访问就近的节点，提高用户访问速度。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从客户端读写访问的透明度来看，数据复制集群系统分下面两种： 1、写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离； 2、写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</p><h4 id="zookeeper是如何保证事务的顺序一致性的"><a href="#zookeeper是如何保证事务的顺序一致性的" class="headerlink" title="zookeeper是如何保证事务的顺序一致性的"></a>zookeeper是如何保证事务的顺序一致性的</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zookeeper采用了递增的事务Id来标识，所有的proposal（提议）都在被提出的时候加上了zxid，zxid实际上是一个64位的数字，高32位是epoch（时期; 纪元; 世; 新时代）用来标识leader是否发生改变，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p><h4 id="zk集群下server工作状态"><a href="#zk集群下server工作状态" class="headerlink" title="zk集群下server工作状态"></a>zk集群下server工作状态</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个Server在工作过程中有四种状态：</p><ul><li>LOOKING：当前Server不知道leader是谁，正在搜寻</li><li>LEADING：当前server角色为leader</li><li>FOLLOWING：当前server角色为follower</li><li>OBSERVING：当前server角色为observer</li></ul><h4 id="zookeeper是如何选举Leader的"><a href="#zookeeper是如何选举Leader的" class="headerlink" title="zookeeper是如何选举Leader的"></a>zookeeper是如何选举Leader的</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当leader崩溃或者leader失去大多数的follower，这时zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、Zookeeper选主流程(basic paxos) （1）选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server； （2）选举线程首先向所有Server发起一次询问(包括自己)； （3）选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中； （4）收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server； （5）线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数，设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1. 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/qmfke99.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、Zookeeper选主流程(fast paxos) fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和 zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/L4TOaSl.png"></p><h4 id="zookeeper同步流程"><a href="#zookeeper同步流程" class="headerlink" title="zookeeper同步流程"></a>zookeeper同步流程</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选完Leader以后，zk就进入状态同步过程。</p><ul><li>Leader等待Follower和Observer连接；</li><li>Follower连接leader，将最大的zxid发送给leader；</li><li>Leader根据follower的zxid确定同步点；</li><li>完成同步后通知follower 已经成为uptodate状态；</li><li>Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/QulqU95.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据同步的4种方式：</p><ul><li>SNAP-全量同步<ul><li>条件：peerLastZxid&lt;minCommittedLog</li><li>说明：证明二者数据差异太大，follower数据过于陈旧，leader发送快照SNAP指令给follower全量同步数据，即leader将所有数据全量同步到follower</li></ul></li><li>DIFF-增量同步<ul><li>条件：minCommittedLog&lt;=peerLastZxid&lt;=maxCommittedLog</li><li>说明：证明二者数据差异不大，follower上有一些leader上已经提交的提议proposal未同步，此时需要增量提交这些提议即可</li></ul></li><li>TRUNC-仅回滚同步<ul><li>条件：peerLastZxid&gt;minCommittedLog</li><li>说明：证明follower上有些提议proposal并未在leader上提交，follower需要回滚到zxid为minCommittedLog对应的事务操作</li></ul></li><li>TRUNC+DIFF-回滚+增量同步<ul><li>条件：minCommittedLog&lt;=peerLastZxid&lt;=maxCommittedLog</li><li>说明：leader a已经将事务truncA提交到本地事务日志中，但没有成功发起proposal协议进行投票就宕机了；然后集群中剔除原leader a重新选举出新leader b，又提交了若干新的提议proposal，然后原leader a重新服务又加入到集群中说明：此时a,b都有一些对方未提交的事务，若b是leader, a需要先回滚truncA然后增量同步新leader b上的数据。</li></ul></li></ul><h4 id="分布式通知和协调"><a href="#分布式通知和协调" class="headerlink" title="分布式通知和协调"></a>分布式通知和协调</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后zk将这些变化发送给注册了这个节点的watcher的所有客户端。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。</p><h4 id="zk的session机制"><a href="#zk的session机制" class="headerlink" title="zk的session机制"></a>zk的session机制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zookeeper会为每个客户端分配一个session，类似于web服务器一样，用来标识客户端的身份。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session的作用：</p><ul><li>客户端标识</li><li>超时检查</li><li>请求的顺序执行</li><li>维护临时节点的生命周期</li><li>watcher通知</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session的状态：</p><ul><li>CONNECTING</li><li>CONNECTED</li><li>RECONNECTING</li><li>RECONNECTED</li><li>CLOSED</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;session的属性：</p><ul><li>SessionID：会话ID，全局唯一</li><li>TimeOut：会话超时时间</li><li>TickTime：下次会话超时时间点</li><li>isClosing：会话是否已经被关闭</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sessionID的构成：</p><ul><li>高8位代表创建Session时所在的zk节点的id</li><li>中间40位代表zk节点当前角色在创建的时候的时间戳</li><li>低16位是一个计数器，初始值为0</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot项目</title>
      <link href="/java/springboot/20190710/"/>
      <url>/java/springboot/20190710/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是springboot"><a href="#什么是springboot" class="headerlink" title="什么是springboot"></a>什么是springboot</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot是一个简化Spring开发的框架。用来监护spring应用开发，约定大于配置，去繁就简，just run 就能创建一个独立的，产品级的应用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在使用Spring Boot时只需要配置相应的Spring Boot就可以用所有的Spring组件，简单的说，spring boot就是整合了很多优秀的框架，不用我们自己手动的去写一堆xml配置然后进行配置。从本质上来说，Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置。<a id="more"></a></p><h4 id="单体应用与微服务"><a href="#单体应用与微服务" class="headerlink" title="单体应用与微服务"></a>单体应用与微服务</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单体应用是把所有的应用模块都写在一个应用中，导致项目越写越大，模块之间的耦合度也会越来越高。微服务是一种架构风格，用微服务可以将应用的模块单独部署，对不同的模块进行不同的管理操作，不同的模块生成小型服务，每个功能元素最后都可以成为一个可以独立替换、独立升级的功能单元，各个小型服务之间通过http进行通信。</p><h4 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务：使用Spring Boot可以生成独立的微服务功能单元。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。</p><h4 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h4><h5 id="用maven构建项目"><a href="#用maven构建项目" class="headerlink" title="用maven构建项目"></a>用maven构建项目</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实使用maven或gradle、ant构建都是可以的，使用maven比较熟。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maven使用基于XML的配置，Gradle采用了领域特定语言Groovy的配置。</p><h5 id="配置pom-xml"><a href="#配置pom-xml" class="headerlink" title="配置pom.xml"></a>配置pom.xml</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter 相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">    &lt;groupId&gt;com.sinosoft&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;blacklist-platform&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;packaging&gt;war&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;blacklist-platform&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;description&gt;Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.5.9.RELEASE&lt;&#x2F;version&gt;&lt;!-- 2.x版本，外置tomcat版本需要用8以上的 --&gt;</span><br><span class="line">    &lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;!-- Spring Boot的版本仲裁中心；以后我们导入依赖默认是不需要写版本。（没有在dependencies里面管理的依赖自然需要声明版本号） --&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- web --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">            &lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">            &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">            &lt;druid.version&gt;1.1.9&lt;&#x2F;druid.version&gt;</span><br><span class="line">            &lt;snakeyaml.version&gt;1.19&lt;&#x2F;snakeyaml.version&gt;</span><br><span class="line">            &lt;failOnMissingWebXml&gt;false&lt;&#x2F;failOnMissingWebXml&gt;</span><br><span class="line">        &lt;&#x2F;properties&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- tomcat --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;!-- 移除嵌入式tomcat插件 --&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;!--打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是打包阶段做了exclude操作--&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- 测试 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; </span><br><span class="line">            &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- jdbc --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- activemq --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-activemq&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- alibaba的一个高效连接池 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;druid.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- spring框架下的mybatis --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- mysql连接驱动 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- dubbo,不是官方dubbo-spring-boot-starter --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.gitee.reger&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-dubbo&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.1&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- fastjson --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.47&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!-- 工具包 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;&#x2F;dependencies&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;finalName&gt;blacklist-platform&lt;&#x2F;finalName&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-war-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;plugin&gt;</span><br><span class="line">        &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  # 读取哪个配置</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br></pre></td></tr></table></figure><h5 id="application-dev-yml"><a href="#application-dev-yml" class="headerlink" title="application-dev.yml"></a>application-dev.yml</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9999</span><br><span class="line">mybatis:</span><br><span class="line">  type-aliases-package: com.sinosoft.application.model</span><br><span class="line">  mapper-locations: classpath:mapper&#x2F;*.xml</span><br><span class="line">spring:</span><br><span class="line"> datasource:</span><br><span class="line">  type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">  url: jdbc:mysql:&#x2F;&#x2F;xxx.xx.xx.xx:3306&#x2F;xxxdb?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8</span><br><span class="line">  username: xxx</span><br><span class="line">  password: xxxx</span><br><span class="line">  driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">  initialSize: 5</span><br><span class="line">  minIdle: 5</span><br><span class="line">  maxActive: 20</span><br><span class="line">  maxWait: 60000</span><br><span class="line">  timeBetweenEvictionRunsMillis: 60000</span><br><span class="line"> # 配置一个连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">  minEvictableIdleTimeMillis: 30000</span><br><span class="line">  validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">  testWhileIdle: true</span><br><span class="line">  testOnBorrow: false</span><br><span class="line">  testOnReturn: false</span><br><span class="line"> # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">  poolPreparedStatements: true</span><br><span class="line">  maxPoolPreparedStatementPerConnectionSize: 20</span><br><span class="line"> # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#39;wall&#39;用于防火墙</span><br><span class="line">  filters: stat,wall,slf4j</span><br><span class="line"> # 通过connectProperties属性来打开mergeSql功能；慢SQL记录</span><br><span class="line">  connectionProperties: druid.stat.mergeSql&#x3D;true;druid.stat.slowSqlMillis&#x3D;5000</span><br><span class="line"> # 合并多个DruidDataSource的监控数据</span><br><span class="line">  useGlobalDataSourceStat: true</span><br><span class="line"> activemq:</span><br><span class="line">  broker-url: failover:(tcp:&#x2F;&#x2F;xxx.xxx.xxx.xxx:61616,tcp:&#x2F;&#x2F;xxx.xx.xx.xx:61616)</span><br><span class="line">  user: admin</span><br><span class="line">  password: admin</span><br><span class="line">  pool:</span><br><span class="line">   enabled: true</span><br><span class="line">   max-connections: 50</span><br><span class="line">   expiry-timeout: 10000</span><br><span class="line">   idle-timeout: 30000</span><br><span class="line"> dubbo:</span><br><span class="line">  application:</span><br><span class="line">   name: blacklist-platform</span><br><span class="line">  registry:</span><br><span class="line">   address: zookeeper:&#x2F;&#x2F;xxx.xxx.xxx.xxx:2181?xxx.xxx.xxx.xxx:2181,xxx.xxx.xxx.xxx:2181</span><br><span class="line">  scan: com.sinosoft.blacklist.service</span><br></pre></td></tr></table></figure><h5 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication &#x2F;&#x2F;代表springboot的启动类 用来标注主程序类 说明是一个springboot应用</span><br><span class="line">@ServletComponentScan(&quot;com.sinosoft.blacklist.servlet&quot;) &#x2F;&#x2F;扫描servlet</span><br><span class="line">@MapperScan(&quot;com.sinosoft.blacklist.dao&quot;) &#x2F;&#x2F;扫描mapper</span><br><span class="line">@ComponentScan(basePackages&#x3D; &#123;&quot;com.sinosoft.blacklist.service&quot;,&quot;com.sinosoft.blacklist.controller&quot;&#125;) &#x2F;&#x2F;扫描bean 包含@Component的注解，有@Component,@service,@controller,@Repository,@Configuration</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class ApplicationRun extends SpringBootServletInitializer&#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(ApplicationRun.class, args); &#x2F;&#x2F;springboot启动类</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;如使用外置tomcat，必须继承SpringBootServletInitializer，并重写configure方法，因为没有web.xml，tomcat无法进行加载，也无法知道入口，这个类就是暴露入口给tomcat。使用外置tomcat，yml中配置的port，ip会被忽略，使用tomcat下的service.xml中的配置。</span><br><span class="line">@Override</span><br><span class="line">protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">return builder.sources(ApplicationRun.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="service"><a href="#service" class="headerlink" title="service"></a>service</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BlackListServiceImpl implements BlackListService&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String demo() &#123;</span><br><span class="line">        return BlackListServiceImpl.class.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="contoller"><a href="#contoller" class="headerlink" title="contoller"></a>contoller</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实质是servlet，由DispatcherServlet分发请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BlackListController &#123;</span><br><span class="line">    private Logger logger &#x3D; LoggerFactory.getLogger(BlackListController.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BlackListService blackListService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String welcome() &#123;</span><br><span class="line">        resp.getWriter().append(blackListService.demo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在springboot中servlet，想要调用spring中的bean，需要实现public void init(ServletConfig config) throws ServletException;方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns &#x3D; &quot;&#x2F;BlackListServlet&quot;)</span><br><span class="line">public class BlackListServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID &#x3D; 7001557094255066523L;</span><br><span class="line">    private static Logger logger &#x3D; Logger.getLogger(BlackListServlet.class);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BlackListService blackListService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(ServletConfig config) throws ServletException &#123;</span><br><span class="line">        SpringBeanAutowiringSupport.processInjectionBasedOnServletContext(this, config.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        resp.getWriter().append(blackListService.demo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        doRun(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void doRun(HttpServletRequest req, HttpServletResponse resp) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            req.getSession().setMaxInactiveInterval(120);</span><br><span class="line">            BufferedReader br &#x3D; new BufferedReader(</span><br><span class="line">                    new InputStreamReader((ServletInputStream) req.getInputStream(), &quot;utf-8&quot;));</span><br><span class="line">            System.out.println(&quot;BlackListServlet&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;begin&quot;);</span><br><span class="line">            logger.info(&quot;BlackListServlet&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;begin&quot;);</span><br><span class="line">            resp.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">            resp.setContentType(&quot;application&#x2F;json; charset&#x3D;utf-8&quot;);</span><br><span class="line">            StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">            String temp;</span><br><span class="line">            while ((temp &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                sb.append(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">            System.out.println(sb.toString());</span><br><span class="line">            logger.info(sb.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;BlackListServlet&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&quot;);</span><br><span class="line">            logger.info(&quot;BlackListServlet&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;end&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring boot 配置加载顺序</title>
      <link href="/java/springboot/20190413/"/>
      <url>/java/springboot/20190413/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />### spring boot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置属性的方式很多，Spring boot使用了一种独有的 PropertySource 可以很方便的覆盖属性的值。<a id="more"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置属性加载的顺序如下：1. 开发者工具 `Devtools` 全局配置参数，例如eclipse配置的参数；1. 单元测试上的 `@TestPropertySource` 注解指定的参数；1. 单元测试上的 `@SpringBootTest` 注解指定的参数；1. 命令行指定的参数，如 `java -jar springboot.jar --name="Javaxxx"`；1. 命令行中的 `SPRING_APPLICATION_JSONJSON` 指定参数, 如 `java -Dspring.application.json='{"name":"Javaxxx"}' -jar springboot.jar`1. `ServletConfig` 初始化参数；1. `ServletContext` 初始化参数；1. JNDI参数（如 `java:comp/env/spring.application.json`）；1. Java系统参数（来源：`System.getProperties()`），java源码包级的配置；1. 操作系统环境变量参数；1. `RandomValuePropertySource` 随机数，仅匹配：`ramdom.*`；1. JAR包外面的配置文件参数（`application-{profile}.properties（YAML）`），类子目录下的；1. JAR包里面的配置文件参数（`application-{profile}.properties（YAML）`），类根目录下的；1. JAR包外面的配置文件参数（`application.properties（YAML）`），src子目录下的；1. JAR包里面的配置文件参数（`application.properties（YAML）`），src根目录下的；1. `@Configuration`配置文件上 `@PropertySource` 注解加载的参数，java代码的配置文件；1. 默认参数（通过 `SpringApplication.setDefaultProperties` 指定），启动时手动设置；]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring 启动</title>
      <link href="/java/spring/20200710/"/>
      <url>/java/spring/20200710/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /> <a id="more"></a>#### IOC容器的创建方式##### java创建IOC容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(xml路径);</span><br></pre></td></tr></table></figure>##### web容器创建IOC容器web服务器（tomcat/weblogic）启动会加载web.xml（启动ContextLoaderListener监听器）因为web服务器启动，实际上就是创建servlet容器，而ContextLoaderListener实现ServletContextListener接口，这个接口是监听servlet容器的创建和销毁。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;&#x2F;WEB-INF&#x2F;spring&#x2F;application_context.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br><span class="line"></span><br><span class="line">&lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;</span><br><span class="line">            org.springframework.web.context.ContextLoaderListener</span><br><span class="line">        &lt;&#x2F;listener-class&gt;</span><br><span class="line"> &lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure>ServletContextListener的contextInitialized是servlet容器创建是调用的方法。并传入ServletContextEvent，这个对象对ServletContext初始化。ServletContext是最上层的上下文。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void contextInitialized(ServletContextEvent event) &#123;</span><br><span class="line">        initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在ContextLoaderListener的父类中，有initWebApplicationContext，很明显，ApplicationContext是由ServletContext转化/封装来的。来看一下initWebApplicationContext里的内容是什么。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public WebApplicationContext initWebApplicationContext(ServletContext servletContext)&#123;</span><br><span class="line">    if (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) !&#x3D; null) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Cannot initialize context because there is already a root application context present - &quot; +&quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Log logger &#x3D; LogFactory.getLog(ContextLoader.class);</span><br><span class="line">    servletContext.log(&quot;Initializing Spring root WebApplicationContext&quot;);</span><br><span class="line">    if (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(&quot;Root WebApplicationContext: initialization started&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    long startTime &#x3D; System.currentTimeMillis();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; Store context in local instance variable, to guarantee that</span><br><span class="line">        &#x2F;&#x2F; it is available on ServletContext shutdown.</span><br><span class="line">        if (this.context &#x3D;&#x3D; null) &#123;</span><br><span class="line">            this.context &#x3D; createWebApplicationContext(servletContext);</span><br><span class="line">        &#125;</span><br><span class="line">        if (this.context instanceof ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            ConfigurableWebApplicationContext cwac &#x3D; (ConfigurableWebApplicationContext) this.context;</span><br><span class="line">            if (!cwac.isActive()) &#123;</span><br><span class="line">                &#x2F;&#x2F; The context has not yet been refreshed -&gt; provide services such as</span><br><span class="line">                &#x2F;&#x2F; setting the parent context, setting the application context id, etc</span><br><span class="line">                if (cwac.getParent() &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; The context instance was injected without an explicit parent -&gt;</span><br><span class="line">                    &#x2F;&#x2F; determine parent for root web application context, if any.</span><br><span class="line">                    ApplicationContext parent &#x3D; loadParentContext(servletContext);</span><br><span class="line">                    cwac.setParent(parent);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);</span><br><span class="line">        ClassLoader ccl &#x3D; Thread.currentThread().getContextClassLoader();</span><br><span class="line">        if (ccl &#x3D;&#x3D; ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">            currentContext &#x3D; this.context;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (ccl !&#x3D; null) &#123;</span><br><span class="line">            currentContextPerThread.put(ccl, this.context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Published root WebApplicationContext as ServletContext attribute with name [&quot; +WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            long elapsedTime &#x3D; System.currentTimeMillis() - startTime;</span><br><span class="line">            logger.info(&quot;Root WebApplicationContext: initialization completed in &quot; + elapsedTime + &quot; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this.context;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (RuntimeException ex) &#123;</span><br><span class="line">        logger.error(&quot;Context initialization failed&quot;, ex);</span><br><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line">        throw ex;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (Error err) &#123;</span><br><span class="line">        logger.error(&quot;Context initialization failed&quot;, err);</span><br><span class="line">        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class="line">        throw err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>代码里异常处理比较多，去掉异常处理，这个方法主要做了三件事：1. 创建WebApplicationContext。2. 加载对应的spring配置文件中的Bean。3. 将WebApplicationContext放入ServletContext（Java Web的全局变量）中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected WebApplicationContext createWebApplicationContext(ServletContext sc)&#123;</span><br><span class="line">    Class contextClass &#x3D; determineContextClass(sc);</span><br><span class="line">    if (!(ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass))) &#123;</span><br><span class="line">        throw new ApplicationContextException(&quot;Custom context class [&quot; + contextClass.getName() + &quot;] is not of type [&quot; + ConfigurableWebApplicationContext.class.getName() + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return ((ConfigurableWebApplicationContext)BeanUtils.instantiateClass(contextClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中createWebApplicationContext(servletContext)方法即是完成创建WebApplicationContext工作，也就是说这个方法创建了上下文对象，支持用户自定义上下文对象，但必须继承ConfigurableWebApplicationContext，而Spring MVC默认使用ConfigurableWebApplicationContext作为ApplicationContext（它仅仅是一个接口）的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc)&#123;</span><br><span class="line">    if (ObjectUtils.identityToString(wac).equals(wac.getId()))&#123;</span><br><span class="line">        String idParam &#x3D; sc.getInitParameter(&quot;contextId&quot;);</span><br><span class="line">        if (idParam !&#x3D; null) &#123;</span><br><span class="line">            wac.setId(idParam);</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((sc.getMajorVersion() &#x3D;&#x3D; 2) &amp;&amp; (sc.getMinorVersion() &lt; 5))&#123;</span><br><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getServletContextName()));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wac.setServletContext(sc);</span><br><span class="line">    String configLocationParam &#x3D; sc.getInitParameter(&quot;contextConfigLocation&quot;);</span><br><span class="line">    if (configLocationParam !&#x3D; null) &#123;</span><br><span class="line">        wac.setConfigLocation(configLocationParam);</span><br><span class="line">    &#125;</span><br><span class="line">    ConfigurableEnvironment env &#x3D; wac.getEnvironment();</span><br><span class="line">    if (env instanceof ConfigurableWebEnvironment) &#123;</span><br><span class="line">        ((ConfigurableWebEnvironment)env).initPropertySources(sc, null);</span><br><span class="line">    &#125;</span><br><span class="line">    customizeContext(sc, wac);</span><br><span class="line">    wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下走，有一个方法configureAndRefreshWebApplicationContext就是用来加载spring配置文件中的Bean实例的。这个方法于封装ApplicationContext数据并且初始化所有相关Bean对象。它会从web.xml中读取名为 contextConfigLocation的配置，这就是spring xml数据源设置，然后放到ApplicationContext中，最后调用传说中的refresh方法执行所有Java对象的创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line">    synchronized(this.startupShutdownMonitor) &#123;</span><br><span class="line">        this.prepareRefresh();</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory &#x3D; this.obtainFreshBeanFactory();</span><br><span class="line">        this.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            this.postProcessBeanFactory(beanFactory);</span><br><span class="line">            this.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            this.registerBeanPostProcessors(beanFactory);</span><br><span class="line">            this.initMessageSource();</span><br><span class="line">            this.initApplicationEventMulticaster();</span><br><span class="line">            this.onRefresh();</span><br><span class="line">            this.registerListeners();</span><br><span class="line">            this.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            this.finishRefresh();</span><br><span class="line">        &#125; catch (BeansException var5) &#123;</span><br><span class="line">            if (this.logger.isWarnEnabled()) &#123;</span><br><span class="line">                this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.destroyBeans();</span><br><span class="line">            this.cancelRefresh(var5);</span><br><span class="line">            throw var5;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring aop（未写完）</title>
      <link href="/java/spring/20200611/"/>
      <url>/java/spring/20200611/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring ioc（未写完）</title>
      <link href="/java/spring/20200610/"/>
      <url>/java/spring/20200610/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />#### IOCIoC 全称为 Inversion of Control，翻译为 “控制反转”，它还有一个别名为 DI（Dependency Injection）,即依赖注入。<a id="more"></a>> 所谓 IoC ，就是由 Spring IOC 容器来负责对象的生命周期和对象之间的关系在没有spring的时候，需要某个对象，一般都是已new的方式去创建，这个过程复杂而又繁琐，每个环节都要自己去把控，自己管理整个对象的生命周期，而且对象与对象之间都是耦合在一起的。其实可以思考一下，对象真的需要自己去创建和管理吗，只要用的时候可以拿到即可，无需过问他是怎么来的，还有怎么没的。就比如去餐馆吃饭，点餐之后，饭自然而然就送来了，不需要自己动手去做一顿饭，然后自己吃（难道吃都可以不自己吃了？）。IoC简单点说，就是别人为你服务，需要什么东西，就让别人（IOC Service Provider）送过来。何为控制反转，由原来的主动获取（创建）对象转为被动接受（注入）对象。还是比如去什么样的饭馆，吃什么样的饭，这是另外一说。* 可能你家境殷实，手里有个米其林三星，去了随便吃，都不用说什么。* 多数情况是，想吃什么，纠结半天，选一个有这个菜餐馆，进行愉快的就餐。* 还有就是，吃什么都没有想好，上街开车，随缘进入一家餐馆，随缘点菜，反正都没吃过，尝尝鲜。所以，IOC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、stter方法注入、接口注入。#### 构造器注入构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Man &#123;</span><br><span class="line">    private Restaurant restaurant;</span><br><span class="line">    Man(Restaurant restaurant)&#123;</span><br><span class="line">        this.restaurant &#x3D; restaurant;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>构造器注入方式比较直观，对象构造完毕后就可以直接使用，着就好比你家有个餐馆，自家生意。#### setter 方法注入对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Man &#123;</span><br><span class="line">    private Restaurant restaurant;</span><br><span class="line">    public void setRestaurant(Restaurant restaurant) &#123;</span><br><span class="line">        this.restaurant &#x3D; restaurant;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前）。就好比你想吃某个菜，去某个有这个菜的餐馆吃就行了。#### 接口方式注入接口方式注入需要被依赖的对象实现接口，并重写某些方法来实现功能。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Man extends HttpServlet&#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        super.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注入了HttpServletRequest和HttpServletResponse。#### ClassPathXmlApplicationContext ![](https://raw.githubusercontent.com/snmlm/resources/master/picture/13291365-fba6e7972333fed9.png)改图为ClassPathXmlApplicationContext 的继承架构图，可以看到最上层的BeanFactory，创建bean的核心。ResourceLoader，资源加载器。ApplicationContext贯穿了整个spring框架。#### Resource体系 Resource，对资源的抽象，它的每一个实现类都代表了一种资源的访问策略，如ClasspathResource 、 URLResource ，FileSystemResource 等。有了资源，就应该有资源加载，Spring 利用 ResourceLoader 来进行统一资源加载。独立篇幅#### BeanFactory 体系BeanFactory 是一个非常纯粹的 bean 容器，它是 IOC 必备的数据结构，其中 BeanDefinition 是她的基本结构，它内部维护着一个 BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。BeanFacoty 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory，DefaultListableBeanFactory 为最终默认实现，它实现了所有接口。独立篇幅#### Beandefinition 体系BeanDefinition 用来描述 Spring 中的 Bean 对象。独立篇幅#### BeandefinitionReader体系BeanDefinitionReader 的作用是读取 Spring 的配置文件的内容，并将其转换成 Ioc 容器内部的数据结构：BeanDefinition。独立篇幅#### ApplicationContext体系这个就是大名鼎鼎的 Spring 容器，它叫做应用上下文，与我们应用息息相关，它继承 BeanFactory，所以它是 BeanFactory 的扩展升级版，如果BeanFactory 是屌丝的话，那么 ApplicationContext 则是名副其实的高富帅。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有：* 继承 MessageSource，提供国际化的标准访问策略。* 继承 ApplicationEventPublisher ，提供强大的事件机制。* 扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源。* 对 Web 应用的支持。<p>独立篇幅</p><h4 id="IoC初始化"><a href="#IoC初始化" class="headerlink" title="IoC初始化"></a>IoC初始化</h4><p>Ioc的初始化，就好了解spring的启动顺序。<br>独立篇幅</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring加载对象问题（坑）</title>
      <link href="/java/spring/20190421/"/>
      <url>/java/spring/20190421/</url>
      
        <content type="html"><![CDATA[<h3 id="父类子类属性传递问题，外带懒加载问题"><a href="#父类子类属性传递问题，外带懒加载问题" class="headerlink" title="父类子类属性传递问题，外带懒加载问题"></a>父类子类属性传递问题，外带懒加载问题</h3><h4 id="父类子类属性-gt-权限问题"><a href="#父类子类属性-gt-权限问题" class="headerlink" title="父类子类属性-&gt;权限问题"></a>父类子类属性-&gt;权限问题</h4><table><thead><tr><th>作用域</th><th>当前类</th><th>同一package</th><th>子孙类</th><th>其他package</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>friendly/default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><a id="more"></a><h4 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子类和父类相同的属性对象时，并且用getter和setter方法进行spring管理。子类单独调用子类方法，对象可以使用，父类单独调用父类方法，属性对象可以使用，唯独子类调用父类的方法是，父类的属性对象无法使用，空指针。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子类衍生的父类和单独的父类不是一个对象，那么是不是可以理解成，子类的属性父类是拿不到的，在向上转型时<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其原因未探究出来。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方法：</p><ol><li>删除子类的属性对象，删除子类属性对象的getter和setter，对父类的属性对象的访问权限外放，子类调用父类方法，对属性对象可以拿到。</li><li>父类对象纯抽象化，不做业务处理，并在配置的时候，bean标签加上abstract=”true”，不进行实例化。</li><li>子类不调用父类方法。</li></ol><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;懒加载，顾名思义，只有用的时候才会加载。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在spring中，配置懒加载优先级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans &#x2F;&gt;                &lt;bean &#x2F;&gt;            immediately  </span><br><span class="line">&lt;beans &#x2F;&gt;                &lt;bean lazy-init&#x3D;&quot;true&quot; &#x2F;&gt;   lazy      </span><br><span class="line">&lt;beans &#x2F;&gt;                &lt;bean lazy-init&#x3D;&quot;false&quot;&#x2F;&gt;   immediately           </span><br><span class="line">&lt;beans default-lazy-init&#x3D;&quot;true&quot;&#x2F;&gt;  &lt;bean &#x2F;&gt;          lazy  </span><br><span class="line">&lt;beans default-lazy-init&#x3D;&quot;true&quot;&#x2F;&gt;  &lt;bean lazy-init&#x3D;&quot;true&quot; &#x2F;&gt;     lazy  </span><br><span class="line">&lt;beans default-lazy-init&#x3D;&quot;true&quot;&#x2F;&gt;  &lt;bean lazy-init&#x3D;&quot;false&quot; &#x2F;&gt;    immediately  </span><br><span class="line">&lt;beans default-lazy-init&#x3D;&quot;false&quot;&#x2F;&gt;  &lt;bean &#x2F;&gt;             immediately  </span><br><span class="line">&lt;beans default-lazy-init&#x3D;&quot;false&quot;&#x2F;&gt;  &lt;bean lazy-init&#x3D;&quot;true&quot; &#x2F;&gt;    lazy  </span><br><span class="line">&lt;beans default-lazy-init&#x3D;&quot;false&quot;&#x2F;&gt;  &lt;bean lazy-init&#x3D;&quot;false&quot; &#x2F;&gt;   immediately  </span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>spring早起是默认懒加载的，在版本迭代和维护之后，默认配置已变成容器创建时加载，所以不配置懒加载的话，项目启动不是很快。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring容器外调用容器内的对象</title>
      <link href="/java/spring/20190411/"/>
      <url>/java/spring/20190411/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单的方法，就是把调用对象放到spring容器内。直接调用其他对象即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要么就是实现ApplicationContextAware接口，并把类加载到spring容器中，获取到ApplicationContext，用ApplicationContext.getbean方法拿到spring容器里的对象，进行调用。</p><a id="more"></a><h3 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如上面写的，dubbo中有对应的类进行处理，ServiceBean，但是ServiceBean这个类只有在对外发布服务的时候，才会被加载到spring中，实实在在被坑了一波。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo 配置加载顺序</title>
      <link href="/java/dubbo/20190414/"/>
      <url>/java/dubbo/20190414/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />### dubbo 覆盖策略![](https://raw.githubusercontent.com/snmlm/resources/master/picture/rELywxc.jpg)<a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM 启动 -D 参数优先，这样可以使用户在部署和启动时进行参数重写，比如在启动时需改变协议的端口。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XML 次之，如果在 XML 中有配置，则 dubbo.properties 中的相应配置项无效。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Properties 最后，相当于缺省值，只有 XML 没有配置时，dubbo.properties 的相应配置项才会生效，通常用于共享公共配置，比如应用名。</p><blockquote><p>如果 classpath 根目录下存在多个 dubbo.properties，比如多个 jar 包中有 dubbo.properties，Dubbo 会任意加载，并打印 Error 日志，后续可能改为抛异常。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo的坑（持续更新）</title>
      <link href="/java/dubbo/20190412/"/>
      <url>/java/dubbo/20190412/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />### dubbo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载自定义配置文件，本地测试的路径和打包之后项目路径不一致问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;本地测试需改成&#x2F;conf</span><br><span class="line">&#x2F;&#x2F;打包发环境时，改成&#x2F;</span><br><span class="line">this.getClass().getResource(&quot;&#x2F;&quot;).getPath()</span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本类的路径下去找资源文件的路径。并且不会去下级文件夹寻找文件。<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String、StringBuffer、StringBulider</title>
      <link href="/java/basics/20200817/"/>
      <url>/java/basics/20200817/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><a id="more"></a>### String是常量字符串（final类，值不变，改变的是指向的内存地址）缺点：频繁拼接字符串非常耗内存### StringBulider，StringBuffer值是可以改变的，长度可变，底层已数组形式实现。同时实现Serializable，证明可序列化。同时实现CharSequence，证明是有序字符集合。可以替代stringStringBuffer 与 StringBuilder 中的方法和功能完全是等价的，只是StringBuffer中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。由于完全等价，所以都继承AbstractStringBuilder。无参初始化，长度为16，有参初始化是参数长度+16。扩容时是对象当前长度*2+2每次append的时候，最下层执行的System.arraycopy这个方法进行数组的添加。StringBuffer 始于 JDK 1.0StringBuilder 始于 JDK 1.5从 JDK 1.5 开始，带有字符串变量的连接操作（+），JVM 内部采用的是 StringBuilder 来实现的，而之前这个操作是采用 StringBuffer 实现的。如果是直接的字符串的拼接，会直接指向拼接后的字符串常量。]]></content>
      
      
      
        <tags>
            
            <tag> 汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>return和finally执行问题</title>
      <link href="/java/basics/20200702/"/>
      <url>/java/basics/20200702/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><a id="more"></a>#### 执行顺序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F;代码A</span><br><span class="line">    retrun；</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">    &#x2F;&#x2F;代码B</span><br><span class="line">    retrun；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>* finally中的代码是在retrun之后执行。* retrun返回的时候，对象是返回的地址（finally中是可以改变对象的属性，并能影响返回值），基本类型是具体的数值（无论finally中如何操作，都不会影响返回值）。* finally中有retrun会覆盖其他函数中的retrun。]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重写与重载</title>
      <link href="/java/basics/20200701/"/>
      <url>/java/basics/20200701/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />#### 重写满足条件* 重写方法不能缩小访问权限；* 参数列表必须与被重写方法相同（包括显示形式）；* 返回类型必须与被重写方法的相同或是其子类；* 重写方法不能抛出新的异常，或者超过了父类范围的异常，但是可以抛出更少、更有限的异常，或者不抛出异常。<a id="more"></a><h4 id="重载满足条件"><a href="#重载满足条件" class="headerlink" title="重载满足条件"></a>重载满足条件</h4><ul><li>在同一个类中；</li><li>方法的名称相同；</li><li>参数列表不同。（参数类型，个数，顺序）</li><li>与访问修饰符和返回值类型无关</li><li>与异常无关</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全面理解servlet</title>
      <link href="/java/basics/20200609/"/>
      <url>/java/basics/20200609/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />#### Tomcat工作机制访问的流程（省略连接）* 客户端发出http请求。* http请求到达tomcat。* tomcat把servlet从磁盘中加载到servlet容器中并初始化。* 创建好servlet之后，tomcat把http请求解析成request对象，并转发给对应的servlet进行处理。* servlet处理完成之后，返回response对象，返回给tomcat。* tomcat接收到response对象解析成http返回请求。* 再由tomcat发送给客户端。<a id="more"></a><h4 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h4><p>Servlet（Server Applet），全称Java Servlet，未有中文译文。是用Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。<br>Servlet运行于支持Java的应用服务器中。从实现上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p><h4 id="Servlet-API-概览"><a href="#Servlet-API-概览" class="headerlink" title="Servlet API 概览"></a>Servlet API 概览</h4><p>Servlet API 包含以下4个Java包：</p><ul><li>javax.servlet   其中包含定义servlet和servlet容器之间契约的类和接口。</li><li>javax.servlet.http   其中包含定义HTTP Servlet 和Servlet容器之间的关系。</li><li>javax.servlet.annotation   其中包含标注servlet，Filter,Listener的标注。它还为被标注元件定义元数据。</li><li>javax.servlet.descriptor，其中包含提供程序化登录Web应用程序的配置信息的类型。</li></ul><h4 id="Servlet的使用方式"><a href="#Servlet的使用方式" class="headerlink" title="Servlet的使用方式"></a>Servlet的使用方式</h4><p>Servlet技术的核心是Servlet，它是所有Servlet类必须直接或者间接实现的一个接口。在编写实现Servlet的Servlet类时，直接实现它。在扩展实现这个这个接口的类时，间接实现它。</p><h4 id="Servlet-的工作原理"><a href="#Servlet-的工作原理" class="headerlink" title="Servlet 的工作原理"></a>Servlet 的工作原理</h4><p>Servlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。但是要注意的是，在一个应用程序中，每种Servlet类型只能有一个实例。</p><blockquote><p>servlet的单例和多例问题</p><ol><li>看是否实现了SingleThreadModel接口，实现之后可以实现多例，这个接口在servlet4.0时废弃了，官方不提倡使用。</li><li>还要看servlet容器，一般容器都是单一实现。</li><li>在xml配置的时候，servlet web是不允许配置同名，可以同名的话，可以配置多个。</li></ol></blockquote><p>用户请求致使Servlet容器调用Servlet的Service（）方法，并传入一个ServletRequest对象和一个ServletResponse对象。ServletRequest对象和ServletResponse对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用这两个对象。<br>ServletRequest中封装了当前的Http请求，因此，开发人员不必解析和操作原始的Http数据。ServletResponse表示当前用户的Http响应，程序员只需直接操作ServletResponse对象就能把响应轻松的发回给用户。<br>对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。每个应用程序只有一个ServletContext。每个Servlet对象也都有一个封装Servlet配置的ServletConfig对象。</p><h4 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Servlet &#123;</span><br><span class="line">    public abstract void init(ServletConfig var1) throws ServletException;&#x2F;&#x2F;初始化</span><br><span class="line">    public abstract ServletConfig getServletConfig();&#x2F;&#x2F;获取ServletConfig</span><br><span class="line">    public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;&#x2F;&#x2F;运行是被调用的</span><br><span class="line">    public abstract String getServletInfo();&#x2F;&#x2F;获取信息描述等</span><br><span class="line">    public abstract void destroy();&#x2F;&#x2F;销毁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Servlet-的生命周期"><a href="#Servlet-的生命周期" class="headerlink" title="Servlet 的生命周期"></a>Servlet 的生命周期</h4><p>其中，init( ),service( ),destroy( )是Servlet生命周期的方法。代表了Servlet从“出生”到“工作”再到“死亡 ”的过程。Servlet容器（例如TomCat）会根据下面的规则来调用这三个方法：<br>1.init( ),当Servlet第一次被请求时，Servlet容器就会开始调用这个方法来初始化一个Servlet对象出来，但是这个方法在后续请求中不会在被Servlet容器调用，就像人只能“出生”一次一样。我们可以利用init（ ）方法来执行相应的初始化工作。调用这个方法时，Servlet容器会传入一个ServletConfig对象进来从而对Servlet对象进行初始化。<br>2.service( )方法，每当请求Servlet时，Servlet容器就会调用这个方法。就像人一样，需要不停的接受老板的指令并且“工作”。第一次请求时，Servlet容器会先调用init( )方法初始化一个Servlet对象出来，然后会调用它的service( )方法进行工作，但在后续的请求中，Servlet容器只会调用service方法了。<br>3.destory,当要销毁Servlet时，Servlet容器就会调用这个方法，就如人一样，到时期了就得死亡。在卸载应用程序或者关闭Servlet容器时，就会发生这种情况，一般在这个方法中会写一些清除代码。</p><blockquote><p>getServletInfo（），这个方法会返回Servlet的一段描述，可以返回一段字符串。<br>getServletConfig（），这个方法会返回由Servlet容器传给init（）方法的ServletConfig对象。</p></blockquote><h4 id="ServletRequset接口"><a href="#ServletRequset接口" class="headerlink" title="ServletRequset接口"></a>ServletRequset接口</h4><p>Servlet容器对于接受到的每一个Http请求，都会创建一个ServletRequest对象，并把这个对象传递给Servlet的Sevice( )方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface ServletRequest &#123;</span><br><span class="line">    public int getContentLength();&#x2F;&#x2F;返回请求主体的字节数</span><br><span class="line">    public String getContentType();&#x2F;&#x2F;返回主体的MIME类型</span><br><span class="line">    public String getParameter(String var1);&#x2F;&#x2F;返回请求参数的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServletResponse接口"><a href="#ServletResponse接口" class="headerlink" title="ServletResponse接口"></a>ServletResponse接口</h4><p>javax.servlet.ServletResponse接口表示一个Servlet响应，在调用Servlet的Service( )方法前，Servlet容器会先创建一个ServletResponse对象，并把它作为第二个参数传给Service( )方法。ServletResponse隐藏了向浏览器发送响应的复杂过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface ServletResponse &#123;</span><br><span class="line">    public String getCharacterEncoding();&#x2F;&#x2F;获取字符集</span><br><span class="line">    public String getContentType();&#x2F;&#x2F;获取解析类型</span><br><span class="line">    public ServletOutputStream getOutputStream() throws IOException;&#x2F;&#x2F;获取输出字节流</span><br><span class="line">    public PrintWriter getWriter() throws IOException;&#x2F;&#x2F;获取输出字符流，默认字符集为ISO-8859-1，中文会乱码</span><br><span class="line">    public void setCharacterEncoding(String var1);&#x2F;&#x2F;设置字符集，优先级最高</span><br><span class="line">    public void setContentLength(int var1);&#x2F;&#x2F;设置解析长度</span><br><span class="line">    public void setContentType(String var1);&#x2F;&#x2F;设置解析类型，可以设置字符集，优先级比setCharacterEncoding低</span><br><span class="line">    public void setBufferSize(int var1);&#x2F;&#x2F;设置缓存大小</span><br><span class="line">    public int getBufferSize();&#x2F;&#x2F;获取缓存大小</span><br><span class="line">    public void flushBuffer() throws IOException;&#x2F;&#x2F;刷新缓存</span><br><span class="line">    public void resetBuffer();&#x2F;&#x2F;清空缓存，但是不清除头和状态码</span><br><span class="line">    public boolean isCommitted();&#x2F;&#x2F;是否提交</span><br><span class="line">    public void reset();&#x2F;&#x2F;清空缓存，全部清空</span><br><span class="line">    public void setLocale(Locale var1);&#x2F;&#x2F;设置字符集，优先级比setContentType低</span><br><span class="line">    public Locale getLocale();&#x2F;&#x2F;获取字符集</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在向客户端发送响应时，大多数都是使用该对象向客户端发送HTML。还有一个方法也可以用来向浏览器发送数据，它就是getOutputStream，从名字就可以看出这是一个二进制流对象，因此这个方法是用来发送二进制数据的。</p></blockquote><h4 id="ServletConfig接口"><a href="#ServletConfig接口" class="headerlink" title="ServletConfig接口"></a>ServletConfig接口</h4><p>当Servlet容器初始化Servlet时，Servlet容器会给Servlet的init()方式传入一个ServletConfig对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ServletConfig</span><br><span class="line">&#123;</span><br><span class="line">    public String getServletName();&#x2F;&#x2F;获取servlet的名字</span><br><span class="line">    public Enumeration getInitParameterNames();&#x2F;&#x2F;获取所有属性的名称</span><br><span class="line">    public ServletContext getServletContext();&#x2F;&#x2F;获取servlet上下文</span><br><span class="line">    public String getInitParameter(String paramString);&#x2F;&#x2F;根据名称获取属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h4><p>ServletContext对象表示Servlet应用程序。每个Web应用程序都只有一个ServletContext对象。在将一个应用程序同时部署到多个容器的分布式环境中，每台Java虚拟机上的Web应用都会有一个ServletContext对象。<br>ServletContext中存放所有有关共享数据和资源。所以只会有一个ServletContext。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public interface ServletContext</span><br><span class="line">&#123;</span><br><span class="line">    public int getMajorVersion();&#x2F;&#x2F;获取服务器支持的 Servlet API 最大版本号</span><br><span class="line">    public int getMinorVersion();&#x2F;&#x2F;获取服务器支持的 Servlet API 最小版本号</span><br><span class="line">    public String getServerInfo();&#x2F;&#x2F;获取server的信息</span><br><span class="line">    public String getServletContextName();&#x2F;&#x2F;获取ServletContext的名字</span><br><span class="line">    public void log(String paramString);&#x2F;&#x2F;输出日志</span><br><span class="line">    public void removeAttribute(String paramString);&#x2F;&#x2F;删除属性</span><br><span class="line">    public Enumeration getAttributeNames();&#x2F;&#x2F;获取属性名</span><br><span class="line">    public Enumeration getInitParameterNames();&#x2F;&#x2F;获取初始化参数</span><br><span class="line">    public Enumeration getServletNames();&#x2F;&#x2F;获取所有servlet名</span><br><span class="line">    public Enumeration getServlets();&#x2F;&#x2F;获取所有servlet对象</span><br><span class="line">    public InputStream getResourceAsStream(String paramString);&#x2F;&#x2F;获取资源转换成数据流</span><br><span class="line">    public Object getAttribute(String paramString);&#x2F;&#x2F;获取属性</span><br><span class="line">    public void setAttribute(String paramString, Object paramObject);&#x2F;&#x2F;设置属性</span><br><span class="line">    public void log(Exception paramException, String paramString);&#x2F;&#x2F;输出日志，带异常</span><br><span class="line">    public String getInitParameter(String paramString);&#x2F;&#x2F;获取特定初始化参数</span><br><span class="line">    public String getMimeType(String paramString);&#x2F;&#x2F;获取媒体类型</span><br><span class="line">    public String getRealPath(String paramString);&#x2F;&#x2F;获取真实路径</span><br><span class="line">    public void log(String paramString, Throwable paramThrowable);&#x2F;&#x2F;输出日志，带异常</span><br><span class="line">    public URL getResource(String paramString)throws MalformedURLException;&#x2F;&#x2F;获取资源，返回url</span><br><span class="line">    public Set getResourcePaths(String paramString);&#x2F;&#x2F;获取资源，返回set</span><br><span class="line">    public RequestDispatcher getNamedDispatcher(String paramString);&#x2F;&#x2F;获取RequestDispatcher，用于servlet通</span><br><span class="line">    public RequestDispatcher getRequestDispatcher(String paramString);&#x2F;&#x2F;获取RequestDispatcher，用于servlet通</span><br><span class="line">    public Servlet getServlet(String paramString)throws ServletException;&#x2F;&#x2F;获取servlet</span><br><span class="line">    public ServletContext getContext(String paramString);&#x2F;&#x2F;获取上下文</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GenericServlet抽象类"><a href="#GenericServlet抽象类" class="headerlink" title="GenericServlet抽象类"></a>GenericServlet抽象类</h4><p>前面我们编写Servlet一直是通过实现Servlet接口来编写的，但是，使用这种方法，则必须要实现Servlet接口中定义的所有的方法，即使有一些方法中没有任何东西也要去实现，并且还需要自己手动的维护ServletConfig这个对象的引用。因此，这样去实现Servlet是比较麻烦的。<br>所以出现了GenericServlet抽象类，只需关注业务，不需要关心servlet的初始问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">package javax.servlet;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.Enumeration;</span><br><span class="line"></span><br><span class="line">public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123;</span><br><span class="line">    private transient ServletConfig config;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;构造</span><br><span class="line">    public GenericServlet() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;销毁</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    public void init() throws ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取Servlet信息</span><br><span class="line">    public String getServletInfo() &#123;</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取Servlet名称</span><br><span class="line">    public String getServletName() &#123;</span><br><span class="line">        return this.config.getServletName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;输出日志</span><br><span class="line">    public void log(String msg) &#123;</span><br><span class="line">        this.getServletContext().log(this.getServletName() + &quot;: &quot; + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取初始化参数</span><br><span class="line">    public Enumeration getInitParameterNames() &#123;</span><br><span class="line">        return this.getServletConfig().getInitParameterNames();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取Servlet配置</span><br><span class="line">    public ServletConfig getServletConfig() &#123;</span><br><span class="line">        return this.config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;有参初始化</span><br><span class="line">    public void init(ServletConfig config) throws ServletException &#123;</span><br><span class="line">        this.config &#x3D; config;</span><br><span class="line">        this.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取上下文</span><br><span class="line">    public ServletContext getServletContext() &#123;</span><br><span class="line">        return this.getServletConfig().getServletContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;获取特定初始化参数</span><br><span class="line">    public String getInitParameter(String name) &#123;</span><br><span class="line">        return this.getServletConfig().getInitParameter(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;输入日志，带异常</span><br><span class="line">    public void log(String message, Throwable t) &#123;</span><br><span class="line">        this.getServletContext().log(this.getServletName() + &quot;: &quot; + message, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;执行服务</span><br><span class="line">    public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的无参初始化，只需要关注ServletConfig之外的初始化操作即可，不需要自己维护ServletConfig;<br>然而，虽然GenricServlet是对Servlet一个很好的加强，但是也不经常用，因为他不像HttpServlet那么高级。HttpServlet才是主角，在现实的应用程序中被广泛使用。那么我们接下来就看看传说中的HttpServlet到底厉害在哪里吧。</p><h4 id="HttpServlet抽象类"><a href="#HttpServlet抽象类" class="headerlink" title="HttpServlet抽象类"></a>HttpServlet抽象类</h4><p>HttpServlet抽象类是继承于GenericServlet抽象类而来的。使用HttpServlet抽象类时，还需要借助分别代表Servlet请求和Servlet响应的HttpServletRequest和HttpServletResponse对象。</p><blockquote><p>HttpServletRequest接口扩展于javax.servlet.ServletRequest接口，HttpServletResponse接口扩展于javax.servlet.servletResponse接口。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface HttpServletRequest extends ServletRequest</span><br><span class="line"></span><br><span class="line">public interface HttpServletResponse extends ServletResponse</span><br></pre></td></tr></table></figure><p>HttpServlet抽象类覆盖了GenericServlet抽象类中的Service( )方法，并且添加了一个自己独有的Service(HttpServletRequest request，HttpServletResponse方法。<br>GenericServlet抽象类中的service方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;</span><br></pre></td></tr></table></figure><p>HttpServlet抽象类中重写父类的service方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123;</span><br><span class="line">    HttpServletRequest request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    try &#123;</span><br><span class="line">        request &#x3D; (HttpServletRequest)req;</span><br><span class="line">        response &#x3D; (HttpServletResponse)res;</span><br><span class="line">    &#125; catch (ClassCastException var6) &#123;</span><br><span class="line">        throw new ServletException(&quot;non-HTTP request or response&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpServlet抽象类中重载的service方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">    String method &#x3D; req.getMethod();</span><br><span class="line">    long lastModified;</span><br><span class="line">    if (method.equals(&quot;GET&quot;)) &#123;</span><br><span class="line">        lastModified &#x3D; this.getLastModified(req);</span><br><span class="line">        if (lastModified &#x3D;&#x3D; -1L) &#123;</span><br><span class="line">        this.doGet(req, resp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        long ifModifiedSince &#x3D; req.getDateHeader(&quot;If-Modified-Since&quot;);</span><br><span class="line">        if (ifModifiedSince &lt; lastModified &#x2F; 1000L * 1000L) &#123;</span><br><span class="line">            this.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            this.doGet(req, resp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            resp.setStatus(304);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (method.equals(&quot;HEAD&quot;)) &#123;</span><br><span class="line">        lastModified &#x3D; this.getLastModified(req);</span><br><span class="line">        this.maybeSetLastModified(resp, lastModified);</span><br><span class="line">        this.doHead(req, resp);</span><br><span class="line">    &#125; else if (method.equals(&quot;POST&quot;)) &#123;</span><br><span class="line">        this.doPost(req, resp);</span><br><span class="line">    &#125; else if (method.equals(&quot;PUT&quot;)) &#123;</span><br><span class="line">        this.doPut(req, resp);</span><br><span class="line">    &#125; else if (method.equals(&quot;DELETE&quot;)) &#123;</span><br><span class="line">        this.doDelete(req, resp);</span><br><span class="line">    &#125; else if (method.equals(&quot;OPTIONS&quot;)) &#123;</span><br><span class="line">        this.doOptions(req, resp);</span><br><span class="line">    &#125; else if (method.equals(&quot;TRACE&quot;)) &#123;</span><br><span class="line">        this.doTrace(req, resp);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);</span><br><span class="line">        Object[] errArgs &#x3D; new Object[]&#123;method&#125;;</span><br><span class="line">        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(501, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpServlet在使用的时候，只需要重写doPost或doGet两个常用的方法即可。不需要太繁琐的实现。</p><h4 id="HttpServletRequest接口"><a href="#HttpServletRequest接口" class="headerlink" title="HttpServletRequest接口"></a>HttpServletRequest接口</h4><p>HttpServletRequest表示Http环境中的Servlet请求。它扩展于javax.servlet.ServletRequest接口，并添加了几个方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public interface HttpServletRequest extends ServletRequest &#123;</span><br><span class="line">    String BASIC_AUTH &#x3D; &quot;BASIC&quot;;</span><br><span class="line">    String FORM_AUTH &#x3D; &quot;FORM&quot;;</span><br><span class="line">    String CLIENT_CERT_AUTH &#x3D; &quot;CLIENT_CERT&quot;;</span><br><span class="line">    String DIGEST_AUTH &#x3D; &quot;DIGEST&quot;;</span><br><span class="line">    boolean isRequestedSessionIdFromCookie();</span><br><span class="line">    boolean isRequestedSessionIdFromURL();</span><br><span class="line">    &#x2F;** @deprecated *&#x2F;</span><br><span class="line">    boolean isRequestedSessionIdFromUrl();</span><br><span class="line">    boolean isRequestedSessionIdValid();</span><br><span class="line">    String getAuthType();</span><br><span class="line">    String getContextPath();&#x2F;&#x2F;返回请求上下文的请求URI部分</span><br><span class="line">    String getMethod();&#x2F;&#x2F;返回生成这个请求HTTP的方法名称</span><br><span class="line">    String getPathInfo();</span><br><span class="line">    String getPathTranslated();</span><br><span class="line">    String getQueryString();&#x2F;&#x2F;返回请求URL中的查询字符串</span><br><span class="line">    String getRemoteUser();</span><br><span class="line">    String getRequestURI();</span><br><span class="line">    String getRequestedSessionId();</span><br><span class="line">    String getServletPath();</span><br><span class="line">    int getIntHeader(String var1);</span><br><span class="line">    long getDateHeader(String var1);</span><br><span class="line">    boolean isUserInRole(String var1);</span><br><span class="line">    StringBuffer getRequestURL();</span><br><span class="line">    Principal getUserPrincipal();</span><br><span class="line">    Enumeration getHeaderNames();</span><br><span class="line">    Cookie[] getCookies();&#x2F;&#x2F;返回一个cookie对象数组</span><br><span class="line">    HttpSession getSession();&#x2F;&#x2F;返回与这个请求相关的会话对象</span><br><span class="line">    HttpSession getSession(boolean var1);</span><br><span class="line">    String getHeader(String var1);&#x2F;&#x2F;返回指定HTTP标题的值</span><br><span class="line">    Enumeration getHeaders(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HttpServletResponse接口"><a href="#HttpServletResponse接口" class="headerlink" title="HttpServletResponse接口"></a>HttpServletResponse接口</h4><p>在Service API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。<br>由于HTTP请求消息分为状态行，响应消息头，响应消息体三部分，因此，在HttpServletResponse接口中定义了向客户端发送响应状态码，响应消息头，响应消息体的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public interface HttpServletResponse extends ServletResponse &#123;</span><br><span class="line">    int SC_CONTINUE &#x3D; 100;</span><br><span class="line">    int SC_SWITCHING_PROTOCOLS &#x3D; 101;</span><br><span class="line">    int SC_OK &#x3D; 200;</span><br><span class="line">    int SC_CREATED &#x3D; 201;</span><br><span class="line">    int SC_ACCEPTED &#x3D; 202;</span><br><span class="line">    int SC_NON_AUTHORITATIVE_INFORMATION &#x3D; 203;</span><br><span class="line">    int SC_NO_CONTENT &#x3D; 204;</span><br><span class="line">    int SC_RESET_CONTENT &#x3D; 205;</span><br><span class="line">    int SC_PARTIAL_CONTENT &#x3D; 206;</span><br><span class="line">    int SC_MULTIPLE_CHOICES &#x3D; 300;</span><br><span class="line">    int SC_MOVED_PERMANENTLY &#x3D; 301;</span><br><span class="line">    int SC_MOVED_TEMPORARILY &#x3D; 302;</span><br><span class="line">    int SC_FOUND &#x3D; 302;</span><br><span class="line">    int SC_SEE_OTHER &#x3D; 303;</span><br><span class="line">    int SC_NOT_MODIFIED &#x3D; 304;</span><br><span class="line">    int SC_USE_PROXY &#x3D; 305;</span><br><span class="line">    int SC_TEMPORARY_REDIRECT &#x3D; 307;</span><br><span class="line">    int SC_BAD_REQUEST &#x3D; 400;</span><br><span class="line">    int SC_UNAUTHORIZED &#x3D; 401;</span><br><span class="line">    int SC_PAYMENT_REQUIRED &#x3D; 402;</span><br><span class="line">    int SC_FORBIDDEN &#x3D; 403;</span><br><span class="line">    int SC_NOT_FOUND &#x3D; 404;</span><br><span class="line">    int SC_METHOD_NOT_ALLOWED &#x3D; 405;</span><br><span class="line">    int SC_NOT_ACCEPTABLE &#x3D; 406;</span><br><span class="line">    int SC_PROXY_AUTHENTICATION_REQUIRED &#x3D; 407;</span><br><span class="line">    int SC_REQUEST_TIMEOUT &#x3D; 408;</span><br><span class="line">    int SC_CONFLICT &#x3D; 409;</span><br><span class="line">    int SC_GONE &#x3D; 410;</span><br><span class="line">    int SC_LENGTH_REQUIRED &#x3D; 411;</span><br><span class="line">    int SC_PRECONDITION_FAILED &#x3D; 412;</span><br><span class="line">    int SC_REQUEST_ENTITY_TOO_LARGE &#x3D; 413;</span><br><span class="line">    int SC_REQUEST_URI_TOO_LONG &#x3D; 414;</span><br><span class="line">    int SC_UNSUPPORTED_MEDIA_TYPE &#x3D; 415;</span><br><span class="line">    int SC_REQUESTED_RANGE_NOT_SATISFIABLE &#x3D; 416;</span><br><span class="line">    int SC_EXPECTATION_FAILED &#x3D; 417;</span><br><span class="line">    int SC_INTERNAL_SERVER_ERROR &#x3D; 500;</span><br><span class="line">    int SC_NOT_IMPLEMENTED &#x3D; 501;</span><br><span class="line">    int SC_BAD_GATEWAY &#x3D; 502;</span><br><span class="line">    int SC_SERVICE_UNAVAILABLE &#x3D; 503;</span><br><span class="line">    int SC_GATEWAY_TIMEOUT &#x3D; 504;</span><br><span class="line">    int SC_HTTP_VERSION_NOT_SUPPORTED &#x3D; 505;</span><br><span class="line">    void sendError(int var1) throws IOException;</span><br><span class="line">    void setStatus(int var1);</span><br><span class="line">    void sendError(int var1, String var2) throws IOException;</span><br><span class="line">    &#x2F;** @deprecated *&#x2F;</span><br><span class="line">    void setStatus(int var1, String var2);</span><br><span class="line">    void sendRedirect(String var1) throws IOException;</span><br><span class="line">    boolean containsHeader(String var1);</span><br><span class="line">    void addIntHeader(String var1, int var2);</span><br><span class="line">    void setIntHeader(String var1, int var2);</span><br><span class="line">    void addDateHeader(String var1, long var2);</span><br><span class="line">    void setDateHeader(String var1, long var2);</span><br><span class="line">    void addCookie(Cookie var1);</span><br><span class="line">    String encodeRedirectURL(String var1);</span><br><span class="line">    &#x2F;** @deprecated *&#x2F;</span><br><span class="line">    String encodeRedirectUrl(String var1);</span><br><span class="line">    String encodeURL(String var1);</span><br><span class="line">    &#x2F;** @deprecated *&#x2F;</span><br><span class="line">    String encodeUrl(String var1);</span><br><span class="line">    void addHeader(String var1, String var2);</span><br><span class="line">    void setHeader(String var1, String var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>虽然response对象的getOutSream（）和getWriter（）方法都可以发送响应消息体，但是他们之间相互排斥，不可以同时使用，否则会发生异常。</p></blockquote><h4 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h4><p>浏览器默认字节码为ISO-8859-1，是不支持中文的。http传输时也是默认ISO-8859-1的。所以在使用中文的时候，会出现乱码的情况。一般情况转UTF-8即可。特殊情况的生僻字的话，就需要用Unicode码了。unicode不能直接用，需要进行转换。<br>最终乱码问题都需要进行一个编码统一。</p><h4 id="servlet的局限性"><a href="#servlet的局限性" class="headerlink" title="servlet的局限性"></a>servlet的局限性</h4><p>虽然servlet能输出html格式的字符串到页面，但是对复杂多变且几百行的html文件就有点力不从心了，这导致大量java转向php，这种内嵌html的动态语言，让做页面变得更为轻松。sun公司为了解决这一个问题，也研发出了一个动态网页生成技术jsp，同样可以在网页中去写java代码。<br>虽说jsp是动态页面生成技术，但是它还是基于servlet进行封装的。<a href="#">Post not found: daily/2200608 jsp和servlet有什么区别</a></p><h4 id="ServletContextListener（Servlet全局监听器）"><a href="#ServletContextListener（Servlet全局监听器）" class="headerlink" title="ServletContextListener（Servlet全局监听器）"></a>ServletContextListener（Servlet全局监听器）</h4><p>servlet上下文（容器）监听接口。单纯的监听servlet上下文的创建和销毁。这就可以在servlet容器的创建和销毁的时候做一些事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ServletContextListener extends EventListener &#123;</span><br><span class="line">    void contextDestroyed(ServletContextEvent var1);</span><br><span class="line">    void contextInitialized(ServletContextEvent var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那spring中核心用的就是ioc容器，那ioc是何时被加载的呢。这里spring提供了一个ContextLoaderListener的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ContextLoaderListener extends ContextLoader implements ServletContextListener &#123;</span><br><span class="line">    private ContextLoader contextLoader;</span><br><span class="line">    public ContextLoaderListener() &#123;&#125;</span><br><span class="line">    public ContextLoaderListener(WebApplicationContext context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;这里</span><br><span class="line">    public void contextInitialized(ServletContextEvent event) &#123;</span><br><span class="line">        this.contextLoader &#x3D; this.createContextLoader();</span><br><span class="line">        if (this.contextLoader &#x3D;&#x3D; null) &#123;</span><br><span class="line">            this.contextLoader &#x3D; this;</span><br><span class="line">        &#125;</span><br><span class="line">        this.contextLoader.initWebApplicationContext(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** @deprecated *&#x2F;</span><br><span class="line">    @Deprecated</span><br><span class="line">    protected ContextLoader createContextLoader() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;** @deprecated *&#x2F;</span><br><span class="line">    @Deprecated</span><br><span class="line">    public ContextLoader getContextLoader() &#123;</span><br><span class="line">        return this.contextLoader;</span><br><span class="line">    &#125;</span><br><span class="line">    public void contextDestroyed(ServletContextEvent event) &#123;</span><br><span class="line">        if (this.contextLoader !&#x3D; null) &#123;</span><br><span class="line">            this.contextLoader.closeWebApplicationContext(event.getServletContext());</span><br><span class="line">        &#125;</span><br><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ContextLoaderListener实现了ServletContextListener，在tomcat初始化后，ContextLoaderListener监听到servlet容器初始化完成之后，开始构建ioc容器。在tomcat关闭时，ContextLoaderListener监听到servlet容器被销毁后，开始ioc容器的销毁。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsp和servlet有什么区别</title>
      <link href="/java/basics/20200608/"/>
      <url>/java/basics/20200608/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="基本概念简述"><a href="#基本概念简述" class="headerlink" title="基本概念简述"></a>基本概念简述</h3><h4 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet"></a>什么是servlet</h4><p>Servlet其实就是一个遵循Servlet开发的java类。Servlet是由服务器调用的，运行在服务器端。</p><a id="more"></a><h4 id="为什么要用到Servlet"><a href="#为什么要用到Servlet" class="headerlink" title="为什么要用到Servlet"></a>为什么要用到Servlet</h4><p>我们编写java程序想要在网上实现 聊天、发帖、这样一些的交互功能，普通的java技术是非常难完成的。sun公司就提供了Servlet这种技术供我们使用。</p><h4 id="什么是JSP"><a href="#什么是JSP" class="headerlink" title="什么是JSP"></a>什么是JSP</h4><p>JSP全名为Java Server Pages，java服务器页面。JSP是一种基于文本的程序，其特点就是HTML和Java代码共同存在！</p><h4 id="为什么需要JSP"><a href="#为什么需要JSP" class="headerlink" title="为什么需要JSP"></a>为什么需要JSP</h4><p>JSP是为了简化Servlet的工作出现的替代品，Servlet输出HTML非常困难，JSP就是替代Servlet输出HTML的。</p><h4 id="JSP的工作原理"><a href="#JSP的工作原理" class="headerlink" title="JSP的工作原理"></a>JSP的工作原理</h4><ul><li>Tomcat访问任何的资源都是在访问Servlet。当然了，JSP也不例外！JSP本身就是一种Servlet。为什么我说JSP本身就是一种Servlet呢？其实JSP在第一次被访问的时候会被编译为HttpJspPage类（该类是HttpServlet的一个子类）</li><li>刚才我简单使用了一下JSP，它被编译成了这么一个Servlet:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">package org.apache.jsp;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.*;</span><br><span class="line">import javax.servlet.jsp.*;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public final class _1_jsp extends org.apache.jasper.runtime.HttpJspBase</span><br><span class="line">    implements org.apache.jasper.runtime.JspSourceDependent &#123;</span><br><span class="line"></span><br><span class="line">  private static final JspFactory _jspxFactory &#x3D; JspFactory.getDefaultFactory();</span><br><span class="line"></span><br><span class="line">  private static java.util.List&lt;String&gt; _jspx_dependants;</span><br><span class="line"></span><br><span class="line">  private javax.el.ExpressionFactory _el_expressionfactory;</span><br><span class="line">  private org.apache.tomcat.InstanceManager _jsp_instancemanager;</span><br><span class="line"></span><br><span class="line">  public java.util.List&lt;String&gt; getDependants() &#123;</span><br><span class="line">    return _jspx_dependants;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspInit() &#123;</span><br><span class="line">    _el_expressionfactory &#x3D; _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();</span><br><span class="line">    _jsp_instancemanager &#x3D; org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspDestroy() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void _jspService(final HttpServletRequest request, final HttpServletResponse response)</span><br><span class="line">        throws java.io.IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">    final PageContext pageContext;</span><br><span class="line">    HttpSession session &#x3D; null;</span><br><span class="line">    final ServletContext application;</span><br><span class="line">    final ServletConfig config;</span><br><span class="line">    JspWriter out &#x3D; null;</span><br><span class="line">    final Object page &#x3D; this;</span><br><span class="line">    JspWriter _jspx_out &#x3D; null;</span><br><span class="line">    PageContext _jspx_page_context &#x3D; null;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br><span class="line">      pageContext &#x3D; _jspxFactory.getPageContext(this, request, response,</span><br><span class="line">                  null, true, 8192, true);</span><br><span class="line">      _jspx_page_context &#x3D; pageContext;</span><br><span class="line">      application &#x3D; pageContext.getServletContext();</span><br><span class="line">      config &#x3D; pageContext.getServletConfig();</span><br><span class="line">      session &#x3D; pageContext.getSession();</span><br><span class="line">      out &#x3D; pageContext.getOut();</span><br><span class="line">      _jspx_out &#x3D; out;</span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;html&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;head&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;    &lt;title&gt;简单使用JSP&lt;&#x2F;title&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;&#x2F;head&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;body&gt;\r\n&quot;);</span><br><span class="line">      String s &#x3D; &quot;HelloWorda&quot;;</span><br><span class="line">      out.println(s);</span><br><span class="line">      out.write(&quot;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;&#x2F;body&gt;\r\n&quot;);</span><br><span class="line">      out.write(&quot;&lt;&#x2F;html&gt;\r\n&quot;);</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">      if (!(t instanceof SkipPageException))&#123;</span><br><span class="line">        out &#x3D; _jspx_out;</span><br><span class="line">        if (out !&#x3D; null &amp;&amp; out.getBufferSize() !&#x3D; 0)</span><br><span class="line">          try &#123; out.clearBuffer(); &#125; catch (java.io.IOException e) &#123;&#125;</span><br><span class="line">        if (_jspx_page_context !&#x3D; null) _jspx_page_context.handlePageException(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      _jspxFactory.releasePageContext(_jspx_page_context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译过程是这样子的：浏览器第一次请求1.jsp时，Tomcat会将1.jsp转化成1_jsp.java这么一个类，并将该文件编译成class文件。编译完毕后再运行class文件来响应浏览器的请求。</li><li>以后访问1.jsp就不再重新编译jsp文件了，直接调用class文件来响应浏览器。当然了，如果Tomcat检测到JSP页面改动了的话，会重新编译的。</li><li>既然JSP是一个Servlet，那JSP页面中的HTML排版标签是怎么样被发送到浏览器的？我们来看下上面1_jsp.java的源码就知道了。原来就是用write()出去的罢了。说到底，JSP就是封装了Servlet的java程序罢了。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">out.write(&quot;\r\n&quot;);</span><br><span class="line">out.write(&quot;\r\n&quot;);</span><br><span class="line">out.write(&quot;&lt;html&gt;\r\n&quot;);</span><br><span class="line">out.write(&quot;&lt;head&gt;\r\n&quot;);</span><br><span class="line">out.write(&quot;    &lt;title&gt;简单使用JSP&lt;&#x2F;title&gt;\r\n&quot;);</span><br><span class="line">out.write(&quot;&lt;&#x2F;head&gt;\r\n&quot;);</span><br><span class="line">out.write(&quot;&lt;body&gt;\r\n&quot;);</span><br></pre></td></tr></table></figure><ul><li>有人可能也会问：JSP页面的代码服务器是怎么执行的？再看回1_jsp.java文件，java代码就直接在类中的service()中。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; &quot;HelloWorda&quot;;</span><br><span class="line">out.println(s);</span><br></pre></td></tr></table></figure><ul><li>JSP比Servlet更方便更简单的一个重要原因就是：内置了9个对象！内置对象有：out、session、response、request、config、page、application、pageContext、exception。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础类型</title>
      <link href="/java/basics/20200508/"/>
      <url>/java/basics/20200508/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><a id="more"></a>### java基础类型#### bit 普及是二进制数的一位包含的信息或2个选项中特别指定1个的需要信息量称为一比特，是表示信息的最小单位，只有两种状态：0和1。这两个值也可以被解释为逻辑值(真/假、yes/no)、代数符号(+/-)、激活状态(on/off)或任何其他两值属性。1byte = 8bit#### byte（1byte）<ul><li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li><li>最小值是 -128（-2^7）；</li><li>最大值是 127（2^7-1）；</li><li>默认值是 0；</li><li>byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；</li><li>封装类型Byte</li><li>例子：byte a = 100，byte b = -50。</li></ul><h4 id="short（2byte）"><a href="#short（2byte）" class="headerlink" title="short（2byte）"></a>short（2byte）</h4><ul><li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li><li>最小值是 -32768（-2^15）；</li><li>最大值是 32767（2^15 - 1）；</li><li>Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；</li><li>默认值是 0；</li><li>封装类型Short</li><li>缓存对象ShortCache，范围-128到127</li><li>例子：short s = 1000，short r = -20000。</li></ul><h4 id="char（2byte）"><a href="#char（2byte）" class="headerlink" title="char（2byte）"></a>char（2byte）</h4><ul><li>char类型是一个单一的 16 位 Unicode 字符；</li><li>最小值是 \u0000（即为0）；</li><li>最大值是 \uffff（即为65,535）；</li><li>char 数据类型可以储存任何字符；</li><li>封装对象Character</li><li>缓存对象ByteCache，范围-128到127</li><li>例子：char letter = ‘A’;。</li></ul><h4 id="int（4byte）"><a href="#int（4byte）" class="headerlink" title="int（4byte）"></a>int（4byte）</h4><ul><li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li><li>最小值是 -2,147,483,648（-2^31）；</li><li>最大值是 2,147,483,647（2^31 - 1）；</li><li>一般地整型变量默认为 int 类型；</li><li>默认值是 0 ；</li><li>封装类型Integer</li><li>缓存对象IntegerCache，范围-128到127，可通过参数改变范围</li><li>例子：int a = 100000, int b = -200000。</li></ul><h4 id="long（8byte）"><a href="#long（8byte）" class="headerlink" title="long（8byte）"></a>long（8byte）</h4><ul><li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li><li>最小值是 -9,223,372,036,854,775,808（-2^63）；</li><li>最大值是 9,223,372,036,854,775,807（2^63 -1）；</li><li>这种类型主要使用在需要比较大整数的系统上；</li><li>默认值是 0L；</li><li>封装类型Long</li><li>缓存对象LongCache，范围-128到127</li><li>例子： long a = 100000L，Long b = -200000L。</li><li>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。</li></ul><h4 id="float（4byte）"><a href="#float（4byte）" class="headerlink" title="float（4byte）"></a>float（4byte）</h4><ul><li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li><li>float 在储存大型浮点数组的时候可节省内存空间；</li><li>默认值是 0.0f；</li><li>浮点数不能用来表示精确的值，如货币；</li><li>封装类型Float</li><li>例子：float f1 = 234.5f。</li></ul><h4 id="double（8byte）"><a href="#double（8byte）" class="headerlink" title="double（8byte）"></a>double（8byte）</h4><ul><li>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</li><li>浮点数的默认类型为double类型；</li><li>double类型同样不能表示精确的值，如货币；</li><li>默认值是 0.0d；</li><li>封装类型Double</li><li>例子：double d1 = 123.4。</li></ul><h4 id="boolean（1byte）"><a href="#boolean（1byte）" class="headerlink" title="boolean（1byte）"></a>boolean（1byte）</h4><ul><li>boolean数据类型表示一位的信息；</li><li>只有两个取值：true 和 false；</li><li>这种类型只作为一种标志来记录 true/false 情况；</li><li>默认值是 false；</li><li>封装类型Boolean</li><li>例子：boolean one = true。</li></ul><blockquote><p>从左向右自动转换，从右向左强制转换会精度损失，要加0.5，进行四舍五入。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java8 λ（lambad）表达式</title>
      <link href="/java/basics/20190929/"/>
      <url>/java/basics/20190929/</url>
      
        <content type="html"><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</title>
      <link href="/java/basics/20190501/"/>
      <url>/java/basics/20190501/</url>
      
        <content type="html"><![CDATA[<h3 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMap不支持并发，线程不安全。结构如图：<a id="more"></a><br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/0nh9YWO.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图上所示，没有扩容的情况。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadFactor：负载因子，默认为 0.75。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threshold：扩容的阈值，等于 capacity * loadFactor</p><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 当插入第一个元素的时候，需要先初始化数组大小</span><br><span class="line">    if (table &#x3D;&#x3D; EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return putForNullKey(value);</span><br><span class="line">    &#x2F;&#x2F; 1. 求 key 的 hash 值</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    &#x2F;&#x2F; 2. 找到对应的数组下标</span><br><span class="line">    int i &#x3D; indexFor(hash, table.length);</span><br><span class="line">    &#x2F;&#x2F; 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span><br><span class="line">    &#x2F;&#x2F;    如果有，直接覆盖，put 方法返回旧值就结束了</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[i]; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            e.value &#x3D; value;</span><br><span class="line">            e.recordAccess(this);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    modCount++;</span><br><span class="line">    &#x2F;&#x2F; 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>数组初始化</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void inflateTable(int toSize) &#123;</span><br><span class="line">    &#x2F;&#x2F; 保证数组大小一定是 2 的 n 次方。</span><br><span class="line">    &#x2F;&#x2F; 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span><br><span class="line">    int capacity &#x3D; roundUpToPowerOf2(toSize);</span><br><span class="line">    &#x2F;&#x2F; 计算扩容阈值：capacity * loadFactor</span><br><span class="line">    threshold &#x3D; (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">    &#x2F;&#x2F; 算是初始化数组吧</span><br><span class="line">    table &#x3D; new Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); &#x2F;&#x2F;ignore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。<br>**<em>计算具体数组位置**</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static int indexFor(int hash, int length) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert Integer.bitCount(length) &#x3D;&#x3D; 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">    return hash &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。<br>**<em>添加节点到链表中**</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span><br><span class="line">    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;</span><br><span class="line">        &#x2F;&#x2F; 扩容，后面会介绍一下</span><br><span class="line">        resize(2 * table.length);</span><br><span class="line">        &#x2F;&#x2F; 扩容以后，重新计算 hash 值</span><br><span class="line">        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;</span><br><span class="line">        &#x2F;&#x2F; 重新计算扩容后的新的下标</span><br><span class="line">        bucketIndex &#x3D; indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 往下看</span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这个很简单，其实就是将新值放到链表的表头，然后 size++</span><br><span class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];</span><br><span class="line">    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。<br>**<em>数组扩容**</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable &#x3D; table;</span><br><span class="line">    int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">    if (oldCapacity &#x3D;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 新的数组</span><br><span class="line">    Entry[] newTable &#x3D; new Entry[newCapacity];</span><br><span class="line">    &#x2F;&#x2F; 将原来数组中的值迁移到新的更大的数组中</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table &#x3D; newTable;</span><br><span class="line">    threshold &#x3D; (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。</p><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对于 put 过程，get 过程是非常简单的。</p><ol><li>根据 key 计算 hash 值。</li><li>找到相应的数组下标：hash &amp; (length – 1)。</li><li>遍历该数组位置处的链表，直到找到相等(==或equals)的 key。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    &#x2F;&#x2F; 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了</span><br><span class="line">    if (key &#x3D;&#x3D; null)</span><br><span class="line">        return getForNullKey();</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    Entry&lt;K,V&gt; entry &#x3D; getEntry(key);</span><br><span class="line"> </span><br><span class="line">    return null &#x3D;&#x3D; entry ? null : entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getEntry(key):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</span><br><span class="line">    if (size &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int hash &#x3D; (key &#x3D;&#x3D; null) ? 0 : hash(key);</span><br><span class="line">    &#x2F;&#x2F; 确定数组下标，然后从头开始遍历链表，直到找到为止</span><br><span class="line">    for (Entry&lt;K,V&gt; e &#x3D; table[indexFor(hash, table.length)];</span><br><span class="line">         e !&#x3D; null;</span><br><span class="line">         e &#x3D; e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return e;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 segment。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/A0DsblS.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><p><strong><em>初始化</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;&#x3D; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel &#x3D; MAX_SEGMENTS;</span><br><span class="line">    &#x2F;&#x2F; Find power-of-two sizes best matching arguments</span><br><span class="line">    int sshift &#x3D; 0;</span><br><span class="line">    int ssize &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span><br><span class="line">    while (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;&#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span><br><span class="line">    &#x2F;&#x2F; 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span><br><span class="line">    this.segmentShift &#x3D; 32 - sshift;</span><br><span class="line">    this.segmentMask &#x3D; ssize - 1;</span><br><span class="line"> </span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; initialCapacity 是设置整个 map 初始的大小，</span><br><span class="line">    &#x2F;&#x2F; 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span><br><span class="line">    &#x2F;&#x2F; 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个</span><br><span class="line">    int c &#x3D; initialCapacity &#x2F; ssize;</span><br><span class="line">    if (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    &#x2F;&#x2F; 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span><br><span class="line">    &#x2F;&#x2F; 插入一个元素不至于扩容，插入第二个的时候才会扩容</span><br><span class="line">    int cap &#x3D; MIN_SEGMENT_TABLE_CAPACITY; </span><br><span class="line">    while (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;&#x3D; 1;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 创建 Segment 数组，</span><br><span class="line">    &#x2F;&#x2F; 并创建数组的第一个元素 segment[0]</span><br><span class="line">    Segment&lt;K,V&gt; s0 &#x3D;</span><br><span class="line">        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss &#x3D; (Segment&lt;K,V&gt;[])new Segment[ssize];</span><br><span class="line">    &#x2F;&#x2F; 往数组写入 segment[0]</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); &#x2F;&#x2F; ordered write of segments[0]</span><br><span class="line">    this.segments &#x3D; ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化完成，我们得到了一个 Segment 数组。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p><ul><li>Segment 数组长度为 16，不可以扩容</li><li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li><li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li></ul><p>当前 segmentShift 的值为 32 – 4 = 28，segmentMask 为 16 – 1 = 15，姑且把它们简单翻译为移位数和掩码，这两个值马上就会用到</p><h4 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    if (value &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#x2F;&#x2F; 1. 计算 key 的 hash 值</span><br><span class="line">    int hash &#x3D; hash(key);</span><br><span class="line">    &#x2F;&#x2F; 2. 根据 hash 值找到 Segment 数组中的位置 j</span><br><span class="line">    &#x2F;&#x2F;    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下低 4 位，</span><br><span class="line">    &#x2F;&#x2F;    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的最后 4 位，也就是槽的数组下标</span><br><span class="line">    int j &#x3D; (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    &#x2F;&#x2F; 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，</span><br><span class="line">    &#x2F;&#x2F; ensureSegment(j) 对 segment[j] 进行初始化</span><br><span class="line">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObject          &#x2F;&#x2F; nonvolatile; recheck</span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) &#x3D;&#x3D; null) &#x2F;&#x2F;  in ensureSegment</span><br><span class="line">        s &#x3D; ensureSegment(j);</span><br><span class="line">    &#x2F;&#x2F; 3. 插入新值到 槽 s 中</span><br><span class="line">    return s.put(key, hash, value, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Segment 内部是由 数组+链表 组成的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    &#x2F;&#x2F; 在往该 segment 写入前，需要先获取该 segment 的独占锁</span><br><span class="line">    &#x2F;&#x2F;    先看主流程，后面还会具体介绍这部分内容</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; tryLock() ? null :</span><br><span class="line">        scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 这个是 segment 内部的数组</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; table;</span><br><span class="line">        &#x2F;&#x2F; 再利用 hash 值，求应该放置的数组下标</span><br><span class="line">        int index &#x3D; (tab.length - 1) &amp; hash;</span><br><span class="line">        &#x2F;&#x2F; first 是数组该位置处的链表的表头</span><br><span class="line">        HashEntry&lt;K,V&gt; first &#x3D; entryAt(tab, index);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; first;;) &#123;</span><br><span class="line">            if (e !&#x3D; null) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                if ((k &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                    (e.hash &#x3D;&#x3D; hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue &#x3D; e.value;</span><br><span class="line">                    if (!onlyIfAbsent) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 覆盖旧值</span><br><span class="line">                        e.value &#x3D; value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 继续顺着链表走</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                &#x2F;&#x2F; node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。</span><br><span class="line">                &#x2F;&#x2F; 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。</span><br><span class="line">                if (node !&#x3D; null)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                else</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line"> </span><br><span class="line">                int c &#x3D; count + 1;</span><br><span class="line">                &#x2F;&#x2F; 如果超过了该 segment 的阈值，这个 segment 需要扩容</span><br><span class="line">                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node); &#x2F;&#x2F; 扩容后面也会具体分析</span><br><span class="line">                else</span><br><span class="line">                    &#x2F;&#x2F; 没有达到阈值，将 node 放到数组 tab 的 index 位置，</span><br><span class="line">                    &#x2F;&#x2F; 其实就是将新的节点设置成原链表的表头</span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                ++modCount;</span><br><span class="line">                count &#x3D; c;</span><br><span class="line">                oldValue &#x3D; null;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 解锁</span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    return oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。<br>**<em>初始化槽: ensureSegment**</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private Segment&lt;K,V&gt; ensureSegment(int k) &#123;</span><br><span class="line">    final Segment&lt;K,V&gt;[] ss &#x3D; this.segments;</span><br><span class="line">    long u &#x3D; (k &lt;&lt; SSHIFT) + SBASE; &#x2F;&#x2F; raw offset</span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里看到为什么之前要初始化 segment[0] 了，</span><br><span class="line">        &#x2F;&#x2F; 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span><br><span class="line">        &#x2F;&#x2F; 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span><br><span class="line">        Segment&lt;K,V&gt; proto &#x3D; ss[0];</span><br><span class="line">        int cap &#x3D; proto.table.length;</span><br><span class="line">        float lf &#x3D; proto.loadFactor;</span><br><span class="line">        int threshold &#x3D; (int)(cap * lf);</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 初始化 segment[k] 内部的数组</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab &#x3D; (HashEntry&lt;K,V&gt;[])new HashEntry[cap];</span><br><span class="line">        if ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; 再次检查一遍该槽是否被其他线程初始化了。</span><br><span class="line"> </span><br><span class="line">            Segment&lt;K,V&gt; s &#x3D; new Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            &#x2F;&#x2F; 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span><br><span class="line">            while ((seg &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (UNSAFE.compareAndSwapObject(ss, u, null, seg &#x3D; s))</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我没搞懂这里为什么要搞一个 while 循环，CAS 失败不就代表有其他线程成功了吗，为什么要再进行判断？</p><p><strong><em>获取写入锁: scanAndLockForPut</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们来具体分析这个方法中是怎么控制加锁的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt; first &#x3D; entryForHash(this, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e &#x3D; first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node &#x3D; null;</span><br><span class="line">    int retries &#x3D; -1; &#x2F;&#x2F; negative while locating node</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 循环获取锁</span><br><span class="line">    while (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; &#x2F;&#x2F; to recheck first below</span><br><span class="line">        if (retries &lt; 0) &#123;</span><br><span class="line">            if (e &#x3D;&#x3D; null) &#123;</span><br><span class="line">                if (node &#x3D;&#x3D; null) &#x2F;&#x2F; speculatively create node</span><br><span class="line">                    &#x2F;&#x2F; 进到这里说明数组该位置的链表是空的，没有任何元素</span><br><span class="line">                    &#x2F;&#x2F; 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置</span><br><span class="line">                    node &#x3D; new HashEntry&lt;K,V&gt;(hash, key, value, null);</span><br><span class="line">                retries &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (key.equals(e.key))</span><br><span class="line">                retries &#x3D; 0;</span><br><span class="line">            else</span><br><span class="line">                &#x2F;&#x2F; 顺着链表往下走</span><br><span class="line">                e &#x3D; e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁</span><br><span class="line">        &#x2F;&#x2F;    lock() 是阻塞方法，直到获取锁后返回</span><br><span class="line">        else if (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if ((retries &amp; 1) &#x3D;&#x3D; 0 &amp;&amp;</span><br><span class="line">                 &#x2F;&#x2F; 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头</span><br><span class="line">                 &#x2F;&#x2F;     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法</span><br><span class="line">                 (f &#x3D; entryForHash(this, hash)) !&#x3D; first) &#123;</span><br><span class="line">            e &#x3D; first &#x3D; f; &#x2F;&#x2F; re-traverse if entry changed</span><br><span class="line">            retries &#x3D; -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法就是看似复杂，但是其实就是做了一件事，那就是获取该 segment 的独占锁，如果需要的话顺便实例化了一下 node。</p><p><strong><em>扩容: rehash</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry[] 进行扩容，扩容后，容量为原来的 2 倍。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span><br><span class="line">private void rehash(HashEntry&lt;K,V&gt; node) &#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable &#x3D; table;</span><br><span class="line">    int oldCapacity &#x3D; oldTable.length;</span><br><span class="line">    &#x2F;&#x2F; 2 倍</span><br><span class="line">    int newCapacity &#x3D; oldCapacity &lt;&lt; 1;</span><br><span class="line">    threshold &#x3D; (int)(newCapacity * loadFactor);</span><br><span class="line">    &#x2F;&#x2F; 创建新数组</span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable &#x3D;</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</span><br><span class="line">    &#x2F;&#x2F; 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span><br><span class="line">    int sizeMask &#x3D; newCapacity - 1;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span><br><span class="line">    for (int i &#x3D; 0; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; e 是链表的第一个元素</span><br><span class="line">        HashEntry&lt;K,V&gt; e &#x3D; oldTable[i];</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next &#x3D; e.next;</span><br><span class="line">            &#x2F;&#x2F; 计算应该放置在新数组中的位置，</span><br><span class="line">            &#x2F;&#x2F; 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 &#x3D; 19</span><br><span class="line">            int idx &#x3D; e.hash &amp; sizeMask;</span><br><span class="line">            if (next &#x3D;&#x3D; null)   &#x2F;&#x2F; 该位置处只有一个元素，那比较好办</span><br><span class="line">                newTable[idx] &#x3D; e;</span><br><span class="line">            else &#123; &#x2F;&#x2F; Reuse consecutive sequence at same slot</span><br><span class="line">                &#x2F;&#x2F; e 是链表表头</span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F; idx 是当前链表的头结点 e 的新位置</span><br><span class="line">                int lastIdx &#x3D; idx;</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F; 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span><br><span class="line">                for (HashEntry&lt;K,V&gt; last &#x3D; next;</span><br><span class="line">                     last !&#x3D; null;</span><br><span class="line">                     last &#x3D; last.next) &#123;</span><br><span class="line">                    int k &#x3D; last.hash &amp; sizeMask;</span><br><span class="line">                    if (k !&#x3D; lastIdx) &#123;</span><br><span class="line">                        lastIdx &#x3D; k;</span><br><span class="line">                        lastRun &#x3D; last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span><br><span class="line">                newTable[lastIdx] &#x3D; lastRun;</span><br><span class="line">                &#x2F;&#x2F; 下面的操作是处理 lastRun 之前的节点，</span><br><span class="line">                &#x2F;&#x2F;    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span><br><span class="line">                for (HashEntry&lt;K,V&gt; p &#x3D; e; p !&#x3D; lastRun; p &#x3D; p.next) &#123;</span><br><span class="line">                    V v &#x3D; p.value;</span><br><span class="line">                    int h &#x3D; p.hash;</span><br><span class="line">                    int k &#x3D; h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n &#x3D; newTable[k];</span><br><span class="line">                    newTable[k] &#x3D; new HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span><br><span class="line">    int nodeIndex &#x3D; node.hash &amp; sizeMask; &#x2F;&#x2F; add the new node</span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] &#x3D; node;</span><br><span class="line">    table &#x3D; newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆。</p><h4 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对于 put 来说，get 真的不要太简单。</p><ol><li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li><li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li><li>到这里是链表了，顺着链表进行查找即可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Segment&lt;K,V&gt; s; &#x2F;&#x2F; manually integrate access methods to reduce overhead</span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">    &#x2F;&#x2F; 1. hash 值</span><br><span class="line">    int h &#x3D; hash(key);</span><br><span class="line">    long u &#x3D; (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">    &#x2F;&#x2F; 2. 根据 hash 找到对应的 segment</span><br><span class="line">    if ((s &#x3D; (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) !&#x3D; null &amp;&amp;</span><br><span class="line">        (tab &#x3D; s.table) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 3. 找到segment 内部数组相应位置的链表，遍历</span><br><span class="line">        for (HashEntry&lt;K,V&gt; e &#x3D; (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">             e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">            K k;</span><br><span class="line">            if ((k &#x3D; e.key) &#x3D;&#x3D; key || (e.hash &#x3D;&#x3D; h &amp;&amp; key.equals(k)))</span><br><span class="line">                return e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p><ul><li>put 操作的线程安全性。<ul><li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li><li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li><li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li></ul></li><li>remove 操作的线程安全性。<ul><li>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</li><li>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</li><li>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</li><li>如果 remove 先破坏了一个节点，分两种情况考虑。 <ul><li>如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。</li><li>如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</li></ul></li></ul></li></ul><h3 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来一张图简单示意一下吧：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/oltOuK5.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h4 id="put方法-2"><a href="#put方法-2" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span><br><span class="line">&#x2F;&#x2F; 第四个参数 evict 我们这里不关心</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    &#x2F;&#x2F; 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span><br><span class="line">    &#x2F;&#x2F; 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span><br><span class="line">    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">        n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">    &#x2F;&#x2F; 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span><br><span class="line">    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">        tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line"> </span><br><span class="line">    else &#123;&#x2F;&#x2F; 数组该位置有数据</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        &#x2F;&#x2F; 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span><br><span class="line">        if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            e &#x3D; p;</span><br><span class="line">        &#x2F;&#x2F; 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 到这里，说明数组该位置上是一个链表</span><br><span class="line">            for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                &#x2F;&#x2F; 插入到链表的最后面(Java7 是插入到链表的最前面)</span><br><span class="line">                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                    &#x2F;&#x2F; TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个</span><br><span class="line">                    &#x2F;&#x2F; 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 如果在该链表中找到了&quot;相等&quot;的 key(&#x3D;&#x3D; 或 equals)</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    &#x2F;&#x2F; 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span><br><span class="line">                    break;</span><br><span class="line">                p &#x3D; e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; e!&#x3D;null 说明存在旧值的key与要插入的key&quot;相等&quot;</span><br><span class="line">        &#x2F;&#x2F; 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            V oldValue &#x3D; e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                e.value &#x3D; value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    &#x2F;&#x2F; 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p><p><strong><em>数组扩容</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr &#x3D; threshold;</span><br><span class="line">    int newCap, newThr &#x3D; 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123; &#x2F;&#x2F; 对应数组扩容</span><br><span class="line">        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 将数组大小扩大一倍</span><br><span class="line">        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            &#x2F;&#x2F; 将阈值扩大一倍</span><br><span class="line">            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    else if (oldThr &gt; 0) &#x2F;&#x2F; 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span><br><span class="line">        newCap &#x3D; oldThr;</span><br><span class="line">    else &#123;&#x2F;&#x2F; 对应使用 new HashMap() 初始化后，第一次 put 的时候</span><br><span class="line">        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold &#x3D; newThr;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 用新的数组大小初始化新的数组</span><br><span class="line">    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">    table &#x3D; newTab; &#x2F;&#x2F; 如果是初始化数组，到这里就结束了，返回 newTab 即可</span><br><span class="line"> </span><br><span class="line">    if (oldTab !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 开始遍历原数组，进行数据迁移。</span><br><span class="line">        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                oldTab[j] &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F; 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span><br><span class="line">                if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                &#x2F;&#x2F; 如果是红黑树，具体我们就不展开了</span><br><span class="line">                else if (e instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                else &#123; </span><br><span class="line">                    &#x2F;&#x2F; 这块是处理链表的情况，</span><br><span class="line">                    &#x2F;&#x2F; 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span><br><span class="line">                    &#x2F;&#x2F; loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span><br><span class="line">                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next &#x3D; e.next;</span><br><span class="line">                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                loHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next &#x3D; e;</span><br><span class="line">                            loTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                hiHead &#x3D; e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next &#x3D; e;</span><br><span class="line">                            hiTail &#x3D; e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                    if (loTail !&#x3D; null) &#123;</span><br><span class="line">                        loTail.next &#x3D; null;</span><br><span class="line">                        &#x2F;&#x2F; 第一条链表</span><br><span class="line">                        newTab[j] &#x3D; loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                        hiTail.next &#x3D; null;</span><br><span class="line">                        &#x2F;&#x2F; 第二条链表的新的位置是 j + oldCap，这个很好理解</span><br><span class="line">                        newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法-2"><a href="#get方法-2" class="headerlink" title="get方法"></a>get方法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对于 put 来说，get 真的太简单了。</p><ul><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等(==或equals)的 key</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断第一个节点是不是就是需要的</span><br><span class="line">        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node</span><br><span class="line">            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e &#x3D; first.next) !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断是否是红黑树</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 链表遍历</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先用一个示意图来描述下其结构：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/Cfy6yxZ.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。<br>**<em>初始化**</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 这构造函数里，什么都不干</span><br><span class="line">public ConcurrentHashMap() &#123;</span><br><span class="line">&#125;</span><br><span class="line">public ConcurrentHashMap(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    int cap &#x3D; ((initialCapacity &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</span><br><span class="line">               MAXIMUM_CAPACITY :</span><br><span class="line">               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));</span><br><span class="line">    this.sizeCtl &#x3D; cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p><h4 id="put方法-3"><a href="#put方法-3" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(key, value, false);</span><br><span class="line">&#125;</span><br><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    &#x2F;&#x2F; 得到 hash 值</span><br><span class="line">    int hash &#x3D; spread(key.hashCode());</span><br><span class="line">    &#x2F;&#x2F; 用于记录相应链表的长度</span><br><span class="line">    int binCount &#x3D; 0;</span><br><span class="line">    for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">        &#x2F;&#x2F; 如果数组&quot;空&quot;，进行数组初始化</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">            &#x2F;&#x2F; 初始化数组，后面会详细介绍</span><br><span class="line">            tab &#x3D; initTable();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 找该 hash 值对应的数组下标，得到第一个节点 f</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果数组该位置为空，</span><br><span class="line">            &#x2F;&#x2F;    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了</span><br><span class="line">            &#x2F;&#x2F;          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了</span><br><span class="line">            if (casTabAt(tab, i, null,</span><br><span class="line">                         new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">            &#x2F;&#x2F; 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了</span><br><span class="line">            tab &#x3D; helpTransfer(tab, f);</span><br><span class="line"> </span><br><span class="line">        else &#123; &#x2F;&#x2F; 到这里就是说，f 是该位置的头结点，而且不为空</span><br><span class="line"> </span><br><span class="line">            V oldVal &#x3D; null;</span><br><span class="line">            &#x2F;&#x2F; 获取数组该位置的头结点的监视器锁</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                    if (fh &gt;&#x3D; 0) &#123; &#x2F;&#x2F; 头结点的 hash 值大于 0，说明是链表</span><br><span class="line">                        &#x2F;&#x2F; 用于累加，记录链表的长度</span><br><span class="line">                        binCount &#x3D; 1;</span><br><span class="line">                        &#x2F;&#x2F; 遍历链表</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            &#x2F;&#x2F; 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了</span><br><span class="line">                            if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                 (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal &#x3D; e.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    e.val &#x3D; value;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            &#x2F;&#x2F; 到了链表的最末端，将这个新值放到链表的最后面</span><br><span class="line">                            Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                            if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, null);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123; &#x2F;&#x2F; 红黑树</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount &#x3D; 2;</span><br><span class="line">                        &#x2F;&#x2F; 调用红黑树的插值方法插入新节点</span><br><span class="line">                        if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) !&#x3D; null) &#123;</span><br><span class="line">                            oldVal &#x3D; p.val;</span><br><span class="line">                            if (!onlyIfAbsent)</span><br><span class="line">                                p.val &#x3D; value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; binCount !&#x3D; 0 说明上面在做链表操作</span><br><span class="line">            if (binCount !&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8</span><br><span class="line">                if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                    &#x2F;&#x2F; 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span><br><span class="line">                    &#x2F;&#x2F; 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span><br><span class="line">                    &#x2F;&#x2F;    具体源码我们就不看了，扩容部分后面说</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                if (oldVal !&#x3D; null)</span><br><span class="line">                    return oldVal;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    addCount(1L, binCount);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。<br>**<em>初始化数组：initTable**</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个比较简单，主要就是初始化一个合适大小的数组，然后会设置 sizeCtl。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">    while ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了</span><br><span class="line">        if ((sc &#x3D; sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); &#x2F;&#x2F; lost initialization race; just spin</span><br><span class="line">        &#x2F;&#x2F; CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁</span><br><span class="line">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if ((tab &#x3D; table) &#x3D;&#x3D; null || tab.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; DEFAULT_CAPACITY 默认初始容量是 16</span><br><span class="line">                    int n &#x3D; (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    &#x2F;&#x2F; 初始化数组，长度为 16 或初始化时提供的长度</span><br><span class="line">                    Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                    &#x2F;&#x2F; 将这个数组赋值给 table，table 是 volatile 的</span><br><span class="line">                    table &#x3D; tab &#x3D; nt;</span><br><span class="line">                    &#x2F;&#x2F; 如果 n 为 16 的话，那么这里 sc &#x3D; 12</span><br><span class="line">                    &#x2F;&#x2F; 其实就是 0.75 * n</span><br><span class="line">                    sc &#x3D; n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; 设置 sizeCtl 为 sc，我们就当是 12 吧</span><br><span class="line">                sizeCtl &#x3D; sc;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>链表转红黑树: treeifyBin</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">    Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">    if (tab !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; MIN_TREEIFY_CAPACITY 为 64</span><br><span class="line">        &#x2F;&#x2F; 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容</span><br><span class="line">        if ((n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            &#x2F;&#x2F; 后面我们再详细分析这个方法</span><br><span class="line">            tryPresize(n &lt;&lt; 1);</span><br><span class="line">        &#x2F;&#x2F; b 是头结点</span><br><span class="line">        else if ((b &#x3D; tabAt(tab, index)) !&#x3D; null &amp;&amp; b.hash &gt;&#x3D; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 加锁</span><br><span class="line">            synchronized (b) &#123;</span><br><span class="line"> </span><br><span class="line">                if (tabAt(tab, index) &#x3D;&#x3D; b) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 下面就是遍历链表，建立一颗红黑树</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">                    for (Node&lt;K,V&gt; e &#x3D; b; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p &#x3D;</span><br><span class="line">                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              null, null);</span><br><span class="line">                        if ((p.prev &#x3D; tl) &#x3D;&#x3D; null)</span><br><span class="line">                            hd &#x3D; p;</span><br><span class="line">                        else</span><br><span class="line">                            tl.next &#x3D; p;</span><br><span class="line">                        tl &#x3D; p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 将红黑树设置到数组相应位置中</span><br><span class="line">                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>扩容：tryPresize</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了</span><br><span class="line">private final void tryPresize(int size) &#123;</span><br><span class="line">    &#x2F;&#x2F; c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。</span><br><span class="line">    int c &#x3D; (size &gt;&#x3D; (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</span><br><span class="line">        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);</span><br><span class="line">    int sc;</span><br><span class="line">    while ((sc &#x3D; sizeCtl) &gt;&#x3D; 0) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab &#x3D; table; int n;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码</span><br><span class="line">        if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            n &#x3D; (sc &gt; c) ? sc : c;</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (table &#x3D;&#x3D; tab) &#123;</span><br><span class="line">                        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                        table &#x3D; nt;</span><br><span class="line">                        sc &#x3D; n - (n &gt;&gt;&gt; 2); &#x2F;&#x2F; 0.75 * n</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    sizeCtl &#x3D; sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (c &lt;&#x3D; sc || n &gt;&#x3D; MAXIMUM_CAPACITY)</span><br><span class="line">            break;</span><br><span class="line">        else if (tab &#x3D;&#x3D; table) &#123;</span><br><span class="line">            &#x2F;&#x2F; 我没看懂 rs 的真正含义是什么，不过也关系不大</span><br><span class="line">            int rs &#x3D; resizeStamp(n);</span><br><span class="line"> </span><br><span class="line">            if (sc &lt; 0) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;</span><br><span class="line">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) !&#x3D; rs || sc &#x3D;&#x3D; rs + 1 ||</span><br><span class="line">                    sc &#x3D;&#x3D; rs + MAX_RESIZERS || (nt &#x3D; nextTable) &#x3D;&#x3D; null ||</span><br><span class="line">                    transferIndex &lt;&#x3D; 0)</span><br><span class="line">                    break;</span><br><span class="line">                &#x2F;&#x2F; 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法</span><br><span class="line">                &#x2F;&#x2F;    此时 nextTab 不为 null</span><br><span class="line">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span><br><span class="line">            &#x2F;&#x2F;     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数</span><br><span class="line">            &#x2F;&#x2F;  调用 transfer 方法，此时 nextTab 参数为 null</span><br><span class="line">            else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                transfer(tab, null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，可能的操作就是执行 1 次 transfer(tab, null) + 多次 transfer(tab, nt)，这里怎么结束循环的需要看完 transfer 源码才清楚。</p><p><strong><em>数据迁移：transfer</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是步长，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后从后往前的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</span><br><span class="line">    int n &#x3D; tab.length, stride;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)&#x2F;NCPU，最小值是 16</span><br><span class="line">    &#x2F;&#x2F; stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，</span><br><span class="line">    &#x2F;&#x2F;   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务</span><br><span class="line">    if ((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride &#x3D; MIN_TRANSFER_STRIDE; &#x2F;&#x2F; subdivide range</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 如果 nextTab 为 null，先进行一次初始化</span><br><span class="line">    &#x2F;&#x2F;    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null</span><br><span class="line">    &#x2F;&#x2F;       之后参与迁移的线程调用此方法时，nextTab 不会为 null</span><br><span class="line">    if (nextTab &#x3D;&#x3D; null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 容量翻倍</span><br><span class="line">            Node&lt;K,V&gt;[] nt &#x3D; (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">            nextTab &#x3D; nt;</span><br><span class="line">        &#125; catch (Throwable ex) &#123;      &#x2F;&#x2F; try to cope with OOME</span><br><span class="line">            sizeCtl &#x3D; Integer.MAX_VALUE;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; nextTable 是 ConcurrentHashMap 中的属性</span><br><span class="line">        nextTable &#x3D; nextTab;</span><br><span class="line">        &#x2F;&#x2F; transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置</span><br><span class="line">        transferIndex &#x3D; n;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int nextn &#x3D; nextTab.length;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; ForwardingNode 翻译过来就是正在被迁移的 Node</span><br><span class="line">    &#x2F;&#x2F; 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED</span><br><span class="line">    &#x2F;&#x2F; 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，</span><br><span class="line">    &#x2F;&#x2F;    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了</span><br><span class="line">    &#x2F;&#x2F;    所以它其实相当于是一个标志。</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd &#x3D; new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了</span><br><span class="line">    boolean advance &#x3D; true;</span><br><span class="line">    boolean finishing &#x3D; false; &#x2F;&#x2F; to ensure sweep before committing nextTab</span><br><span class="line"> </span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看</span><br><span class="line">     * </span><br><span class="line">     *&#x2F;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; i 是位置索引，bound 是边界，注意是从后往前</span><br><span class="line">    for (int i &#x3D; 0, bound &#x3D; 0;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; int fh;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 下面这个 while 真的是不好理解</span><br><span class="line">        &#x2F;&#x2F; advance 为 true 表示可以进行下一个位置的迁移了</span><br><span class="line">        &#x2F;&#x2F;   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride</span><br><span class="line">        while (advance) &#123;</span><br><span class="line">            int nextIndex, nextBound;</span><br><span class="line">            if (--i &gt;&#x3D; bound || finishing)</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 将 transferIndex 值赋给 nextIndex</span><br><span class="line">            &#x2F;&#x2F; 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了</span><br><span class="line">            else if ((nextIndex &#x3D; transferIndex) &lt;&#x3D; 0) &#123;</span><br><span class="line">                i &#x3D; -1;</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (U.compareAndSwapInt</span><br><span class="line">                     (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound &#x3D; (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : 0))) &#123;</span><br><span class="line">                &#x2F;&#x2F; 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前</span><br><span class="line">                bound &#x3D; nextBound;</span><br><span class="line">                i &#x3D; nextIndex - 1;</span><br><span class="line">                advance &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i &lt; 0 || i &gt;&#x3D; n || i + n &gt;&#x3D; nextn) &#123;</span><br><span class="line">            int sc;</span><br><span class="line">            if (finishing) &#123;</span><br><span class="line">                &#x2F;&#x2F; 所有的迁移操作已经完成</span><br><span class="line">                nextTable &#x3D; null;</span><br><span class="line">                &#x2F;&#x2F; 将新的 nextTab 赋值给 table 属性，完成迁移</span><br><span class="line">                table &#x3D; nextTab;</span><br><span class="line">                &#x2F;&#x2F; 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍</span><br><span class="line">                sizeCtl &#x3D; (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            &#x2F;&#x2F; 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2</span><br><span class="line">            &#x2F;&#x2F; 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，</span><br><span class="line">            &#x2F;&#x2F; 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务</span><br><span class="line">            if (U.compareAndSwapInt(this, SIZECTL, sc &#x3D; sizeCtl, sc - 1)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 任务结束，方法退出</span><br><span class="line">                if ((sc - 2) !&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    return;</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F; 到这里，说明 (sc - 2) &#x3D;&#x3D; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，</span><br><span class="line">                &#x2F;&#x2F; 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing)&#123;&#125; 分支了</span><br><span class="line">                finishing &#x3D; advance &#x3D; true;</span><br><span class="line">                i &#x3D; n; &#x2F;&#x2F; recheck before commit</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“</span><br><span class="line">        else if ((f &#x3D; tabAt(tab, i)) &#x3D;&#x3D; null)</span><br><span class="line">            advance &#x3D; casTabAt(tab, i, null, fwd);</span><br><span class="line">        &#x2F;&#x2F; 该位置处是一个 ForwardingNode，代表该位置已经迁移过了</span><br><span class="line">        else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">            advance &#x3D; true; &#x2F;&#x2F; already processed</span><br><span class="line">        else &#123;</span><br><span class="line">            &#x2F;&#x2F; 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    &#x2F;&#x2F; 头结点的 hash 大于 0，说明是链表的 Node 节点</span><br><span class="line">                    if (fh &gt;&#x3D; 0) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，</span><br><span class="line">                        &#x2F;&#x2F; 需要将链表一分为二，</span><br><span class="line">                        &#x2F;&#x2F;   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span><br><span class="line">                        &#x2F;&#x2F;   lastRun 之前的节点需要进行克隆，然后分到两个链表中</span><br><span class="line">                        int runBit &#x3D; fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun &#x3D; f;</span><br><span class="line">                        for (Node&lt;K,V&gt; p &#x3D; f.next; p !&#x3D; null; p &#x3D; p.next) &#123;</span><br><span class="line">                            int b &#x3D; p.hash &amp; n;</span><br><span class="line">                            if (b !&#x3D; runBit) &#123;</span><br><span class="line">                                runBit &#x3D; b;</span><br><span class="line">                                lastRun &#x3D; p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (runBit &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                            ln &#x3D; lastRun;</span><br><span class="line">                            hn &#x3D; null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            hn &#x3D; lastRun;</span><br><span class="line">                            ln &#x3D; null;</span><br><span class="line">                        &#125;</span><br><span class="line">                        for (Node&lt;K,V&gt; p &#x3D; f; p !&#x3D; lastRun; p &#x3D; p.next) &#123;</span><br><span class="line">                            int ph &#x3D; p.hash; K pk &#x3D; p.key; V pv &#x3D; p.val;</span><br><span class="line">                            if ((ph &amp; n) &#x3D;&#x3D; 0)</span><br><span class="line">                                ln &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            else</span><br><span class="line">                                hn &#x3D; new Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 其中的一个链表放在新数组的位置 i</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        &#x2F;&#x2F; 另一个链表放在新数组的位置 i+n</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        &#x2F;&#x2F; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span><br><span class="line">                        &#x2F;&#x2F;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        &#x2F;&#x2F; advance 设置为 true，代表该位置已经迁移完毕</span><br><span class="line">                        advance &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (f instanceof TreeBin) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 红黑树的迁移</span><br><span class="line">                        TreeBin&lt;K,V&gt; t &#x3D; (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        int lc &#x3D; 0, hc &#x3D; 0;</span><br><span class="line">                        for (Node&lt;K,V&gt; e &#x3D; t.first; e !&#x3D; null; e &#x3D; e.next) &#123;</span><br><span class="line">                            int h &#x3D; e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p &#x3D; new TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, null, null);</span><br><span class="line">                            if ((h &amp; n) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                if ((p.prev &#x3D; loTail) &#x3D;&#x3D; null)</span><br><span class="line">                                    lo &#x3D; p;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; p;</span><br><span class="line">                                loTail &#x3D; p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            else &#123;</span><br><span class="line">                                if ((p.prev &#x3D; hiTail) &#x3D;&#x3D; null)</span><br><span class="line">                                    hi &#x3D; p;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; p;</span><br><span class="line">                                hiTail &#x3D; p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span><br><span class="line">                        ln &#x3D; (lc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn &#x3D; (hc &lt;&#x3D; UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc !&#x3D; 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line"> </span><br><span class="line">                        &#x2F;&#x2F; 将 ln 放置在新数组的位置 i</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        &#x2F;&#x2F; 将 hn 放置在新数组的位置 i+n</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        &#x2F;&#x2F; 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span><br><span class="line">                        &#x2F;&#x2F;    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        &#x2F;&#x2F; advance 设置为 true，代表该位置已经迁移完毕</span><br><span class="line">                        advance &#x3D; true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p><h4 id="get方法-3"><a href="#get方法-3" class="headerlink" title="get方法"></a>get方法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get 方法从来都是最简单的，这里也不例外：</p><ul><li>计算 hash 值</li><li>根据 hash 值找到数组对应位置: (n – 1) &amp; h</li><li>根据该位置处结点性质进行相应查找</li><li>如果该位置为 null，那么直接返回 null 就可以了</li><li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li><li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li><li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    int h &#x3D; spread(key.hashCode());</span><br><span class="line">    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断头结点是否就是我们需要的节点</span><br><span class="line">        if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;</span><br><span class="line">            if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            &#x2F;&#x2F; 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)</span><br><span class="line">            return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F; 遍历链表</span><br><span class="line">        while ((e &#x3D; e.next) !&#x3D; null) &#123;</span><br><span class="line">            if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java子类继承加载顺序</title>
      <link href="/java/basics/20190420/"/>
      <url>/java/basics/20190420/</url>
      
        <content type="html"><![CDATA[<h3 id="java子类继承加载顺序"><a href="#java子类继承加载顺序" class="headerlink" title="java子类继承加载顺序"></a>java子类继承加载顺序</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类的加载中包括：</p><ul><li>静态代码块</li><li>代码块</li><li>构造</li><li>析构（c++中）</li></ul><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">public class FatherTest &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    FatherTest()&#123;</span><br><span class="line">       System.out.println(&quot;--父类的无参构造函数--&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FatherTest(String name)&#123;</span><br><span class="line">       this.name&#x3D;name;</span><br><span class="line">       System.out.println(&quot;--父类的有参构造函数--&quot;+this.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">       System.out.println(&quot;--父类的静态代码块--&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       System.out.println(&quot;--父类的非静态代码块--&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void speak()&#123;</span><br><span class="line">       System.out.println(&quot;--父类的方法--&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SonTest extends FatherTest &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">       System.out.println(&quot;--子类的静态代码块--&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">       System.out.println(&quot;--子类的非静态代码块--&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SonTest()&#123;</span><br><span class="line">       System.out.println(&quot;--子类的无参构造函数--&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SonTest(String name)&#123;</span><br><span class="line">       this.name&#x3D;name;</span><br><span class="line">       System.out.println(&quot;--子类的有参构造函数--&quot;+this.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void speak()&#123;</span><br><span class="line">       System.out.println(&quot;--子类Override了父类的方法--&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       FatherTest father&#x3D;new FatherTest(&quot;父亲的名字&quot;);</span><br><span class="line">       father.speak();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 输出：</span><br><span class="line"> * --父类的静态代码块--</span><br><span class="line"> * --父类的非静态代码块--</span><br><span class="line"> * --父类的有参构造函数--父亲的名字</span><br><span class="line"> * --父类的方法--</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       SonTest son&#x3D;new SonTest(&quot;儿子的名字&quot;);</span><br><span class="line">       son.speak();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 输出：</span><br><span class="line"> * --父类的静态代码块--</span><br><span class="line"> * --子类的静态代码块--</span><br><span class="line"> * --父类的非静态代码块--</span><br><span class="line"> * --父类的无参构造函数--</span><br><span class="line"> * --子类的非静态代码块--</span><br><span class="line"> * --子类的有参构造函数--儿子的名字</span><br><span class="line"> * --子类Override了父类的方法--</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       FatherTest father&#x3D;new FatherTest(&quot;父亲的名字&quot;);</span><br><span class="line">       father.speak();</span><br><span class="line">       SonTest son&#x3D;new SonTest(&quot;儿子的名字&quot;);</span><br><span class="line">       son.speak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * --父类的静态代码块--</span><br><span class="line"> * --子类的静态代码块--</span><br><span class="line"> * --父类的非静态代码块--</span><br><span class="line"> * --父类的无参构造函数--</span><br><span class="line"> * --子类的非静态代码块--</span><br><span class="line"> * --子类的有参构造函数--儿子的名字</span><br><span class="line"> * --子类Override了父类的方法--</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java总结</title>
      <link href="/java/basics/20190419/"/>
      <url>/java/basics/20190419/</url>
      
        <content type="html"><![CDATA[<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#">Post not found: 20190415_2</a></p><a id="more"></a><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#">Post not found: 20190418_1</a></p><ul><li>二分法查找</li><li>Arrays（工具类   sort（二分法排序））</li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><h4 id="自定义创建的对象"><a href="#自定义创建的对象" class="headerlink" title="自定义创建的对象"></a>自定义创建的对象</h4><h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><h5 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h5><ul><li>静态代码块（类相同的代码）</li><li>构造代码块（对象相同的代码）</li><li>局部代码块（）</li></ul><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法名相同，形参列表不同。</p><h5 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子类继承覆盖。</p><h5 id="继承（加载顺序）"><a href="#继承（加载顺序）" class="headerlink" title="继承（加载顺序）"></a>继承（加载顺序）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#">Post not found: 20190415_1</a></p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map不是集合 Collection的接口下的都是集合，map不是子类</p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有序能重复</p><h6 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h6><h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无序不能重复</p><h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h6><h6 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h6><p>比较器接口</p><h4 id="图-Map"><a href="#图-Map" class="headerlink" title="图 Map"></a>图 Map</h4><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口和抽象类</p><h4 id="基本类型对应的引用类型"><a href="#基本类型对应的引用类型" class="headerlink" title="基本类型对应的引用类型"></a>基本类型对应的引用类型</h4><p>1&gt; byte       ——    Byte<br>2&gt; short      ——   Short<br>3&gt; int          ——    Integer<br>4&gt; long       ——    Long<br>5&gt; char       ——    Character<br>6&gt; float       ——    Float<br>7&gt; double   ——    Double<br>8&gt; boolean ——    Boolean<br> 想搞清楚各种基本数据类型占用的字节数，首先要有一些基本知识，例：计算机最小的存储单位是 位(bit)，而一个字节等于8位即（1byte = 8bit)</p><h4 id="强引用-软引用-弱引用-虚引用"><a href="#强引用-软引用-弱引用-虚引用" class="headerlink" title="强引用,软引用,弱引用,虚引用"></a>强引用,软引用,弱引用,虚引用</h4><h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>public private（本包本类） protected（本包不本类 自类能用）<br>默认不属于权限修饰符 不能继承</p><h3 id="java中对象分类"><a href="#java中对象分类" class="headerlink" title="java中对象分类"></a>java中对象分类</h3><p>a.runnable class（）主类（运行类）含有main方法，可以直接执行<br>b.java bean（） （不含有main方法，构造方法，set get 方法）<br>c.POJO对象（简单的java对象，只含有set get方法）</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>a.封装（维护性）：隐藏成员变量和方法，隐藏共能实现的具体细节<br>b.继承（可扩展性）：子类继承父类的变量或者方法，也可以定义自己的<br>c.多态（灵活性）：父类的引用指向子类的实力（上转型对象）</p><h3 id="java中的两大机制：（跨平台）"><a href="#java中的两大机制：（跨平台）" class="headerlink" title="java中的两大机制：（跨平台）"></a>java中的两大机制：（跨平台）</h3><p>a.JVM java虚拟机<br>b.GC 垃圾回收</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>程序中出现的不正常的情况（会阻止程序的继续运行）（子类不能抛出比父类更多的异常，可以抛出父类的子异常）<br>1.编译异常（概率发生高的定义为编译异常）Exception直接子类<br>2.运行异常（概率发生低的定义为运行异常）继承RuntimeException</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>1.for<br>2.foreach<br>3.do while<br>4.while<br>5.递归<br>    1.构造方法不能递归、<br>    2.必须有出口，if判断，否则死循环（肯定内存溢出）<br>    3.次数不易过多，否则会出现内存溢出<br>    递归解决问题的思想：（大-&gt;小）<br>    将大问题拆成小问题<br>6.if go(java中go无用，字段保留)</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程与进程<br>start（）方法和run（）方法的区别？<br>    run方法只是一个普通的方法（还是单线程）<br>    start方法启动多线程，其次自动调用run方法<br>Thread，Runnable，callable<br>使用ExecutorService、Callable、Future实现有返回结果的线程</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>23种<br>3类：<br>a.创建型<br>b.模板型<br>c.功能型<br>单例，工厂，装饰，代理等。</p><h3 id="对象的序列化和反序列化"><a href="#对象的序列化和反序列化" class="headerlink" title="对象的序列化和反序列化"></a>对象的序列化和反序列化</h3><p>a.序列化：将对象以二进制的形式存储到硬盘中<br>b.反序列化：将以二进制形式的对象读取到内存中<br>要求：被序列化的对象必须要实现Serializable（标记接口）接口<br>不被序列化的字段处理，SerializableID问题</p><h3 id="XML格式，json格式"><a href="#XML格式，json格式" class="headerlink" title="XML格式，json格式"></a>XML格式，json格式</h3><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><p>读取，格式化等<br>DOM<br>SAX<br>JDOM<br>DOM4J</p><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p>读取，格式化等<br>jsonobject<br>gson<br>fastjson<br>等</p><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>在日本东京大学申请ip地址<br>UDP 不用连接<br>TCP 三次握手<br>一个好的通讯软件（io流技术，多线程，udp tcp技术）</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>1.transient（在对象序列化的时候，如果某个属性不想被序列化就是该关键字修饰）<br>2.abstract：<br>a.修饰类（被他修饰的类为抽象类）<br>b.修饰方法（权限：public protected，抽象方法不能有方法体）<br>3.final：<br>a.修饰类：不能有子类<br>b.修饰方法：不能被重写 （不能修饰抽象方法）<br>c.修饰变量：常量（要赋初始值）<br>4.implements：实现接口<br>5.static：<br>a.修饰类：（内部类）<br>b.静态变量是属于类的，对象共享<br>c.修饰方法：静态方法只能调用的静态的东西<br>6.instanceof：<br>eg：a instanceof A：判断对象a是不是类A及其子类创建的实力<br>final finally，顺道finalize()</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>1、泛型类<br>2、泛型接口<br>3、泛型方法<br>4、泛型引用</p><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>IO(BIO) 同步堵塞<br>NIO 同步非堵塞<br>AIO 异步（非）堵塞</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>==和equals</title>
      <link href="/java/basics/20190418/"/>
      <url>/java/basics/20190418/</url>
      
        <content type="html"><![CDATA[<h3 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;== 操作比较的是两个变量的值是否相等，对于引用型变量表示的是两个变量在堆中存储的地址是否相同，即栈中的内容是否相同。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==一般用在基本数据类型中，equals()一般比较字符串是否相等</p><a id="more"></a><h3 id="object中的equals"><a href="#object中的equals" class="headerlink" title="object中的equals"></a>object中的equals</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object中的equals是比较地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string中的equals"><a href="#string中的equals" class="headerlink" title="string中的equals"></a>string中的equals</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string中的equals是比较数值，先比较是否指向同一地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString &#x3D; (String)anObject;</span><br><span class="line">        int n &#x3D; value.length;</span><br><span class="line">        if (n &#x3D;&#x3D; anotherString.value.length) &#123;</span><br><span class="line">            char v1[] &#x3D; value;</span><br><span class="line">            char v2[] &#x3D; anotherString.value;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            while (n-- !&#x3D; 0) &#123;</span><br><span class="line">                if (v1[i] !&#x3D; v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写equals"><a href="#重写equals" class="headerlink" title="重写equals"></a>重写equals</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;项目中重写equals，必须重写hashcode<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重写 hashcode() 方法有如下几个原则可以遵循：</p><ul><li>如果重写了 equals() 方法，且 equals() 方法判断相等则 hashCode() 方法也要保证必须相等。</li><li>重写 hashCode() 方法算法也不能太过简单，否则哈希冲突过多。</li><li>重写 hashCode() 方法算法也不能太过复杂，否则计算复杂度过高而影响性能。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;《Effective Java》书中给出的一种算法，基于 17 和 31 散列码思想的实现，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode()&#123;</span><br><span class="line">    int result &#x3D; 17;</span><br><span class="line">    result &#x3D; 31*result + xxxx.hashCode();</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java SE 1.7简称java 1.7 对应JDK7，从1.7开始提供了java.util.Objects来重写equals 和 hashCode 方法，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int hashCode()&#123;</span><br><span class="line">    return Objects.hash(xxxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList删除节点（坑）</title>
      <link href="/java/basics/20190417/"/>
      <url>/java/basics/20190417/</url>
      
        <content type="html"><![CDATA[<h3 id="ArrayList删除节点"><a href="#ArrayList删除节点" class="headerlink" title="ArrayList删除节点"></a>ArrayList删除节点</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ArrayList的remove方法，进行删除的时候，数组的长度不变，但被删除的节点之后的数据会前移，看源码可知。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public E remove(int index) &#123;</span><br><span class="line">      &#x2F;&#x2F; 先检查下标索引是是否越界</span><br><span class="line">      rangeCheck(index);</span><br><span class="line">      &#x2F;&#x2F; ArrayList的修改次数加1</span><br><span class="line">      modCount++;</span><br><span class="line">      &#x2F;&#x2F; 获取索引对应的元素值</span><br><span class="line">      E oldValue &#x3D; elementData(index);</span><br><span class="line">      &#x2F;&#x2F; 获取删除元素后，需要移动的元素的个数</span><br><span class="line">      int numMoved &#x3D; size - index - 1;</span><br><span class="line">      if (numMoved &gt; 0)</span><br><span class="line">          &#x2F;&#x2F; 将元素进行移动拷贝</span><br><span class="line">          System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">      &#x2F;&#x2F; 最后将多出的位置设置为空，这样说明是没有引用的对象了</span><br><span class="line">      elementData[--size] &#x3D; null; &#x2F;&#x2F; Let gc do its work</span><br><span class="line">      &#x2F;&#x2F; 返回删除的旧值</span><br><span class="line">      return oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public boolean remove(Object o) &#123;</span><br><span class="line">        if (o &#x3D;&#x3D; null) &#123;</span><br><span class="line">            for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">                if (elementData[index] &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            for (int index &#x3D; 0; index &lt; size; index++)</span><br><span class="line">                if (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void fastRemove(int index) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        int numMoved &#x3D; size - index - 1;</span><br><span class="line">        if (numMoved &gt; 0)</span><br><span class="line">            System.arraycopy(elementData, index+1, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] &#x3D; null; &#x2F;&#x2F; clear to let GC do its work</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果这样操作就会有问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;String&gt;();</span><br><span class="line">list.add(&quot;java&quot;);</span><br><span class="line">list.add(&quot;android&quot;);</span><br><span class="line">list.add(&quot;android&quot;);</span><br><span class="line">list.add(&quot;c&quot;);</span><br><span class="line">list.add(&quot;c++&quot;);</span><br><span class="line">list.add(&quot;c&quot;);</span><br><span class="line"></span><br><span class="line">public void remove1(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">    for (inti&#x3D;0; i&lt;list.size(); i++) &#123;</span><br><span class="line">        String s &#x3D; list.get(i);</span><br><span class="line">        if (s.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void remove2(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">    for (Strings: list) &#123;</span><br><span class="line">        if (s.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove1 方法执行后第二个 “android” 字符串没有被删掉。看源码可知最终删除会执行 System.arraycopy 方法而导致删除元素时涉及到数组元素的移动，所以在遍历第一个字符串 “android” 时因为符合删除条件，所以将该元素从数组中删除，并且将后一个元素移动（也就是第二个字符串 “android”）至当前位置，导致下一次循环遍历时后一个字符串 “android” 并没有被遍历到，所以无法删除，同时由于每删除一次 size 也减一，所以其实每次都会向前移位，也会导致越来越多的元素无法被遍历获取。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remove2 方法运行会报 for-each 著名的并发修改异常 java.util.ConcurrentModificationException，因为迭代器内部会维护一些索引位置数据，要求在迭代过程中容器不能发生结构性变化（添加、插入、删除，修改数据不算），否则这些索引位置数据就失效了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么如何正确的删除节点。该造上面两个方法即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;从尾部循环</span><br><span class="line">public void remove1(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">    for(int i&#x3D;list.size()-1; i&gt;&#x3D;0; i--) &#123;</span><br><span class="line">        String s &#x3D; list.get(i);</span><br><span class="line">        if (s.equals(&quot;android&quot;)) &#123;</span><br><span class="line">            list.remove(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;利用迭代器</span><br><span class="line">public static void remove2(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">    Iterator&lt;String&gt; iterator &#x3D; list.iterator();</span><br><span class="line">    while(iterator.hasNext())&#123;</span><br><span class="line">        if (iterator.next().equals(&quot;android&quot;)) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Iterator-和-ListIterator-的区别"><a href="#Iterator-和-ListIterator-的区别" class="headerlink" title="Iterator 和 ListIterator 的区别"></a>Iterator 和 ListIterator 的区别</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;区别主要如下：</p><ul><li>ListIterator 有 add() 方法，可以向 List 中添加对象，而 Iterator 不能。</li><li>ListIterator 和 Iterator 都有 hasNext() 和 next() 方法，可以实现顺序向后遍历，但是 ListIterator 有 hasPrevious() 和 previous() 方法，可以实现逆向（顺序向前）遍历，Iterator 就不可以。</li><li>ListIterator 可以定位当前的索引位置，通过 nextIndex() 和 previousIndex() 可以实现，Iterator 没有此功能。</li><li>都可实现删除对象，但是 ListIterator 可以实现对象的修改，通过 set() 方法可以实现，Iterator 仅能遍历，不能修改。</li><li>ListIterator 是 Iterator 的子接口。<blockquote><p>注意：容器类提供的迭代器都会在迭代中间进行结构性变化检测，如果容器发生了结构性变化，就会抛出 ConcurrentModificationException，所以不能在迭代中间直接调用容器类提供的 add、remove 方法，如需添加和删除，应调用迭代器的相关方法。</p></blockquote></li></ul><h3 id="为什么使用-for-each-时调用-List-的-remove-方法元素会抛出-ConcurrentModificationException-异常"><a href="#为什么使用-for-each-时调用-List-的-remove-方法元素会抛出-ConcurrentModificationException-异常" class="headerlink" title="为什么使用 for-each 时调用 List 的 remove 方法元素会抛出 ConcurrentModificationException 异常"></a>为什么使用 for-each 时调用 List 的 remove 方法元素会抛出 ConcurrentModificationException 异常</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先Java 提供了一个 Iterable 接口返回一个迭代器，常用的 Collection<E>、List<E>、Set<E> 等都实现了这个接口，该接口的 iterator() 方法返回一个标准的 Iterator 实现，实现 Iterable 接口允许对象成为 for-each 语句的目标来遍历底层集合序列，因此使用 for-each 方式遍历列表在编译后实质是迭代器的形式实现。之所以会出现 ConcurrentModificationException 异常我们需要去看下最常见的 ArrayList 中 iterator() 方法的实现（别的集合 iterator 类似），如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">    protected int limit &#x3D; ArrayList.this.size;  &#x2F;&#x2F;集合列表的个数尺寸</span><br><span class="line">    int cursor;       &#x2F;&#x2F;下一个元素的索引位置</span><br><span class="line">    int lastRet &#x3D; -1; &#x2F;&#x2F;上一个元素的索引位置</span><br><span class="line">    int expectedModCount &#x3D; modCount;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return cursor &lt; limit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public E next() &#123;</span><br><span class="line">        &#x2F;&#x2F;modCount用于记录ArrayList集合的修改次数，初始化为0，</span><br><span class="line">        &#x2F;&#x2F;每当集合被修改一次（结构上面的修改，内部update不算），</span><br><span class="line">        &#x2F;&#x2F;如add、remove等方法，modCount + 1，所以如果modCount不变，</span><br><span class="line">        &#x2F;&#x2F;则表示集合内容没有被修改。</span><br><span class="line">        if (modCount !&#x3D; expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        int i &#x3D; cursor;</span><br><span class="line">        &#x2F;&#x2F;如果下一个元素的索引位置超过了集合长度抛出异常</span><br><span class="line">        if (i &gt;&#x3D; limit)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData &#x3D; ArrayList.this.elementData;</span><br><span class="line">        if (i &gt;&#x3D; elementData.length)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#x2F;&#x2F;调用一次cursor加一次</span><br><span class="line">        cursor &#x3D; i + 1;</span><br><span class="line">        &#x2F;&#x2F;返回当前一个元素</span><br><span class="line">        return (E) elementData[lastRet &#x3D; i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void remove() &#123;</span><br><span class="line">        &#x2F;&#x2F;lastRet每次在remove成功后都需要在next()中重新赋值，</span><br><span class="line">        &#x2F;&#x2F;否则调用一次后再调用为-1异常，因此使用迭代器的remove方法</span><br><span class="line">        &#x2F;&#x2F;前必须先调用next()方法。</span><br><span class="line">        if (lastRet &lt; 0)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        if (modCount !&#x3D; expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList.this.remove(lastRet);</span><br><span class="line">            cursor &#x3D; lastRet;</span><br><span class="line">            lastRet &#x3D; -1;</span><br><span class="line">            expectedModCount &#x3D; modCount;</span><br><span class="line">            limit--;</span><br><span class="line">        &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面的源码发现迭代操作中都有判断 modCount!=expectedModCount 的操作，在 ArrayList 中 modCount 是当前集合的版本号，每次修改（增、删）集合都会加 1，expectedModCount 是当前迭代器的版本号，在迭代器实例化时初始化为 modCount，所以当调用 ArrayList.add() 或 ArrayList.remove() 时只是更新了 modCount 的状态，而迭代器中的 expectedModCount 未修改，因此才会导致再次调用 Iterator.next() 方法时抛出 ConcurrentModificationException 异常。而使用 Iterator.remove() 方法没有问题是因为 Iterator 的 remove() 方法中有同步 expectedModCount 值，所以当下次再调用 next() 时检查不会抛出异常。这其实是一种快速失败机制，机制的规则就是当多个线程对 Collection 进行操作时若其中某一个线程通过 Iterator 遍历集合时该集合的内容被其他线程所改变，则抛出 ConcurrentModificationException 异常。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此在使用 Iterator 遍历操作集合时应该保证在遍历集合的过程中不会对集合产生结构上的修改，如果在遍历过程中需要修改集合元素则一定要使用迭代器提供的修改方法而不是集合自身的修改方法，此外 for-each 循环遍历的实质是迭代器，使用迭代器的 remove() 方法前必须先调用迭代器的 next() 方法且不允许调用一次 next() 方法后调用多次 remove() 方法。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java调用js方法</title>
      <link href="/java/basics/20190416/"/>
      <url>/java/basics/20190416/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdk1.6开始就提供了动态脚本语言诸如JavaScript动态的支持。这无疑是一个很好的功能，毕竟Java的语法不是适合成为动态语言。而JDK通过执行JavaScript脚本可以弥补这一不足。这也符合“Java虚拟机不仅仅是Java一种语言的虚拟机“这一目标。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ScriptEngine功能强大，基本能实现笔者所能想到的Java与JavaScript交互的需求。而且十分的方便简洁。jdk1.8又对ScriptEngine接口进行了一定改变，因此，在jdk1.8能运行的代码，在1.6中可能会报错，反之亦然。<a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">public void test2()</span><br><span class="line">&#123;</span><br><span class="line">    ScriptEngineManager manager &#x3D; new ScriptEngineManager();</span><br><span class="line">    List&lt;ScriptEngineFactory&gt; factories &#x3D; manager.getEngineFactories();</span><br><span class="line">    for (ScriptEngineFactory factory: factories)&#123;</span><br><span class="line">    &#x2F;&#x2F; 打印脚本信息</span><br><span class="line">        System.out.println(factory.getEngineName());</span><br><span class="line">        System.out.println(factory.getEngineVersion());</span><br><span class="line">        System.out.println(factory.getLanguageName());</span><br><span class="line">        System.out.println(factory.getLanguageVersion());</span><br><span class="line">        System.out.println(factory.getExtensions());</span><br><span class="line">        System.out.println(factory.getMimeTypes());</span><br><span class="line">        System.out.println(factory.getNames());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;输出</span><br><span class="line">Oracle Nashorn</span><br><span class="line">1.8.0_77</span><br><span class="line">ECMAScript</span><br><span class="line">ECMA - 262 Edition 5.1</span><br><span class="line">[js]</span><br><span class="line">[application&#x2F;javascript, application&#x2F;ecmascript, text&#x2F;javascript, text&#x2F;ecmascript]</span><br><span class="line">[nashorn, Nashorn, js, JS, JavaScript, javascript, ECMAScript, ecmascript]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 加载脚本引擎，并在java中调用js方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void test2()</span><br><span class="line">&#123;</span><br><span class="line">     ScriptEngineManager manager &#x3D; new ScriptEngineManager();</span><br><span class="line">     ScriptEngine engine &#x3D; manager.getEngineByName(&quot;javascript&quot;);</span><br><span class="line">     try &#123;</span><br><span class="line">         String str&#x3D;&quot;1+2*(3+4)&quot;;</span><br><span class="line">         System.out.println(engine.eval(str));</span><br><span class="line">     &#125; catch (ScriptException ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 在java中调用js，jdk1.6中有加载js引擎类，然后由它来调用js方法。</span><br><span class="line"> * 并通过JDK平台给script的方法中的形参赋值  </span><br><span class="line"> *&#x2F;</span><br><span class="line">public void test(String name)</span><br><span class="line">&#123;</span><br><span class="line">    ScriptEngineManager sem &#x3D; new ScriptEngineManager(); </span><br><span class="line">    &#x2F;*sem.getEngineByExtension(String extension)参数为js   </span><br><span class="line">      sem.getEngineByMimeType(String mimeType) 参数为application&#x2F;javascript 或者text&#x2F;javascript   </span><br><span class="line">      sem.getEngineByName(String shortName)参数为js或javascript或JavaScript </span><br><span class="line">     *&#x2F;</span><br><span class="line">    ScriptEngine se &#x3D; sem.getEngineByName(&quot;js&quot;); </span><br><span class="line">    try</span><br><span class="line">    &#123; </span><br><span class="line">      String script &#x3D; &quot;function say()&#123; return &#39;hello,&#39;&quot;+name+&quot;; &#125;&quot;;</span><br><span class="line">      se.eval(script); </span><br><span class="line">      Invocable inv2 &#x3D; (Invocable) se; </span><br><span class="line">      String res&#x3D;(String)inv2.invokeFunction(&quot;say&quot;,name); </span><br><span class="line">      System.out.println(res);</span><br><span class="line">    &#125; </span><br><span class="line">    catch(Exception e) </span><br><span class="line">    &#123; </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 演示如何将java中对象作为js中全局变量，同时演示将file类赋给脚本语言，并获得其属性。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void testScriptVariables()</span><br><span class="line">&#123;</span><br><span class="line">    ScriptEngineManager sem&#x3D;new ScriptEngineManager();</span><br><span class="line">    ScriptEngine engine&#x3D;sem.getEngineByName(&quot;js&quot;);</span><br><span class="line">    File file&#x3D;new File(&quot;c:\\1.txt&quot;);</span><br><span class="line">    engine.put(&quot;f&quot;, file);</span><br><span class="line">    try &#123;</span><br><span class="line">        engine.eval(&quot;println(&#39;path:&#39;+f.getPath())&quot;);&#x2F;&#x2F;无法使用alert方法</span><br><span class="line">    &#125; catch (ScriptException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * 演示如何在java中如何通过线程来启动一个js方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void testScriptInterface() throws ScriptException</span><br><span class="line">&#123;</span><br><span class="line">    ScriptEngineManager sem&#x3D;new ScriptEngineManager();</span><br><span class="line">    ScriptEngine engine&#x3D;sem.getEngineByName(&quot;js&quot;);</span><br><span class="line">    String script&#x3D;&quot;var obj&#x3D;new Object();obj.run&#x3D;function()&#123;println(&#39;test thread&#39;)&#125;&quot;;</span><br><span class="line">    engine.eval(script);</span><br><span class="line">    Object obj&#x3D;engine.get(&quot;obj&quot;);&#x2F;&#x2F;获取js中对象</span><br><span class="line">    Invocable inv&#x3D;(Invocable)engine;</span><br><span class="line">    Runnable r&#x3D;inv.getInterface(obj,Runnable.class);</span><br><span class="line">    Thread t&#x3D;new Thread(r);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java类中缓存机制类</title>
      <link href="/java/basics/20190415/"/>
      <url>/java/basics/20190415/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="具有缓存机制的类"><a href="#具有缓存机制的类" class="headerlink" title="具有缓存机制的类"></a>具有缓存机制的类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Byte、Short、Integer、Long、Character都具有缓存机制。缓存工作都是在静态块中完成，在类生命周期（loading verify prepare resolving initial using unload）的初始化阶段执行。</p><a id="more"></a><h3 id="缓存范围"><a href="#缓存范围" class="headerlink" title="缓存范围"></a>缓存范围</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Byte，Short，Integer，Long为 -128 到 127，Character范围为 0 到 127</p><h3 id="是否可以改变缓存范围"><a href="#是否可以改变缓存范围" class="headerlink" title="是否可以改变缓存范围"></a>是否可以改变缓存范围</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了Integer可以指定缓存范围，其它类都不行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer的缓存上界high可以通过jvm参数-XX:AutoBoxCacheMax=size指定，取指定值与127的最大值并且不超过Integer表示范围，而下界low不能指定，只能为-128</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用activityMQ做处理，消息的顺序性和服务处理的时效性问题</title>
      <link href="/java/activitymq/20190422/"/>
      <url>/java/activitymq/20190422/</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分期缴费的时候，如果有抵扣，把抵扣已批单的形式从保费中扣除。那么就需要进行批单的处理。批单处理上需要一定时间。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么问题来了：</p><ol><li>如果短时间内多次进行分期缴费呢，也就意味着需要进行多次批减保费的操作。每次批减保费是基于上次批减操作进行的，批减需要时间去处理，没处理完，之后的批减/退或其他操作是没办法进行的。</li><li>还是同样的情况，如果有一次批减发生了错误，那么之后的操作如何处理。</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结为同单高并发，且需要按顺序处理</p><a id="more"></a><h3 id="解决顺序性的方案"><a href="#解决顺序性的方案" class="headerlink" title="解决顺序性的方案"></a>解决顺序性的方案</h3><h4 id="利用mq的JMSXGroupID"><a href="#利用mq的JMSXGroupID" class="headerlink" title="利用mq的JMSXGroupID"></a>利用mq的JMSXGroupID</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mq的JMSXGroupID字段，只要consumer保持active，那么同一组的消息会被分到同一consumer下处理。这样可以保证消息处理顺序的正确性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺点就是在某种情况下，mq队列会堆积，等待一个consumer处理，而其他consumer是空闲的。</p><h4 id="redis锁-mq重发"><a href="#redis锁-mq重发" class="headerlink" title="redis锁+mq重发"></a>redis锁+mq重发</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加redis锁，consumer消费后，自己重发mq。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺点就是耗费资源，而且重发是秒级。</p><h4 id="redis锁-redis队列存放消息"><a href="#redis锁-redis队列存放消息" class="headerlink" title="redis锁+redis队列存放消息"></a>redis锁+redis队列存放消息</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;难点在于，对消息的消费，其实第一种方案比较合理，在不知道第一种的情况下，自己实现顺序消费。将进来的消息放到redis的队列中，集合也行，加上redis锁，在释放锁之前获取redis队列里的数据，取出一条进行重新消费。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺点就是，在某种极端情况下，向redis中放数据在查询数据之后，那么，这条数据就在不会被处理。</p>]]></content>
      
      
      <categories>
          
          <category> 经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀方案（未写完）</title>
      <link href="/java/20200622/"/>
      <url>/java/20200622/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />redis lpush + lpop = stack 先进后出的栈lpush + rpop = queue 先进先出的队列lpush + ltrim = capped collection 有限集合lpush + brpop = message queue 消息队列<p>高并发(多用户同时请求，一个账号只能请求一次（账号上锁？）)-&gt;分布式锁(redis的setnx)-&gt;原子操作减库存</p>]]></content>
      
      
      <categories>
          
          <category> 有点东西 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树(未写完)</title>
      <link href="/dataStructure/20200525/"/>
      <url>/dataStructure/20200525/</url>
      
        <content type="html"><![CDATA[<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;红黑树（Red Black Tree） 是一种自平衡二叉查找树，一种特化的AVL树。都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;红黑树必须满足下面性质：</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。<a id="more"></a></li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/1.jpg"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先解读一下规则，除了字面上看到的意思，还隐藏了哪些意思呢?</p><ul><li>从根节点到叶子节点的最长路径不大于最短路径的 2 倍<ul><li>怎么样的路径算最短路径?从规则 5 中，我们知道从根节点到每个叶子节点的黑色节点数量是一样的，那么纯由黑色节点组成的路径就是最短路径。</li><li>什么样的路径算是最长路径?根据规则 4 和规则 3，若有红色节点，则必然有一个连接的黑色节点，当红色节点和黑色节点数量相同时，就是最长路*径，也就是黑色节点(或红色节点)*2。</li></ul></li><li>为什么说新加入到红黑树中的节点为红色节点<ul><li>从规则 4 中知道，当前红黑树中从根节点到每个叶子节点的黑色节点数量是一样的，此时假如新的是黑色节点的话，必然破坏规则。</li><li>但加入红色节点却不一定，除非其父节点就是红色节点，因此加入红色节点，破坏规则的可能性小一些，下面我们也会举例来说明。</li><li>什么情况下，红黑树的结构会被破坏呢?破坏后又怎么维持平衡，维持平衡主要通过两种方式【变色】和【旋转】，【旋转】又分【左旋】和【右旋】，两种方式可相互结合。</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们从插入和删除两种场景来举例说明。</p><h4 id="红黑树节点插入"><a href="#红黑树节点插入" class="headerlink" title="红黑树节点插入"></a>红黑树节点插入</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们插入值为 66 的节点时，红黑树变成了这样：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/2.jpg"><br>很明显，这个时候结构依然遵循着上述 6 大规则，无需启动自动平衡机制调整节点平衡状态。<br>如果再向里面插入值为 51 的节点，这个时候红黑树变成了这样：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/3.jpg"><br>很明显现在的结构不遵循规则 4 了，这个时候就需要启动自动平衡机制调整节点平衡状态。<br>变色<br>我们可以通过变色的方式，使结构满足红黑树的规则：</p><ul><li>首先解决结构不遵循规则 4 这一点(红色节点相连，节点 49-51)，需将节点 49 改为黑色。</li><li>此时我们发现又违反了规则 5(56-49-51-XX 路径中黑色节点超过了其他路径)，那么我们将节点 45 改为红色节点。</li><li>哈哈，妹的，又违反了规则 4(红色节点相连，节点 56-45-43)，那么我们将节点 56 和节点 43 改为黑色节点。</li><li>但是我们发现此时又违反了规则 5(60-56-XX 路径的黑色节点比 60-68-XX 的黑色节点多)，因此我们需要调整节点 68 为黑色。</li><li>完成!<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/4.jpg"><br>最终调整完成后的树为：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/5.jpg"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用数据结构</title>
      <link href="/dataStructure/20190502/"/>
      <url>/dataStructure/20190502/</url>
      
        <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先给出Java集合框架的基本接口/类层次结构：<a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java.util.Collection [I]</span><br><span class="line">    +--java.util.List [I]</span><br><span class="line">       +--java.util.ArrayList [C]    </span><br><span class="line">       +--java.util.LinkedList [C]  </span><br><span class="line">       +--java.util.Vector [C]    &#x2F;&#x2F;线程安全</span><br><span class="line">          +--java.util.Stack [C]  &#x2F;&#x2F;线程安全</span><br><span class="line">    +--java.util.Set [I]                   </span><br><span class="line">       +--java.util.HashSet [C]      </span><br><span class="line">       +--java.util.SortedSet [I]    </span><br><span class="line">          +--java.util.TreeSet [C]    </span><br><span class="line">    +--Java.util.Queue[I]</span><br><span class="line">        +--java.util.Deque[I]   </span><br><span class="line">        +--java.util.PriorityQueue[C]  </span><br><span class="line">java.util.Map [I]</span><br><span class="line">    +--java.util.SortedMap [I]</span><br><span class="line">       +--java.util.TreeMap [C]</span><br><span class="line">    +--java.util.Hashtable [C]   &#x2F;&#x2F;线程安全</span><br><span class="line">    +--java.util.HashMap [C]</span><br><span class="line">    +--java.util.LinkedHashMap [C]</span><br><span class="line">    +--java.util.WeakHashMap [C]</span><br><span class="line"></span><br><span class="line">[I]：接口</span><br><span class="line">[C]：类</span><br></pre></td></tr></table></figure><h3 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h3><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/qrYRX93.jpg"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组是相同数据类型的元素按一定顺序排列的集合，是一块连续的内存空间。数组的优点是：get和set操作时间上都是O(1)的；缺点是：add和remove操作时间上都是O(N)的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中，Array就是数组，此外，ArrayList使用了数组Array作为其实现基础,它和一般的Array相比，最大的好处是，我们在添加元素时不必考虑越界，元素超出数组容量时，它会自动扩张保证容量。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vector和ArrayList相比，主要差别就在于多了一个线程安全性，但是效率比较低下。如今java.util.concurrent包提供了许多线程安全的集合类（比如 LinkedBlockingQueue），所以不必再使用Vector了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[] ints &#x3D; new int[10];</span><br><span class="line">ints[0] &#x3D; 5;&#x2F;&#x2F;set</span><br><span class="line">int a &#x3D; ints[2];&#x2F;&#x2F;get</span><br><span class="line">int len &#x3D; ints.length;&#x2F;&#x2F;数组长度</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链表是一种非连续、非顺序的结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，链表由一系列结点组成。链表的优点是：add和remove操作时间上都是O(1)的；缺点是：get和set操作时间上都是O(N)的，而且需要额外的空间存储指向其他数据地址的项。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找操作对于未排序的数组和链表时间上都是O(N)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中，LinkedList 使用链表作为其基础实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; linkedList &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">linkedList.add(&quot;addd&quot;);&#x2F;&#x2F;add</span><br><span class="line">linkedList.set(0,&quot;s&quot;);&#x2F;&#x2F;set，必须先保证 linkedList中已经有第0个元素</span><br><span class="line">String s &#x3D;  linkedList.get(0);&#x2F;&#x2F;get</span><br><span class="line">linkedList.contains(&quot;s&quot;);&#x2F;&#x2F;查找</span><br><span class="line">linkedList.remove(&quot;s&quot;);&#x2F;&#x2F;删除</span><br></pre></td></tr></table></figure><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，亦即所谓的先进先出（FIFO）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中，LinkedList实现了Deque，可以做为双向队列（自然也可以用作单向队列）。另外PriorityQueue实现了带优先级的队列，亦即队列的每一个元素都有优先级，且元素按照优先级排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; integerDeque &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">&#x2F;&#x2F; 尾部入队，区别在于如果失败了</span><br><span class="line">&#x2F;&#x2F; add方法会抛出一个IllegalStateException异常，而offer方法返回false</span><br><span class="line">integerDeque.offer(122);</span><br><span class="line">integerDeque.add(122);</span><br><span class="line">&#x2F;&#x2F; 头部出队,区别在于如果失败了</span><br><span class="line">&#x2F;&#x2F; remove方法抛出一个NoSuchElementException异常，而poll方法返回false</span><br><span class="line">int head &#x3D; integerDeque.poll();&#x2F;&#x2F;返回第一个元素，并在队列中删除</span><br><span class="line">head &#x3D; integerDeque.remove();&#x2F;&#x2F;返回第一个元素，并在队列中删除</span><br><span class="line">&#x2F;&#x2F; 头部出队，区别在于如果失败了</span><br><span class="line">&#x2F;&#x2F; element方法抛出一个NoSuchElementException异常，而peek方法返回null。</span><br><span class="line">head &#x3D; integerDeque.peek();&#x2F;&#x2F;返回第一个元素，不删除</span><br><span class="line">head &#x3D; integerDeque.element();&#x2F;&#x2F;返回第一个元素，不删除</span><br></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。它体现了后进先出（LIFO）的特点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中，Stack实现了这种特性，但是Stack也继承了Vector，所以具有线程安全线和效率低下两个特性，最新的JDK8中，推荐用Deque来实现栈，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack &#x3D; new ArrayDeque&lt;Integer&gt;();</span><br><span class="line">stack.push(12);&#x2F;&#x2F;尾部入栈</span><br><span class="line">stack.push(16);&#x2F;&#x2F;尾部入栈</span><br><span class="line">int tail &#x3D; stack.pop();&#x2F;&#x2F;尾部出栈，并删除该元素</span><br><span class="line">tail &#x3D; stack.peek();&#x2F;&#x2F;尾部出栈，不删除该元素</span><br></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集合是指具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的元素，其主要特性是元素不可重复。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java中，HashSet 体现了这种数据结构，而HashSet是在MashMap的基础上构建的。LinkedHashSet继承了HashSet，使用HashCode确定在集合中的位置，使用链表的方式确定位置，所以有顺序。TreeSet实现了SortedSet 接口，是排好序的集合（在TreeMap 基础之上构建），因此查找操作比普通的Hashset要快（log(N)）；插入操作要慢（log（N））,因为要维护有序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; integerHashSet &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">integerHashSet.add(12121);&#x2F;&#x2F;添加</span><br><span class="line">integerHashSet.contains(121);&#x2F;&#x2F;是否包含</span><br><span class="line">integerHashSet.size();&#x2F;&#x2F;集合大小</span><br><span class="line">integerHashSet.isEmpty();&#x2F;&#x2F;是否为空</span><br></pre></td></tr></table></figure><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;散列表也叫哈希表，是根据关键键值(Keyvalue)进行访问的数据结构，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中HashMap实现了散列表，而Hashtable比它多了一个线程安全性，但是由于使用了全局锁导致其性能较低，所以现在一般用ConcurrentHashMap来实现线程安全的HashMap（类似的，以上的数据结构在最新的java.util.concurrent的包中几乎都有对应的高性能的线程安全的类）。TreeMap实现SortMap接口，能够把它保存的记录按照键排序。LinkedHashMap保留了元素插入的顺序。WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收，而不需要我们手动删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; integerHashSet &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">integerHashSet.add(12121);&#x2F;&#x2F;添加</span><br><span class="line">integerHashSet.contains(121);&#x2F;&#x2F;是否包含</span><br><span class="line">integerHashSet.size();&#x2F;&#x2F;集合大小</span><br><span class="line">integerHashSet.isEmpty();&#x2F;&#x2F;是否为空</span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树（tree）是包含n（n&gt;0）个节点的有穷集合，其中：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个元素称为节点（node）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一个特定的节点被称为根节点或树根（root）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除根节点之外的其余数据元素被分为m（m≥0）个互不相交的结合T1，T2，……Tm-1，其中每一个集合Ti（1&lt;=i&lt;=m）本身也是一棵树，被称作原树的子树（subtree）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树这种数据结构在计算机世界中有广泛的应用，比如操作系统中用到了红黑树，数据库用到了B+树，编译器中的语法树，内存管理用到了堆（本质上也是树），信息论中的哈夫曼编码等等等等，在Java中TreeSet和TreeMap用到了树来排序（二分查找提高检索速度），不过一般都需要程序员自己去定义一个树的类，并实现相关性质，而没有现成的API。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面用Java来实现各种常见的树:</p><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉树是一种基础而且重要的数据结构，其每个结点至多只有二棵子树，二叉树有左右子树之分，第i层至多有2^(i-1)个结点（i从1开始）；深度为k的二叉树至多有2^(k)-1)个结点，对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉树的性质：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在非空二叉树中，第i层的结点总数不超过2^(i-1), i&gt;=1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;深度为h的二叉树最多有2^h-1个结点(h&gt;=1)，最少有h个结点;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具有n个结点的完全二叉树的深度为log2(n+1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系： 若I为结点编号则 如果I&gt;1，则其父结点的编号为I/2； 如果2I&lt;=N，则其左儿子（即左子树的根结点）的编号为2I；若2I&gt;N，则无左儿子； 如果2I+1&lt;=N，则其右儿子的结点编号为2I+1；若2I+1&gt;N，则无右儿子。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1)。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i。</p><h4 id="满二叉树、完全二叉树"><a href="#满二叉树、完全二叉树" class="headerlink" title="满二叉树、完全二叉树"></a>满二叉树、完全二叉树</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;满二叉树是完全二叉树的一个特例。</p><h4 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉查找树，又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;左、右子树也分别为二叉排序树；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有键值相等的节点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。 二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡二叉树设计的初衷。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉查找树可以这样表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    private Node root;             &#x2F;&#x2F; 根节点</span><br><span class="line"> </span><br><span class="line">    private class Node &#123;</span><br><span class="line">        private Key key;           &#x2F;&#x2F; 排序的间</span><br><span class="line">        private Value val;         &#x2F;&#x2F; 相应的值</span><br><span class="line">        private Node left, right;  &#x2F;&#x2F; 左子树，右子树</span><br><span class="line">        private int size;          &#x2F;&#x2F; 以该节点为根的树包含节点数量</span><br><span class="line"> </span><br><span class="line">        public Node(Key key, Value val, int size) &#123;</span><br><span class="line">            this.key &#x3D; key;</span><br><span class="line">            this.val &#x3D; val;</span><br><span class="line">            this.size &#x3D; size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public BST() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    public int size() &#123;&#x2F;&#x2F;获得该二叉树节点数量</span><br><span class="line">        return size(root);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private int size(Node x) &#123;获得以该节点为根的树包含节点数量</span><br><span class="line">        if (x &#x3D;&#x3D; null) return 0;</span><br><span class="line">        else return x.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Value get(Key key) &#123;</span><br><span class="line">    return get(root, key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private Value get(Node x, Key key) &#123;&#x2F;&#x2F;在以x节点为根的树中查找key</span><br><span class="line">    if (x &#x3D;&#x3D; null) return null;</span><br><span class="line">    int cmp &#x3D; key.compareTo(x.key);</span><br><span class="line">    if(cmp &lt; 0) </span><br><span class="line">        return get(x.left, key);&#x2F;&#x2F;递归左子树查找</span><br><span class="line">    else if (cmp &gt; 0) </span><br><span class="line">        return get(x.right, key);&#x2F;&#x2F;递归右子树查找</span><br><span class="line">    else              </span><br><span class="line">        return x.val;&#x2F;&#x2F;找到了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void put(Key key, Value val) &#123;</span><br><span class="line">    root &#x3D; put(root, key, val);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private Node put(Node x, Key key, Value val) &#123;在以x节点为根的树中查找key，val</span><br><span class="line">    if (x &#x3D;&#x3D; null) </span><br><span class="line">        return new Node(key, val, 1);</span><br><span class="line">    int cmp &#x3D; key.compareTo(x.key);</span><br><span class="line">    if(cmp &lt; 0) </span><br><span class="line">        x.left  &#x3D; put(x.left,  key, val);&#x2F;&#x2F;递归左子树插入</span><br><span class="line">    else if (cmp &gt; 0) </span><br><span class="line">        x.right &#x3D; put(x.right, key, val);&#x2F;&#x2F;递归右子树插入</span><br><span class="line">    else              </span><br><span class="line">        x.val   &#x3D; val;</span><br><span class="line">    x.size &#x3D; 1 + size(x.left) + size(x.right);</span><br><span class="line">    return x;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public Key min() &#123;</span><br><span class="line">    return min(root).key;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">private Node min(Node x) &#123; </span><br><span class="line">    if (x.left &#x3D;&#x3D; null) </span><br><span class="line">        return x; </span><br><span class="line">    else                </span><br><span class="line">        return min(x.left); </span><br><span class="line"> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public void deleteMin() &#123;</span><br><span class="line">    root &#x3D; deleteMin(root);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private Node deleteMin(Node x) &#123;&#x2F;&#x2F;删除以x为根节点的子树最小值</span><br><span class="line">    if (x.left &#x3D;&#x3D; null) </span><br><span class="line">        return x.right;</span><br><span class="line">    x.left &#x3D; deleteMin(x.left);</span><br><span class="line">    x.size &#x3D; size(x.left) + size(x.right) + 1;</span><br><span class="line">    return x;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void delete(Key key) &#123;</span><br><span class="line">     root &#x3D; delete(root, key);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private Node delete(Node x, Key key) &#123;</span><br><span class="line">    if (x &#x3D;&#x3D; null) </span><br><span class="line">        return null;</span><br><span class="line"> </span><br><span class="line">    int cmp &#x3D; key.compareTo(x.key);</span><br><span class="line">    if(cmp &lt; 0) </span><br><span class="line">        x.left  &#x3D; delete(x.left,  key);&#x2F;&#x2F;递归删除左子树</span><br><span class="line">    else if (cmp &gt; 0) </span><br><span class="line">        x.right &#x3D; delete(x.right, key);&#x2F;&#x2F;递归删除右子树</span><br><span class="line">    else &#123; &#x2F;&#x2F;该节点就是所要删除的节点</span><br><span class="line">        if (x.right &#x3D;&#x3D; null) </span><br><span class="line">            return x.left;&#x2F;&#x2F;没有右子树，把左子树挂在原节点父节点上</span><br><span class="line">        if (x.left  &#x3D;&#x3D; null) </span><br><span class="line">            return x.right;&#x2F;&#x2F;没有左子树，，把右子树挂在原节点父节点上</span><br><span class="line">        Node t &#x3D; x;&#x2F;&#x2F;用右子树中最小的节点来替代被删除的节点，仍然保证树的有序性</span><br><span class="line">        x &#x3D; min(t.right);</span><br><span class="line">        x.right &#x3D; deleteMin(t.right);</span><br><span class="line">        x.left &#x3D; t.left;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    x.size &#x3D; size(x.left) + size(x.right) + 1;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;平衡二叉树又被称为AVL树，具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。它的出现就是解决二叉查找树不平衡导致查找效率退化为线性的问题，因为在删除和插入之时会维护树的平衡，使得查找时间保持在O(logn)，比二叉查找树更稳定。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ALLTree 的 Node 由 BST 的 Node 加上 private int height; 节点高度属性即可，这是为了便于判断树是否平衡。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;维护树的平衡关键就在于旋转。对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2，容易看出，这种不平衡出现在下面四种情况：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单旋转是针对于左左和右右这两种情况，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为使树恢复平衡，我们把k1变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private int height(Node t)&#123;  </span><br><span class="line">    return t &#x3D;&#x3D; null ? -1 : t.height;  </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;左左情况单旋转  </span><br><span class="line">private Node rotateWithLeftChild(Node k2)&#123;  </span><br><span class="line">    Node k1 &#x3D; k2.left;  </span><br><span class="line">    k2.left &#x3D; k1.right;       </span><br><span class="line">    k1.right &#x3D; k2;        </span><br><span class="line">    k1.size &#x3D; k2.size;</span><br><span class="line">    k2.size &#x3D; size(k2.right)+size(k2.left)+1;</span><br><span class="line">    k2.height &#x3D; Math.max(height(k2.left), height(k2.right)) + 1;  </span><br><span class="line">    k1.height &#x3D; Math.max(height(k1.left), k2.height) + 1;         </span><br><span class="line">    return k1;      &#x2F;&#x2F;返回新的根  </span><br><span class="line">&#125;     </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;右右情况单旋转  </span><br><span class="line">private Node rotateWithRightChild(Node k2)&#123;  </span><br><span class="line">    Node k1 &#x3D; k2.right;  </span><br><span class="line">    k2.right &#x3D; k1.left;  </span><br><span class="line">    k1.left &#x3D; k2;  </span><br><span class="line">    k1.size &#x3D; k2.size;</span><br><span class="line">    k2.size &#x3D; size(k2.right)+size(k2.left)+1;       </span><br><span class="line">    k2.height &#x3D; Math.max(height(k2.left), height(k2.right)) + 1;  </span><br><span class="line">    k1.height &#x3D; Math.max(height(k1.right), k2.height) + 1;        </span><br><span class="line">    return k1;      &#x2F;&#x2F;返回新的根   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双旋转是针对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树树。 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;左右情况  </span><br><span class="line">private Node doubleWithLeftChild(Node k3)&#123;        </span><br><span class="line">    try&#123;  </span><br><span class="line">        k3.left &#x3D; rotateWithRightChild(k3.left);  </span><br><span class="line">    &#125;catch(NullPointerException e)&#123;  </span><br><span class="line">        System.out.println(&quot;k.left.right为：&quot;+k3.left.right);  </span><br><span class="line">        throw e;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return rotateWithLeftChild(k3);       </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;右左情况  </span><br><span class="line">private Node doubleWithRightChild(Node k3)&#123;  </span><br><span class="line">    try&#123;  </span><br><span class="line">        k3.right &#x3D; rotateWithLeftChild(k3.right);  </span><br><span class="line">    &#125;catch(NullPointerException e)&#123;  </span><br><span class="line">        System.out.println(&quot;k.right.left为：&quot;+k3.right.left);  </span><br><span class="line">        throw e;  </span><br><span class="line">    &#125;         </span><br><span class="line">    return rotateWithRightChild(k3);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AVL查找操作与BST相同，AVL的删除与插入操作在BST基础之上需要检查是否平衡，如果不平衡就要使用旋转操作来维持平衡：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private Node balance(Node x) &#123;</span><br><span class="line">    if (balanceFactor(x) &lt; -1) &#123;&#x2F;&#x2F;右边高</span><br><span class="line">        if (balanceFactor(x.right) &gt; 0) &#123;&#x2F;&#x2F;右左</span><br><span class="line">            x.right &#x3D; rotateWithLeftChild(x.right);</span><br><span class="line">        &#125;</span><br><span class="line">        x &#x3D; rotateWithRightChild(x);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (balanceFactor(x) &gt; 1) &#123;&#x2F;&#x2F;左边高</span><br><span class="line">        if (balanceFactor(x.left) &lt; 0) &#123;&#x2F;&#x2F;左右</span><br><span class="line">            x.left &#x3D; rotateWithRightChild(x.left);</span><br><span class="line">        &#125;</span><br><span class="line">        x &#x3D; rotateWithLeftChild(x);</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private int balanceFactor(Node x) &#123;</span><br><span class="line">    return height(x.left) - height(x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆是一颗完全二叉树，在这棵树中，所有父节点都满足大于等于其子节点的堆叫大根堆，所有父节点都满足小于等于其子节点的堆叫小根堆。堆虽然是一颗树，但是通常存放在一个数组中，父节点和孩子节点的父子关系通过数组下标来确定。如下面的小根堆及存储它的数组：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值：7,8,9,12,13,11<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组索引：0,1,2,3,4,5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过一个节点在数组中的索引怎么计算出它的父节点及左右孩子节点的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int left(int i) &#123;</span><br><span class="line">     return (i + 1) * 2 - 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public int right(int i) &#123;</span><br><span class="line">    return (i + 1) * 2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public int parent(int i) &#123;</span><br><span class="line">    &#x2F;&#x2F; i为根结点</span><br><span class="line">    if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return (i - 1) &#x2F; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;维护大根堆的性质：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void heapify(T[] a, int i, int heapLength) &#123;</span><br><span class="line">    int l &#x3D; left(i);</span><br><span class="line">    int r &#x3D; right(i);</span><br><span class="line">    int largest &#x3D; -1;</span><br><span class="line">    &#x2F;&#x2F;寻找根节点及其左右子节点，三个元素中的最大值</span><br><span class="line">    if (l &lt; heapLength &amp;&amp; a[i].compareTo(a[l]) &lt; 0) &#123;</span><br><span class="line">        largest &#x3D; l;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        largest &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    if (r &lt; heapLength &amp;&amp; a[largest].compareTo(a[r]) &lt; 0) &#123;</span><br><span class="line">        largest &#x3D; r;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 如果i处元素不是最大的，就把i处的元素与最大处元素交换，使得i处元素变为最大的</span><br><span class="line">    if (i !&#x3D; largest) &#123;</span><br><span class="line">        T temp &#x3D; a[i];</span><br><span class="line">        a[i] &#x3D; a[largest];</span><br><span class="line">        a[largest] &#x3D; temp;</span><br><span class="line">        &#x2F;&#x2F; 交换元素后，以a[i]为根的树可能不在满足大根堆性质，于是递归调用该方法</span><br><span class="line">        heapify(a, largest, heapLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造堆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void buildHeap(T[] a, int heapLength) &#123;</span><br><span class="line">    &#x2F;&#x2F;从后往前看lengthParent处的元素是第一个有子节点的元素，所以从它开始，进行堆得维护</span><br><span class="line">    int lengthParent &#x3D; parent(heapLength - 1);</span><br><span class="line">    for(int i &#x3D; lengthParent; i &gt;&#x3D; 0; i--)&#123;</span><br><span class="line">        heapify(a, i, heapLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆的用途：堆排序，优先级队列。此外由于调整代价较小，也适合实时类型的排序与变更。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 架构模式</title>
      <link href="/database/redis/20200804/"/>
      <url>/database/redis/20200804/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><a id="more"></a><h4 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h4><p>特点：简单<br>问题：<br>1、内存容量有限 2、处理能力有限 3、无法高可用。</p><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>Redis 的复制（replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（master），而通过复制创建出来的服务器复制品则为从服务器（slave）。 只要主从服务器之间的网络连接正常，主从服务器两者会具有相同的数据，主服务器就会一直将发生在自己身上的数据更新同步 给从服务器，从而一直保证主从服务器的数据相同。</p><p>特点：<br>1、master/slave 角色<br>2、master/slave 数据相同<br>3、降低 master 读压力在转交从库</p><p>问题：<br>无法保证高可用<br>没有解决 master 写的压力</p><h4 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h4><p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：<br>1、监控（Monitoring）：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。<br>2、提醒（Notification）：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。<br>3、自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</p><p>特点：<br>1、保证高可用<br>2、监控各个节点<br>3、自动故障迁移<br>缺点：主从模式，切换需要时间丢数据<br>没有解决 master 写的压力</p><h4 id="集群（proxy-型）"><a href="#集群（proxy-型）" class="headerlink" title="集群（proxy 型）"></a>集群（proxy 型）</h4><p>Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。<br>特点：<br>1、多种 hash 算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins<br>2、支持失败节点自动删除<br>3、后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致<br>缺点：增加了新的 proxy，需要维护其高可用。<br>failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预</p><h4 id="集群（直连型）："><a href="#集群（直连型）：" class="headerlink" title="集群（直连型）："></a>集群（直连型）：</h4><p>从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p><p>特点：<br>1、无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。<br>2、数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。<br>3、可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。<br>4、高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本<br>5、实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</p><p>缺点：<br>1、资源隔离性较差，容易出现相互影响的情况。<br>2、数据通过异步复制,不保证数据的强一致性</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis 分布式锁</title>
      <link href="/database/redis/20200730/"/>
      <url>/database/redis/20200730/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />#### 常见的分布式锁实现方式* 数据库乐观锁；* 基于Redis的分布式锁；* 基于ZooKeeper的分布式锁。<a id="more"></a><h5 id="redis-分布式锁满足条件"><a href="#redis-分布式锁满足条件" class="headerlink" title="redis 分布式锁满足条件"></a>redis 分布式锁满足条件</h5><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁</li><li>不发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ul><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><blockquote><p>setnx是SET if Not eXists的缩写，当key不存在的情况下设置key和value，返回1，当key存在时，不做任何操作，返回0。可以用锁的争抢，设置key，意为获得锁。<br>expire是对已存在的key设置过期时间，到达过期时间后，自动删除。这个命令有更新时间的含义，已有过期时间，新指令会替代旧指令的时间，并重新计时。重新设置key，也会重新计时。<br>但是分布式锁的实现话，不要用setnx+expire两次命令实现，需要保证原子性。所以用一条指令去实现加锁，set key value px milliseconds nx。</p></blockquote><ul><li>set中加入nx参数，实现效果与setnx是一样的，满足了互斥性。</li><li>设置过期时间，是为了防止死锁，持有锁的线程异常崩溃，无法正常的释放锁。</li><li>这里还有考虑内存淘汰策略。极限情况下，丢锁了。。。</li></ul><h4 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h4><p>redis在内存空间不足的时候，为了保证命中率，就会选择一定的数据淘汰策略。</p><ul><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li><li>volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。</li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</li><li>allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。</li></ul><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>先获取key里的值，进行判断，看是否是自己加的锁。一致后删除。<br>eval执行lua脚本可以保证原子性。整个流程有多次操作（获取，比较，删除（获取+删除））。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>redis存在宕机的危险，如果存储锁的节点宕机了，锁可能会丢失（除了主从复制的集群，都不能保证集群下数据的强一致性，单机挂了就没了，虽然有持久化，但是也不能保证数据完全不丢失）。导致多个客户端持有锁。</p><h4 id="redlock算法"><a href="#redlock算法" class="headerlink" title="redlock算法"></a>redlock算法</h4><p>假设有5个redis master-slave，那么就尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n / 2 + 1。<br>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；<br>要是锁建立失败了，那么就依次之前建立过的锁删除；<br>只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。</p><h4 id="redisson"><a href="#redisson" class="headerlink" title="redisson"></a>redisson</h4><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。<br>Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。</p><h4 id="Redisson-分布式重入锁用法"><a href="#Redisson-分布式重入锁用法" class="headerlink" title="Redisson 分布式重入锁用法"></a>Redisson 分布式重入锁用法</h4><p>Redisson 支持单点模式、主从模式、哨兵模式、集群模式，这里以单点模式为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.构造redisson实现分布式锁必要的Config</span><br><span class="line">Config config &#x3D; new Config();</span><br><span class="line">config.useSingleServer().setAddress(&quot;redis:&#x2F;&#x2F;127.0.0.1:5379&quot;).setPassword(&quot;123456&quot;).setDatabase(0);</span><br><span class="line">&#x2F;&#x2F; 2.构造RedissonClient</span><br><span class="line">RedissonClient redissonClient &#x3D; Redisson.create(config);</span><br><span class="line">&#x2F;&#x2F; 3.获取锁对象实例（无法保证是按线程的顺序获取到）</span><br><span class="line">RLock rLock &#x3D; redissonClient.getLock(lockKey);</span><br><span class="line">try &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 4.尝试获取锁</span><br><span class="line">     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span><br><span class="line">     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean res &#x3D; rLock.tryLock((long)waitTimeout, (long)leaseTime, TimeUnit.SECONDS);</span><br><span class="line">    if (res) &#123;</span><br><span class="line">        &#x2F;&#x2F;成功获得锁，在这里处理业务</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    throw new RuntimeException(&quot;aquire lock fail&quot;);</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    &#x2F;&#x2F;无论如何, 最后都要解锁</span><br><span class="line">    rLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加锁流程图<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/8.png"><br>解锁流程图<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/9.png"><br>我们可以看到，RedissonLock是可重入的，并且考虑了失败重试，可以设置锁的最大等待时间， 在实现上也做了一些优化，减少了无效的锁申请，提升了资源的利用率。<br>需要特别注意的是，RedissonLock 同样没有解决 节点挂掉的时候，存在丢失锁的风险的问题。而现实情况是有一些场景无法容忍的，所以 Redisson 提供了实现了redlock算法的 RedissonRedLock，RedissonRedLock 真正解决了单点失败的问题，代价是需要额外的为 RedissonRedLock 搭建Redis环境。<br>所以，如果业务场景可以容忍这种小概率的错误，则推荐使用 RedissonLock， 如果无法容忍，则推荐使用 RedissonRedLock。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis知识点</title>
      <link href="/database/redis/20190927/"/>
      <url>/database/redis/20190927/</url>
      
        <content type="html"><![CDATA[<h4 id="redis淘汰策略"><a href="#redis淘汰策略" class="headerlink" title="redis淘汰策略"></a>redis淘汰策略</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：</p><ul><li>voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据<a id="more"></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis命令</title>
      <link href="/database/redis/20190517/"/>
      <url>/database/redis/20190517/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h3><h4 id="客户端基本语法"><a href="#客户端基本语法" class="headerlink" title="客户端基本语法"></a>客户端基本语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br></pre></td></tr></table></figure><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line"></span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h4 id="连接远程"><a href="#连接远程" class="headerlink" title="连接远程"></a>连接远程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli -h host -p port -a password</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line"></span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="Redis-keys-命令"><a href="#Redis-keys-命令" class="headerlink" title="Redis keys 命令"></a>Redis keys 命令</h3><h4 id="DEL-key"><a href="#DEL-key" class="headerlink" title="DEL key"></a>DEL key</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该命令用于在 key 存在时删除 key。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基本语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; DEL KEY_NAME</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可用版本<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;= 1.0.0<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回值<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;被删除 key 的数量。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql连接（未写完）</title>
      <link href="/database/mysql/20200630/"/>
      <url>/database/mysql/20200630/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL5.7中Derived table变形记</title>
      <link href="/database/mysql/20190426/"/>
      <url>/database/mysql/20190426/</url>
      
        <content type="html"><![CDATA[<h3 id="MySQL-Derived-table"><a href="#MySQL-Derived-table" class="headerlink" title="MySQL Derived table"></a>MySQL Derived table</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derived table实际上是一种特殊的subquery，它位于SQL语句中FROM子句里面，可以看做是一个单独的表。MySQL5.7之前的处理都是对Derived table进行Materialize，生成一个临时表保存Derived table的结果，然后利用临时表来协助完成其他父查询的操作，比如JOIN等操作。MySQL5.7中对Derived table做了一个新特性。该特性允许将符合条件的Derived table中的子表与父查询的表合并进行直接JOIN。<a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们看一下DBT-3中的一条被新特性优化过的执行计划：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT t2.o_clerk, t1.price - t2.o_totalprice</span><br><span class="line">FROM</span><br><span class="line">    (SELECT l_orderkey, SUM( l_extendedprice * (1 - l_discount)) price</span><br><span class="line">     FROM lineitem GROUP by l_orderkey) t1</span><br><span class="line">JOIN</span><br><span class="line">    (SELECT o_clerk, o_orderkey, o_totalprice</span><br><span class="line">     FROM orders </span><br><span class="line">     WHERE o_orderdate BETWEEN &#39;1995-01-01&#39; AND &#39;1995-12-31&#39;) t2</span><br><span class="line">ON t1.l_orderkey &#x3D; t2.o_orderkey WHERE t1.price &gt; t2.o_totalprice;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MySQL5.6执行计划如下图所示（下图通过WorkBench的Visual Explain直观的对执行计划进行了展示）：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/iEU4flk.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对应的explain输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ID SELECT_TYPE  TABLE    TYPEPOSSIBLE_KEYSKEY    KEY_LENREF            ROWS    EXTRA</span><br><span class="line">1PRIMARY  &lt;derived3&gt;ALL  NULL        NULLNULLNULL        4812318    NULL</span><br><span class="line">1PRIMARY    &lt;derived2&gt;ref   &lt;auto_key0&gt; &lt;auto_key0&gt;   4t2.o_orderkey599860    Using where; Using index</span><br><span class="line">3DERIVED       ordersALL   i_o_orderdateNULLNULLNULL        15000000    Using where</span><br><span class="line">2DERIVED      lineitemindexPRIMARY, i_l_shipdate, …PRIMARY8NULL 59986052NULL   </span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到orders已经从Derived table的子表里面merge到了父查询中，尽而简化了执行计划，同时也提高了执行效率。看一下MySQL5.6与MySQL5.7对于上面的DBT-3中的这条Query执行性能的对比图：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/RWDjMQi.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merge Derived table有两种方式进行控制。第一种，通过开关optimizer_switch=’derived_merge=on|off’来进行控制。第二种，在CREATE VIEW的时候指定ALGORITHM=MERGE | TEMPTABLE， 默认是MERGE方式。如果指定是TEMPTABLE，将不会对VIEW进行Merge Derived table操作。只要Derived table里不包含如下条件就可以利用该特性进行优化：</p><ul><li>UNION clause</li><li>GROUP BY</li><li>DISTINCT</li><li>Aggregation</li><li>LIMIT or OFFSET</li><li>Derived table里面包含用户变量的设置。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么Merge Derived table在MySQL中是如何实现的呢？下面我们分析一下源码。<br>对于Derived table的merge过程是在MySQL的resolve阶段完成的，这意味着对于Merge操作是永久性的，经过resolve阶段之后就不会再对Derived table进行其他的变换。执行的简单流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT_LEX::prepare</span><br><span class="line"></span><br><span class="line">       |</span><br><span class="line"></span><br><span class="line">TABLE_LIST::resolve_derived &#x2F;&#x2F; 这里首先递归对每个Derived table自身进行变换，经过变换后的Derived table开始考虑和最外层的父查询进行Merge</span><br><span class="line"></span><br><span class="line">       |</span><br><span class="line"></span><br><span class="line">SELECT_LEX::merge_derived &#x2F;&#x2F; 将Derived table与父查询进行Merge</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们重点研究一下merge_derived这个函数实现过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line">bool SELECT_LEX::merge_derived(THD *thd, TABLE_LIST *derived_table)</span><br><span class="line">&#123;   </span><br><span class="line">  DBUG_ENTER(&quot;SELECT_LEX::merge_derived&quot;);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 这里首先会判断是不是Derived table（这里view看做是带有名字的Derived table),同时也会看该Derived table是否已经被合并过了</span><br><span class="line">  if (!derived_table-&gt;is_view_or_derived() || derived_table-&gt;is_merged())</span><br><span class="line">    DBUG_RETURN(false);</span><br><span class="line"></span><br><span class="line">  SELECT_LEX_UNIT *const derived_unit&#x3D; derived_table-&gt;derived_unit();</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; A derived table must be prepared before we can merge it</span><br><span class="line">  DBUG_ASSERT(derived_unit-&gt;is_prepared());</span><br><span class="line"></span><br><span class="line">  LEX *const lex&#x3D; parent_lex;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; Check whether the outer query allows merged views</span><br><span class="line">  if ((master_unit() &#x3D;&#x3D; lex-&gt;unit &amp;&amp; &#x2F;&#x2F; 只会在父查询进行merge Derived table操作。</span><br><span class="line">    &#x2F;&#x2F; 这里会查看当前命令是否需要进行merge操作，比如CREATE VIEW，SHOW CREATE VIEW等。如果需要再继续</span><br><span class="line">       !lex-&gt;can_use_merged()) ||  </span><br><span class="line">      lex-&gt;can_not_use_merged()) </span><br><span class="line">    DBUG_RETURN(false);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 查看当前的Derived table是否满足merge条件</span><br><span class="line">  if (!derived_unit-&gt;is_mergeable() ||</span><br><span class="line">      derived_table-&gt;algorithm &#x3D;&#x3D; VIEW_ALGORITHM_TEMPTABLE ||</span><br><span class="line">      (!thd-&gt;optimizer_switch_flag(OPTIMIZER_SWITCH_DERIVED_MERGE) &amp;&amp;</span><br><span class="line">       derived_table-&gt;algorithm !&#x3D; VIEW_ALGORITHM_MERGE))</span><br><span class="line">    DBUG_RETURN(false);</span><br><span class="line"></span><br><span class="line">  SELECT_LEX *const derived_select&#x3D; derived_unit-&gt;first_select();</span><br><span class="line">  &#x2F;*</span><br><span class="line">当前不会对包含 STRAIGHT_JOIN，且Derived table中包含semi-join的query进行merge操作。</span><br><span class="line">这是因为MySQL为了保证正确性，必须先做semi-join之后才可以与其他表继续做JOIN。</span><br><span class="line">例如：select straight_join * from tt , (select * from tt where a in (select a from t1)) as ttt;</span><br><span class="line">  *&#x2F;</span><br><span class="line">  if ((active_options() &amp; SELECT_STRAIGHT_JOIN) &amp;&amp; derived_select-&gt;has_sj_nests)</span><br><span class="line">    DBUG_RETURN(false);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 利用Nested_join结构来辅助处理OUTER-JOIN的情况。如果Derived table是OUTER-JOIN的内表，需要将Derived table中的每个表设置为JOIN的时候可以为空。具体请参考propagate_nullability。</span><br><span class="line">  if (!(derived_table-&gt;nested_join&#x3D;</span><br><span class="line">       (NESTED_JOIN *) thd-&gt;mem_calloc(sizeof(NESTED_JOIN))))</span><br><span class="line">    DBUG_RETURN(true);        &#x2F;* purecov: inspected *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; 这里确保NESTED_JOIN结构是空的，在构造函数处理比较合适</span><br><span class="line">  derived_table-&gt;nested_join-&gt;join_list.empty();</span><br><span class="line">  &#x2F;&#x2F; 该函数会将所有Derived table中的表merge到NESTED_JOIN结构体中</span><br><span class="line">  if (derived_table-&gt;merge_underlying_tables(derived_select))</span><br><span class="line">    DBUG_RETURN(true);       &#x2F;* purecov: inspected *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 接下来需要将Derived table中的所有表连接到父查询的table_list列表中，进而将Derived table从父查询中剔除。</span><br><span class="line">  for (TABLE_LIST **tl&#x3D; &amp;leaf_tables; *tl; tl&#x3D; &amp;(*tl)-&gt;next_leaf)</span><br><span class="line">  &#123;</span><br><span class="line">    if (*tl &#x3D;&#x3D; derived_table)</span><br><span class="line">    &#123;</span><br><span class="line">      for (TABLE_LIST *leaf&#x3D; derived_select-&gt;leaf_tables; leaf;</span><br><span class="line">           leaf&#x3D; leaf-&gt;next_leaf)</span><br><span class="line">      &#123;</span><br><span class="line">        if (leaf-&gt;next_leaf &#x3D;&#x3D; NULL)</span><br><span class="line">        &#123;</span><br><span class="line">          leaf-&gt;next_leaf&#x3D; (*tl)-&gt;next_leaf;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      *tl&#x3D; derived_select-&gt;leaf_tables;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 下面会对父查询的所有相关数据结构进行重新计算，进而包含所有从Derived table merge之后的表的相关信息。</span><br><span class="line">  leaf_table_count+&#x3D; (derived_select-&gt;leaf_table_count - 1);</span><br><span class="line">  derived_table_count+&#x3D; derived_select-&gt;derived_table_count;</span><br><span class="line">  materialized_derived_table_count+&#x3D;</span><br><span class="line">    derived_select-&gt;materialized_derived_table_count;</span><br><span class="line">  has_sj_nests|&#x3D; derived_select-&gt;has_sj_nests;</span><br><span class="line">  partitioned_table_count+&#x3D; derived_select-&gt;partitioned_table_count;</span><br><span class="line">  cond_count+&#x3D; derived_select-&gt;cond_count;</span><br><span class="line">  between_count+&#x3D; derived_select-&gt;between_count;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Propagate schema table indication:</span><br><span class="line">  &#x2F;&#x2F; @todo: Add to BASE options instead</span><br><span class="line">  if (derived_select-&gt;active_options() &amp; OPTION_SCHEMA_TABLE)</span><br><span class="line">    add_base_options(OPTION_SCHEMA_TABLE);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Propagate nullability for derived tables within outer joins:</span><br><span class="line">  if (derived_table-&gt;is_inner_table_of_outer_join())</span><br><span class="line">    propagate_nullability(&amp;derived_table-&gt;nested_join-&gt;join_list, true);</span><br><span class="line"></span><br><span class="line">  select_n_having_items+&#x3D; derived_select-&gt;select_n_having_items;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将Derived table的where条件合并到父查询</span><br><span class="line">  if (derived_table-&gt;merge_where(thd))</span><br><span class="line">    DBUG_RETURN(true);        &#x2F;* purecov: inspected *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; 将Derived table的结构从父查询中删除</span><br><span class="line">  derived_unit-&gt;exclude_level();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 这里用来禁止对Derived table的继续访问</span><br><span class="line">  derived_table-&gt;set_derived_unit((SELECT_LEX_UNIT *)1);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 建立对Derived table需要获取的列的引用。在后续函数中会对引用列进行相关处理，请参考函数setup_natural_join_row_types函数</span><br><span class="line">  if (derived_table-&gt;create_field_translation(thd))  </span><br><span class="line">    DBUG_RETURN(true); </span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将Derived table中的列或者表的重命名合并到父查询</span><br><span class="line">  merge_contexts(derived_select);</span><br><span class="line">  repoint_contexts_of_join_nests(derived_select-&gt;top_join_list);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 因为已经把Derived table中包含的表merge到了父查询，所以需要对TABLE_LIST中的表所在的位置进行重新定位。</span><br><span class="line">  remap_tables(thd);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将Derived table合并到父查询之后，需要重新修改原来Derived table中所有对Derived table中所有列的引用，</span><br><span class="line">  fix_tables_after_pullout(this, derived_select, derived_table, table_adjust);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果Derived table中包含ORDER By语句，处理原则和正常SubQuery的处理方式类似：</span><br><span class="line">  &#x2F;&#x2F;  1. 如果Derived table只包含一个表</span><br><span class="line">  &#x2F;&#x2F;  2. 并且Derived table不包含聚集函数</span><br><span class="line">  &#x2F;&#x2F; 满足上述两个条件之后，Derived table将会保留ORDER BY。其他情况subquery中的ORDER BY将会被忽略掉，这也是MySQL5.7区别于MySQL5.6的一点。</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;  当Derived table保留了Order by，是否能合并到父查询，需要满足如下条件：</span><br><span class="line">  &#x2F;&#x2F; 1. 父查询允许做Derived table中的ORDER BY。下面几种情况不允许做ORDER BY</span><br><span class="line">  &#x2F;&#x2F; a) 如果父查询包含有自己的ORDER BY</span><br><span class="line">  &#x2F;&#x2F; b) 如果父查询包含GROUP BY</span><br><span class="line">  &#x2F;&#x2F;         c) 如果父查询包含未被优化掉的DISTINCT</span><br><span class="line">  &#x2F;&#x2F; 2. 父查询不能是UNION操作，因为UNION默认会做DISTINCT操作</span><br><span class="line">  &#x2F;&#x2F;     3. 为了简化操作，只有当父查询只包含Derived table的时候（即FROM子句里面只有Derived table一个表）才可以保留ORDER BY。这里有相当大的改进空间可以尽量的来按照Derived table定义的ORDER BY操作来进行父查询的操作。比如有两个表以上，如果父查询没有ORDER BY的要求，也可以按照Derived table来对结果进行排序。</span><br><span class="line">  if (derived_select-&gt;is_ordered())</span><br><span class="line">  &#123;</span><br><span class="line">    if ((lex-&gt;sql_command &#x3D;&#x3D; SQLCOM_SELECT ||</span><br><span class="line">         lex-&gt;sql_command &#x3D;&#x3D; SQLCOM_UPDATE ||</span><br><span class="line">         lex-&gt;sql_command &#x3D;&#x3D; SQLCOM_DELETE) &amp;&amp;</span><br><span class="line">        !(master_unit()-&gt;is_union() ||</span><br><span class="line">          is_grouped() ||</span><br><span class="line">          is_distinct() ||</span><br><span class="line">          is_ordered() ||</span><br><span class="line">          get_table_list()-&gt;next_local !&#x3D; NULL))</span><br><span class="line">      order_list.push_back(&amp;derived_select-&gt;order_list);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 对于Derived table中包含的full-text functions需要添加到父查询的查询列表中。</span><br><span class="line">  if (derived_select-&gt;ftfunc_list-&gt;elements &amp;&amp;</span><br><span class="line">      add_ftfunc_list(derived_select-&gt;ftfunc_list))</span><br><span class="line">    DBUG_RETURN(true);        &#x2F;* purecov: inspected *&#x2F;</span><br><span class="line"></span><br><span class="line">  DBUG_RETURN(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，本篇文章简要的分析了MySQL Merge Derived table的作用以及实现方式。Merge Derived table的引入可以有效的提升Subquery query的执行效率，更重要的是为以后应对复杂查询提供了新的优化手段。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引底层实现原理</title>
      <link href="/database/mysql/20190425/"/>
      <url>/database/mysql/20190425/</url>
      
        <content type="html"><![CDATA[<h3 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。<a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看一个栗子：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/E8ANlJi.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(logn2)的复杂度内获取到相应数据。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在介绍B树之前，先来看另一棵神奇的树——二叉排序树（Binary Sort Tree），首先它是一棵树，“二叉”这个描述已经很明显了，就是树上的一根树枝开两个叉，于是递归下来就是二叉树了（下图所示），而这棵树上的节点是已经排好序的，具体的排序规则如下：</p><ul><li>若左子树不空，则左子树上所有节点的值均小于它的根节点的值</li><li>若右子树不空，则右字数上所有节点的值均大于它的根节点的值</li><li>它的左、右子树也分别为二叉排序数（递归定义）</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/JQo1Vob.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从图中可以看出，二叉排序树组织数据时，用于查找是比较方便的，因为每次经过一次节点时，最多可以减少一半的可能，不过极端情况会出现所有节点都位于同一侧，直观上看就是一条直线，那么这种查询的效率就比较低了，因此需要对二叉树左右子树的高度进行平衡化处理，于是就有了平衡二叉树（Balenced Binary Tree）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓“平衡”，说的是这棵树的各个分支的高度是均匀的，它的左子树和右子树的高度之差绝对值小于1，这样就不会出现一条支路特别长的情况。于是，在这样的平衡树中进行查找时，总共比较节点的次数不超过树的高度，这就确保了查询的效率（时间复杂度为O(logn)）</p><h3 id="B树-B-树"><a href="#B树-B-树" class="headerlink" title="B树(B-树)"></a>B树(B-树)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还是直接看图比较清楚，图中所示，B树事实上是一种平衡的多叉查找树，B即Balanced，也就是说最多可以开m个叉（m&gt;=2），我们称之为m阶b树，这里特意画了一棵5阶B树 。<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/JOqST3D.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总的来说，m阶B树满足以下条件：</p><ul><li>每个节点至多可以拥有m棵子树。</li><li>根节点，只有至少有2个节点（要么极端情况，就是一棵树就一个根节点，单细胞生物，即是根，也是叶，也是树)。</li><li>非根非叶的节点至少有的Ceil(m/2)个子树(Ceil表示向上取整，图中5阶B树，每个节点至少有3个子树，也就是至少有3个叉)。</li><li>非叶节点中的信息包括[n,A0,K1,A1,K2,A2,…,Kn,An]，，其中n表示该节点中保存的关键字个数，K为关键字且Ki&lt;Ki+1，A为指向子树根节点的指针。</li><li>从根到叶子的每一条路径都有相同的长度，也就是说，叶子节在相同的层，并且这些节点不带信息，实际上这些节点就表示找不到指定的值，也就是指向这些节点的指针为空。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B树的查询过程和二叉排序树比较类似，从根节点依次比较每个结点，因为每个节点中的关键字和左右子树都是有序的，所以只要比较节点中的关键字，或者沿着指针就能很快地找到指定的关键字，如果查找失败，则会返回叶子节点，即空指针。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如查询图中字母表中的K：</p><ol><li>从根节点P开始，K的位置在P之前，进入左侧指针。</li><li>左子树中，依次比较C、F、J、M，发现K在J和M之间。</li><li>沿着J和M之间的指针，继续访问子树，并依次进行比较，发现第一个关键字K即为指定查找的值。</li></ol><p>B树搜索的简单伪算法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BTree_Search(node, key) &#123;</span><br><span class="line">    if(node &#x3D;&#x3D; null) return null;</span><br><span class="line">    foreach(node.key)</span><br><span class="line">    &#123;</span><br><span class="line">        if(node.key[i] &#x3D;&#x3D; key) return node.data[i];</span><br><span class="line">            if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    return BTree_Search(point[i+1]-&gt;node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data &#x3D; BTree_Search(root, my_key);</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B树的特点可以总结为如下：</p><ol><li>关键字集合分布在整颗树中。</li><li>任何一个关键字出现且只出现在一个节点中。</li><li>搜索有可能在非叶子节点结束。</li><li>其搜索性能等价于在关键字集合内做一次二分查找。</li><li>B树在插入删除新的数据记录会破坏B-Tree的性质，因为在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质。</li></ol><h3 id="Plus版-—-B-树"><a href="#Plus版-—-B-树" class="headerlink" title="Plus版 — B+树"></a>Plus版 — B+树</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为B树的加强版，B+树与B树的差异在于</p><ul><li>有n棵子树的节点含有n个关键字（也有认为是n-1个关键字）。</li><li>所有的关键字全部存储在叶子节点上，且叶子节点本身根据关键字自小而大顺序连接。</li><li>非叶子节点可以看成索引部分，节点中仅含有其子树（根节点）中的最大（或最小）关键字。</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/UlPKpVq.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B+树的查找过程，与B树类似，只不过查找时，如果在非叶子节点上的关键字等于给定值，并不终止，而是继续沿着指针直到叶子节点位置。因此在B+树，不管查找成功与否，每次查找都是走了一条从根到叶子节点的路径。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B+树的特性如下：</p><ul><li>所有关键字都存储在叶子节上，且链表中的关键字恰好是有序的。</li><li>不可能非叶子节点命中返回。</li><li>非叶子节点相当于叶子节点的索引，叶子节点相当于是存储（关键字）数据的数据层。</li><li>更适合文件索引系统。</li></ul><h3 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/jt1sYyX.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><h3 id="MySQL为什么使用B树（B-树）"><a href="#MySQL为什么使用B树（B-树）" class="headerlink" title="MySQL为什么使用B树（B+树）"></a>MySQL为什么使用B树（B+树）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#">Post not found: 20190425_1</a>等数据结构也可以用来实现索引，但是文件系统以及数据库系统普遍采用B树或者B+树，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。这样的话，索引查找过程中o就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率</p><h3 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/574boWH.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。上图展示了一个4 x 4的主存模型。<br><strong>主存的存取过程如下：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><h3 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图是磁盘的整体结构示意图：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/3PImRBF.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图是磁盘结构的示意图：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/CiNyYKb.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/JxRph0L.png"></p><h3 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个数据被用到时，其附近的数据也通常会马上被使用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，程序运行期间所需要的数据通常应当比较集中。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里终于可以分析B-/+Tree索引的性能了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。（h表示树的高度 &amp; 出度d表示的是树的度，即树中各个节点的度的最大值）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，用B-Tree作为索引结构效率是非常高的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmax=floor(pagesize/(keysize+datasize+pointsize))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p><h3 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><h4 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/gSRE7hn.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里设表一共有三列，假设我们以Col1为主键，则上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/IUaUT32.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样也是一棵B+树，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h4 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/b8UXvPU.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整型。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，上图为定义在Col3上的一个辅助索引：<br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/2illpIF.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一棵B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql如何获取当前时间</title>
      <link href="/database/mysql/20190424/"/>
      <url>/database/mysql/20190424/</url>
      
        <content type="html"><![CDATA[<h3 id="mysql如何获取当前时间"><a href="#mysql如何获取当前时间" class="headerlink" title="mysql如何获取当前时间"></a>mysql如何获取当前时间</h3><h4 id="now"><a href="#now" class="headerlink" title="now()"></a>now()</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获得当前日期+时间（date + time）函数：now() </p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了 now() 函数能获得当前的日期时间外，MySQL 中还有下面的函数：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current_timestamp() current_timestamp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localtime() localtime<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localtimestamp() localtimestamp<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些日期时间函数，都等同于 now()。鉴于 now() 函数简短易记，建议总是使用 now() 来替代上面列出的函数。</p><h4 id="sysdate"><a href="#sysdate" class="headerlink" title="sysdate()"></a>sysdate()</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获得当前日期+时间（date + time）函数：sysdate()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sysdate() 日期时间函数跟 now() 类似，不同之处在于：now() 在执行开始时值就得到了， sysdate() 在函数执行时动态得到值。</p><h4 id="curdate"><a href="#curdate" class="headerlink" title="curdate()"></a>curdate()</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获得当前日期（date）函数：curdate()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，下面的两个日期函数等同于 curdate()： current_date(),current_date </p><h4 id="curtime"><a href="#curtime" class="headerlink" title="curtime()"></a>curtime()</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获得当前时间（time）函数：curtime()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curtime() 其中，下面的两个时间函数等同于 curtime()：current_time(),current_time<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curtime() 获得当前 UTC 日期时间函数：utc_date(), utc_time(), utc_timestamp()</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql关键字执行顺序</title>
      <link href="/database/mysql/20190409/"/>
      <url>/database/mysql/20190409/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="mysql关键字执行顺序"><a href="#mysql关键字执行顺序" class="headerlink" title="mysql关键字执行顺序"></a>mysql关键字执行顺序</h3><ol><li>from</li><li>on</li><li>join</li><li>where</li><li>group by</li><li>having</li><li>select</li><li>distinc </li><li>union</li><li>order by<a id="more"></a></li></ol><h3 id="那么需要先排序在分组的操作怎么办"><a href="#那么需要先排序在分组的操作怎么办" class="headerlink" title="那么需要先排序在分组的操作怎么办"></a>那么需要先排序在分组的操作怎么办</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于版本原因，mysql5.7以下版本，可以用这个样去处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.operatetime,a.ERRORMESSAGE from (select operatetime,ERRORMESSAGE from gumessagelog where businessno &#x3D; &#39;xxxx&#39; ORDER BY OperateTime) a GROUP BY a.ERRORMESSAGE;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mysql5.7以上，包括5.7版本，上面的方法就不适用了，5.7版本进行了优化，优先按关键字处理。那么可以这样做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select  left(group_concat(operatetime order by operatetime desc),&quot;19&quot;),ERRORMESSAGE from gumessagelog where businessno &#x3D; &#39;xxxx&#39; GROUP BY ERRORMESSAGE;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;left函数可以换成其他的，19的长短也可以换。</p><h3 id="那么为什么会被优化"><a href="#那么为什么会被优化" class="headerlink" title="那么为什么会被优化"></a>那么为什么会被优化</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://yq.aliyun.com/articles/72503">5.7中Derived table变形记</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查阅相关资料了解到MySql 5.7对子查询进行了优化，认为子查询中的order by可以进行忽略，只要Derived table里不包含如下条件就可以进行优化：</p><ol><li>UNION clause</li><li>GROUP BY</li><li>DISTINCT</li><li>Aggregation</li><li>LIMIT or OFFSET</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么对之前语句进行改写，就可以加上limit处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select a.operatetime,a.ERRORMESSAGE from (select operatetime,ERRORMESSAGE from gumessagelog where businessno &#x3D; &#39;xxxx&#39; ORDER BY OperateTime desc limit 9999) a GROUP BY a.ERRORMESSAGE;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之外的话，可以利用结果集进行二次处理。比如利用中间表方式，先对数据进行排序。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql利用find_in_set去查询in的集合</title>
      <link href="/database/mysql/20190327/"/>
      <url>/database/mysql/20190327/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />MySQL手册中find_in_set函数的语法：FIND_IN_SET(str,strlist)str 要查询的字符串strlist 字段名 参数以”,”分隔 如 (1,2,6,8)<a id="more"></a>查询字段(strlist)中包含(str)的结果，返回结果为null或记录假如字符串str在由N个子链组成的字符串列表strlist 中，则返回值的范围在 1 到 N 之间。 一个字符串列表就是一个由一些被 ‘,’ 符号分开的子链组成的字符串。如果第一个参数是一个常数字符串，而第二个是type SET列，则FIND_IN_SET() 函数被优化，使用比特计算。 如果str不在strlist 或strlist 为空字符串，则返回值为 0 。如任意一个参数为NULL，则返回值为 NULL。这个函数在第一个参数包含一个逗号(‘,’)时将无法正常运行。用find_in_set(str,strList)函数去进行处理，一个字段多条件的查询<p>set @field = ‘P106620190101X0000012,P106620190101X0000013’;<br>select * from table where find_in_set(field,@field);</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 性能优化梳理</title>
      <link href="/database/20191009/"/>
      <url>/database/20191009/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="基本概念简述"><a href="#基本概念简述" class="headerlink" title="基本概念简述"></a>基本概念简述</h3><h4 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h4><ul><li>第一层：客户端通过连接服务，将要执行的sql指令传输过来<ul><li>客户端</li></ul></li><li>第二层：服务器解析并优化sql，生成最终的执行计划并执行<ul><li>缓存</li><li>解析SQL</li><li>预处理</li><li>查询优化器</li><li>生成执行计划</li><li>执行</li></ul></li><li>第三层：存储引擎，负责数据的储存和提取<ul><li>存储引擎<a id="more"></a></li></ul></li></ul><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>数据库通过锁机制来解决并发场景-共享锁（读锁）和排他锁（写锁）。读锁是不阻塞的，多个客户端可以在同一时刻读取同一个资源。写锁是排他的，并且会阻塞其他的读锁和写锁。简单提下乐观锁和悲观锁。</p><ul><li>乐观锁，通常用于数据竞争不激烈的场景，多读少写，通过版本号和时间戳实现。</li><li>悲观锁，通常用于数据竞争激烈的场景，每次操作都会锁定数据。</li></ul><p>要锁定数据需要一定的锁策略来配合。</p><ul><li>表锁，锁定整张表，开销最小，但是会加剧锁竞争。</li><li>行锁，锁定行级别，开销最大，但是可以最大程度的支持并发。</li></ul><p>但是MySql的存储引擎的真实实现不是简单的行级锁，一般都是实现了多版本并发控制（MVCC）。MVCC是行级锁的变种，多数情况下避免了加锁操作，开销更低。MVCC是通过保存数据的某个时间点快照实现的。所有操作都有事务，只是不加transaction，是默认自动提交，加了transaction，手动提交，容易操作。</p><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>事务保证一组原子性的操作，要么全部成功，要么全部失败。一旦失败，回滚之前的所有操作。MySql采用自动提交，如果不是显式的开启一个事务，则每个查询都作为一个事务。</p><p>隔离级别控制了一个事务中的修改，哪些在事务内和事务间是可见的。四种常见的隔离级别：</p><ul><li>未提交读（Read UnCommitted），事务中的修改，即使没提交对其他事务也是可见的。事务可能读取未提交的数据，造成脏读。</li><li>提交读（Read Committed），一个事务开始时，只能看见已提交的事务所做的修改。事务未提交之前，所做的修改对其他事务是不可见的。也叫不可重复读，同一个事务多次读取同样记录可能不同。</li><li>可重复读（RepeatTable Read），同一个事务中多次读取同样的记录结果时结果相同。</li><li>可串行化（Serializable），最高隔离级别，强制事务串行执行。</li></ul><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>InnoDB引擎，最重要，使用最广泛的存储引擎。被用来设计处理大量短期事务，具有高性能和自动崩溃恢复的特性。<br>MyISAM引擎，不支持事务和行级锁，崩溃后无法安全恢复。</p><h3 id="创建时优化"><a href="#创建时优化" class="headerlink" title="创建时优化"></a>创建时优化</h3><h4 id="Schema和数据类型优化"><a href="#Schema和数据类型优化" class="headerlink" title="Schema和数据类型优化"></a>Schema和数据类型优化</h4><p><strong>整数</strong><br>TinyInt,SmallInt,MediumInt,Int,BigInt 使用的存储8,16,24,32,64位存储空间。使用Unsigned表示不允许负数，可以使正数的上线提高一倍。<br><strong>实数</strong></p><ul><li>Float,Double , 支持近似的浮点运算。</li><li>Decimal，用于存储精确的小数。</li></ul><p><strong>字符串</strong></p><ul><li>VarChar，存储变长的字符串。需要1或2个额外的字节记录字符串的长度。</li><li>Char，定长，适合存储固定长度的字符串，如MD5值。</li><li>Blob，Text 为了存储很大的数据而设计的。分别采用二进制和字符的方式。</li></ul><p><strong>时间类型</strong></p><ul><li>DateTime，保存大范围的值，占8个字节。</li><li>TimeStamp，推荐，与UNIX时间戳相同，占4个字节。</li></ul><p><strong>优化建议点</strong></p><ul><li>尽量使用对应的数据类型。比如，不要用字符串类型保存时间，用整型保存IP。</li><li>选择更小的数据类型。能用TinyInt不用Int。</li><li>标识列（identifier column），建议使用整型，不推荐字符串类型，占用更多空间，而且计算速度比整型慢。</li><li>不推荐ORM系统自动生成的Schema，通常具有不注重数据类型，使用很大的VarChar类型，索引利用不合理等问题。</li><li>真实场景混用范式和反范式。冗余高查询效率高，插入更新效率低；冗余低插入更新效率高，查询效率低。</li><li>创建完全的独立的汇总表\缓存表，定时生成数据，用于用户耗时时间长的操作。对于精确度要求高的汇总操作，可以采用 历史结果+最新记录的结果 来达到快速查询的目的。</li><li>数据迁移，表升级的过程中可以使用影子表的方式，通过修改原表的表名，达到保存历史数据，同时不影响新表使用的目的。</li></ul><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引包含一个或多个列的值。MySql只能高效的利用索引的最左前缀列。索引的优势：</p><ul><li>减少查询扫描的数据量</li><li>避免排序和零时表</li><li>将随机IO变为顺序IO （顺序IO的效率高于随机IO）</li></ul><p><strong>B-Tree</strong><br>使用最多的索引类型。采用B-Tree数据结构来存储数据（每个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的遍历）。B-Tree索引适用于全键值，键值范围，键前缀查找，支持排序。<br>B-Tree索引限制：</p><ul><li>如果不是按照索引的最左列开始查询，则无法使用索引。</li><li>不能跳过索引中的列。如果使用第一列和第三列索引，则只能使用第一列索引。</li><li>如果查询中有个范围查询，则其右边的所有列都无法使用索引优化查询。</li></ul><p><strong>哈希索引</strong><br>只有精确匹配索引的所有列，查询才有效。存储引擎会对所有的索引列计算一个哈希码，哈希索引将所有的哈希码存储在索引中，并保存指向每个数据行的指针。<br>哈希索引限制：</p><ul><li>无法用于排序</li><li>不支持部分匹配</li><li>只支持等值查询如=，IN（），不支持 &lt; &gt;</li></ul><p>优化建议点<br>注意每种索引的适用范围和适用限制。</p><ul><li>索引的列如果是表达式的一部分或者是函数的参数，则失效。</li><li>针对特别长的字符串，可以使用前缀索引，根据索引的选择性选择合适的前缀长度。</li><li>使用多列索引的时候，可以通过 AND 和 OR 语法连接。</li><li>重复索引没必要，如（A，B）和（A）重复。</li><li>索引在where条件查询和group by语法查询的时候特别有效。</li><li>将范围查询放在条件查询的最后，防止范围查询导致的右边索引失效的问题。</li><li>索引最好不要选择过长的字符串，而且索引列也不宜为null。</li></ul><h3 id="查询时优化"><a href="#查询时优化" class="headerlink" title="查询时优化"></a>查询时优化</h3><h4 id="查询质量的三个重要指标"><a href="#查询质量的三个重要指标" class="headerlink" title="查询质量的三个重要指标"></a>查询质量的三个重要指标</h4><ul><li>响应时间 （服务时间，排队时间）</li><li><strong>扫描的行</strong></li><li><strong>返回的行</strong> 占内存</li></ul><h4 id="查询优化点"><a href="#查询优化点" class="headerlink" title="查询优化点"></a>查询优化点</h4><ul><li>避免查询无关的列，如使用Select * 返回所有的列。</li><li>避免查询无关的行</li><li>切分查询。将一个对服务器压力较大的任务，分解到一个较长的时间中，并分多次执行。如要删除一万条数据，可以分10次执行，每次执行完成后暂停一段时间，再继续执行。过程中可以释放服务器资源给其他任务。</li><li>分解关联查询。将多表关联查询的一次查询，分解成对单表的多次查询。可以减少锁竞争，查询本身的查询效率也比较高。因为MySql的连接和断开都是轻量级的操作，不会由于查询拆分为多次，造成效率问题。</li><li>注意count的操作只能统计不为null的列，所以统计总的行数使用count（*）。</li><li>group by 按照标识列分组效率高，分组结果不宜出行分组列之外的列。</li><li>关联查询延迟关联，可以根据查询条件先缩小各自要查询的范围，再关联。</li><li>Limit分页优化。可以根据索引覆盖扫描，再根据索引列关联自身查询其他列。</li><li>Union查询默认去重，如果不是业务必须，建议使用效率更高的Union All</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>条件中的字段类型和表结构类型不一致，mysql会自动加转换函数，导致索引作为函数中的参数失效。</li><li>like查询前面部分未输入，以%开头无法命中索引。</li><li>补充2个5.7版本的新特性：<ul><li>generated column，就是数据库中这一列由其他列计算而得</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE triangle (sidea DOUBLE, sideb DOUBLE, area DOUBLE AS (sidea * sideb &#x2F; 2));</span><br><span class="line">insert into triangle(sidea, sideb) values(3, 4);</span><br><span class="line">select * from triangle; </span><br><span class="line"></span><br><span class="line">+-------+-------+------+</span><br><span class="line">| sidea | sideb | area |</span><br><span class="line">+-------+-------+------+</span><br><span class="line">|   3      |   4      |  6     |</span><br><span class="line">+-------+-------+------+</span><br></pre></td></tr></table></figure><ul><li>支持JSON格式数据，并提供相关内置函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE json_test (name JSON);</span><br><span class="line">INSERT INTO json_test VALUES(&#39;&#123;&quot;name1&quot;: &quot;value1&quot;, &quot;name2&quot;: &quot;value2&quot;&#125;&#39;);</span><br><span class="line">SELECT * FROM json_test WHERE JSON_CONTAINS(name, &#39;$.name1&#39;);</span><br></pre></td></tr></table></figure></li></ul><ul><li>explain<ul><li>select_type，有几种值：simple（表示简单的select，没有union和子查询），primary（有子查询，最外面的select查询就是primary），union（union中的第二个或随后的select查询，不依赖外部查询结果），dependent union（union中的第二个或随后的select查询，依赖外部查询结果）</li><li>type，有几种值：system（表仅有一行（=系统表），这是const连接类型的一个特例），const（常量查询）, ref(非唯一索引访问，只有普通索引)，eq_ref（使用唯一索引或组件查询），all（全表查询），index（根据索引查询全表），range（范围查询）</li><li>possible_keys: 表中可能帮助查询的索引</li><li>key，选择使用的索引</li><li>key_len，使用的索引长度</li><li>rows，扫描的行数，越大越不好</li><li>extra，有几种值：Only index（信息从索引中检索出，比扫描表快），where used（使用where限制），Using filesort （可能在内存或磁盘排序），Using temporary（对查询结果排序时使用临时表）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试的东东</title>
      <link href="/daily/20190515/"/>
      <url>/daily/20190515/</url>
      
        <content type="html"><![CDATA[<h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ul><li>leetcode <a href="http://leetcode.com/">http://leetcode.com/</a></li><li>careerup <a href="http://www.careercup.com/">http://www.careercup.com/</a> <a id="more"></a></li><li><a href="http://hawstein.com/posts/ctci-solutions-contents.html">http://hawstein.com/posts/ctci-solutions-contents.html</a></li><li>glassdoor <a href="http://www.glassdoor.com/index.htm">http://www.glassdoor.com/index.htm</a></li><li>topcoder <a href="http://www.topcoder.com/">http://www.topcoder.com/</a></li><li>zoj <a href="http://acm.zju.edu.cn/onlinejudge/">http://acm.zju.edu.cn/onlinejudge/</a></li><li>july的博客 <a href="http://blog.csdn.net/v_july_v/article/details/6543438">http://blog.csdn.net/v_july_v/article/details/6543438</a></li><li>mitbbs <a href="http://www.mitbbs.com/bbsdoc/JobHunting.html">http://www.mitbbs.com/bbsdoc/JobHunting.html</a></li><li>poj <a href="http://poj.org/">http://poj.org/</a></li><li>杭电acm <a href="http://acm.hdu.edu.cn/">http://acm.hdu.edu.cn/</a></li><li>codeforces<a href="http://codeforces.com/">http://codeforces.com/</a></li><li>复杂数据结构的讲解及实现 GeeksForGeeks： <a href="http://www.geeksforgeeks.org/">http://www.geeksforgeeks.org/</a></li><li>一个比较牛逼的coding challenge网站： <a href="https://www.hackerrank.com/">https://www.hackerrank.com/</a></li></ul><h4 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h4><ul><li>面向对象的特征：继承、封装和多态</li><li>int 和 Integer 有什么区别；Integer的值缓存范围</li><li>说说反射的用途及实现</li><li>Http 请求的 GET 和 POST 方式的区别</li><li>MVC设计思想</li><li>什么是Java序列化和反序列化；如何实现Java序列化；或者请描述</li><li>Serializable接口的作用</li><li>重载和重写的区别</li></ul><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><ul><li>线程和进程的概念</li><li>并行和并发的概念</li><li>创建线程的方式及实现</li><li>进程间通信的方式</li><li>说说 CountDownLatch、CyclicBarrier 原理和区别</li><li>说说 Semaphore 原理</li><li>说说 Exchanger 原理</li><li>ThreadLocal 原理分析；ThreadLocal为什么会出现OOM，出现的深</li></ul><h4 id="层次原理"><a href="#层次原理" class="headerlink" title="层次原理"></a>层次原理</h4><ul><li>讲讲线程池的实现原理</li><li>线程池的几种实现方式 </li><li>线程的生命周期；状态是如何转移的</li></ul><h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><ul><li>什么是线程安全？如何保证线程安全？</li><li>重入锁的概念；重入锁为什么可以防止死锁？</li><li>产生死锁的四个条件</li><li>如何检查死锁</li><li>volatile 实现原理</li><li>synchronized 实现原理（对象监视器）</li><li>synchronized 与 lock 的区别</li><li>AQS 同步队列</li><li>CAS 无锁的概念；乐观锁和悲观锁</li><li>常见的原子操作类</li><li>什么是 ABA 问题；出现 ABA 问题 JDK 是如何解决的</li><li>乐观锁的业务场景及实现方式</li><li>Java 8 并发包下常见的并发类</li><li>偏向锁、轻量级锁、重量级锁、自旋锁的概念</li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li>DDL、DML、DCL 分别指什么</li><li>explain 命令</li><li>脏读、幻读、不可重复读</li><li>事务的隔离级别</li><li>数据库的几大范式</li><li>说说分库与分表设计</li><li>分库与分表带来的分布式困境与对应之策</li><li>说说 SQL 优化之道</li><li>存储引擎的 InnoDB 与 MyISAM 区别、优缺点、使用场景</li><li>索引类别（B+树索引、全文索引、哈希索引）；索引的区别</li><li>什么是自适应哈希索引（AHI）</li><li>为什么要用 B+tree 作为 MySql 索引的数据结构</li><li>聚集索引与非聚集索引的区别</li><li>limit 20000 加载很慢怎么解决</li><li>常见的几种分布式 ID 的设计方案</li></ul><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul><li>JVM 运行时内存区域划分</li><li>常见的 GC 回收算法及其含义</li><li>常见的 JVM 性能监控和故障处理工具类</li><li>JVM 性能调优</li><li>类加载器、双亲委派模型</li><li>类加载的过程</li><li>强引用、软引用、弱引用、虚引用</li><li>Java 内存模型 JMM</li></ul><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对上面的内容做了准备后，我开始投简历面试，先从小公司开始面，小公司一般 1-2面技术，大公司 3-5 轮技术，一般都是一面基础，二面进阶，三面优化和场景，四面问规划，五面hr.</p></blockquote><h4 id="学习方式"><a href="#学习方式" class="headerlink" title="学习方式"></a>学习方式</h4><ul><li>看面试题 <ul><li>正常人第一步肯定都会看面试题，我也不例外，在看的过程中，我发现有些文章写的不错，对我帮助不小值得推荐 。</li></ul></li><li>对问题深入理解 <ul><li>在看面试题的过程，你会遇到一些自己没接触过的或者以前没深入学习过的知识，例如最常问的HashMap内部实现原理，这就促使你得开始去看jdk的源码或者是学习一些新的东西。看源码是很重要的一步，起步很难，但是会让你收益良多。</li></ul></li><li>熟悉项目的代码和需求<ul><li>把项目中不错的需求拿出来，看会，代码熟悉好，将整个功能的流程和涉及的东西吃透。项目是面试中必问的环节，一般是以一个功能点为基础展开问，因此你必须对这个功能有很深的认识，不能有模糊的地方。如果有时间，能把涉及到的知识点也搞懂最好。 </li></ul></li><li>网上做题和刷题<ul><li>头条会远程面试， 一般会做题。建议去本文开头的一些刷题网站多做些题目。</li></ul></li><li>总结记录 <ul><li>把自己每天学到的内容记录下来，可以让自己更有动力的复习，技术是一个枯燥的过程，你必须让自己时刻保持有动力。 </li></ul></li></ul><h4 id="投简历、约面试环节"><a href="#投简历、约面试环节" class="headerlink" title="投简历、约面试环节"></a>投简历、约面试环节</h4><ul><li>投简历渠道<ul><li>BOSS直聘、猎聘网。拉钩等（一般不靠谱），找靠谱猎头也行。</li></ul></li><li>简历不要海投 <ul><li>为两个情况。 </li><li>没有社招面试经验：建议采取海投的方式，只要职位要求跟自己比较匹配都可以投，累计面试经验。</li><li>社招面试经验已经足够：投那些职位匹配、公司满意的职位。公司评价可以去看准网，企业查等。</li></ul></li><li>投简历没下文<ul><li>简历确实亮点不多，学历不好，项目不行，容易被HR给刷掉，因此他们看得最直接的就是你上家的公司和你毕业的学校，如果你不是从牛逼的公司/学校出来，可能会碰到和我一样的情况，应对的办法就是多投。</li></ul></li><li>一天约几家面试合适？ <ul><li>最理想的情况为2家面试，上午一般在10点左右，下午一般在2点左右。建议把理想的公司放下午，因为下午的时间比较充足，可以让公司更充分的了解你。我开始面的时候，每次都是上午面的不好，下午面的不错。 </li></ul></li><li>是否该裸辞？ <ul><li>我一开始是边上班边投，然后利用调休时间，或者请假去面试。后来，面试机会越来越多，请假太频繁了，自己都不好意思了，并且自己也已经有足够的信心，这个时候我选择了裸辞。</li></ul></li><li>注意事项 <ul><li>千万别迟到。 </li><li>做好特殊情况处理，带简历、充电宝、纸巾、伞。 </li></ul></li></ul><blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;裸辞还有一个原因是，在面试过程中你会发现，遇到公司要人紧急的，如果你的入职流程过长可能错过这个公司。 </p></blockquote><h4 id="面试现场"><a href="#面试现场" class="headerlink" title="面试现场"></a>面试现场</h4><ul><li>笔试常见的问题 <ul><li>面试常见的问题上面给的面试题链接基本都有。</li><li>手写代码：手写代码一般考单例、排序、线程、消费者生产者 排序。</li><li>写SQL很常考察group by、内连接和外连接</li></ul></li><li>面试1-5面总结 <ul><li>让你自我介绍 </li><li>做两道算法题（刷题必中）</li><li>问Java基础知识 </li><li>java 高级进阶就是我准备的那些</li><li>问项目中指责和做了什么</li><li>业务情景问题，例如：你的一个功能上了生产环境后，服务器压力骤增，该怎么排查。 </li><li>对职业的规划</li><li>你有什么想问面试官的 </li><li>问期望待遇</li></ul></li><li>常问的知识要点<ul><li>集合相关问题（必问）： </li><li>线程相关问题（必问）：  </li><li>JVM相关问题（必问）：</li><li>设计模式相关问题（必问）： </li><li>数据库相关问题，针对Mysql（必问）： </li><li>主流框架相关问题：  </li><li>Spring的设计模式。 </li><li>Spring中AOP。 </li><li>Spring注入bean的方式。 </li><li>什么是IOC，什么是依赖注入。 </li><li>Spring是单例还是多例，怎么修改。 </li><li>Spring事务隔离级别和传播性。 </li><li>介绍下Mybatis/Hibernate的缓存机制。 </li><li>Mybatis的mapper文件中#和$的区别。 </li><li>Mybatis的mapper文件中resultType和resultMap的区别。 </li><li>Hibernate和Mybatis的区别。 </li><li>Spring MVC和Struts2的区别。</li><li>Mybatis中DAO层接口没有写实现类，Mapper中的方法和DAO接口方法是怎么绑定到一起的，其内部是怎么实现的。 </li></ul></li><li>其他遇到问题： <ul><li>介绍下B树、二叉树。 </li><li>IO和NIO的区别。 </li><li>重载和重写的区别。 </li><li>栈和队列。 </li><li>接口和抽象类的区别。 </li><li>int和Integer的自动拆箱/装箱相关问题。 常量池相关问题。 </li><li>==和equals的区别。 </li><li>String和StringBuilder、StringBuffer的区别。 </li><li>静态变量、实例变量、局部变量线程安全吗，为什么。</li><li>try、catch、finally都有return语句时执行哪个。 </li><li>分布式锁的实现。 </li><li>分布式session存储解决方案。 </li><li>常用的linux命令。</li></ul></li></ul><h4 id="Offer-流程"><a href="#Offer-流程" class="headerlink" title="Offer 流程"></a>Offer 流程</h4><ul><li>面试通过当然还有一些后续的环节<ul><li>提交工资流水（大点的公司），学历，学位照片。</li><li>定薪</li><li>体检通知</li><li>背调 发offer。</li><li>入职材料 选择入职日期。</li></ul></li></ul><h4 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h4><ul><li>千万别裸辞，别裸辞，别裸辞 我同事裸辞了，2个月了到现在还没找到工作。</li><li>先投一些普通的小公司，等面出感觉了再去面大公司。 </li><li>自己不会的技术简历不要写 </li><li>很多公司压待遇，期望待遇适当提高。 </li><li>不要去实习期6个月还打8折的公司，除非你没有其他选择了，否则不要去。</li><li>不要去参加很多大大小小的招聘会，纯粹是浪费时间。 </li><li>把面试当作一次技术的交流，不要太在意是否能被录取。 就当学习。</li><li>公司一般面完就决定是否录取了，让你回去等消息这种情况一般没戏，感觉良好也没用。</li><li>地方远的尽量通过电话面试，不然白跑。 </li><li>面试冲刺阶段，要保持每天学习，无论是学习新东西还是复习旧东西。 </li><li>无论好的坏的公司，先拿到offer再说，最后看看自己这个公司自己是否值得去。</li><li>通过面试体验和面试官的风格 可以大概判断入职团队的情况。 </li><li>拉勾投的简历很多会被筛掉，但是拉勾还是面试机会的最主要来源。 </li><li>理想的公司可以多投几次，不同部门要求不一样。</li><li>问到自己有深入研究过的知识，抓住机会好好表现，吹是必须的，不要轻易错过吹得机会。 </li><li>大公司可以走猎头渠道，谈待遇靠谱一点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嘿嘿嘿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看到的题，记录一下</title>
      <link href="/daily/20190427/"/>
      <url>/daily/20190427/</url>
      
        <content type="html"><![CDATA[<p><a href="http://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485167&amp;idx=1&amp;sn=a35fad235a6bb2b6e31f1ff37e72bfd7&amp;chksm=cea24924f9d5c032cbbeffc87cd366e9aa7b209897a26ad5c7f7b1b766b3c34a2c9b6870006c&amp;mpshare=1&amp;scene=1&amp;srcid=#rd">http://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485167&amp;idx=1&amp;sn=a35fad235a6bb2b6e31f1ff37e72bfd7&amp;chksm=cea24924f9d5c032cbbeffc87cd366e9aa7b209897a26ad5c7f7b1b766b3c34a2c9b6870006c&amp;mpshare=1&amp;scene=1&amp;srcid=#rd</a></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo指令</title>
      <link href="/daily/20190328/"/>
      <url>/daily/20190328/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />### init<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。<a id="more"></a>### new<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [folder]</span><br></pre></td></tr></table></figure>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成静态文件。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li>-d, –deploy    文件生成后立即部署网站</li><li>-w, –watch    监视文件变动</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该命令可以简写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo g -w 常用这个</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发表草稿。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><h4 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h4><ul><li>-p, –port    重设端口</li><li>-s, –static    只使用静态文件</li><li>-l, –log    启动日记记录，使用覆盖记录格式</li></ul><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;部署网站。</p><h4 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h4><ul><li>-g, –generate    部署之前预先生成静态文件</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该命令可以简写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;渲染文件。</p><h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><ul><li>-o, –output    设置输出路径</li></ul><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从其他博客系统 迁移内容。</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显示 Hexo 版本。</p><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;隐藏终端信息。</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --config custom.yml</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义配置文件的路径，执行后将不再使用 _config.yml。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显示 source/_drafts 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义当前工作目录（Current working directory）的路径。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github上传限制</title>
      <link href="/daily/20190313/"/>
      <url>/daily/20190313/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />github 限制在1G，单个文件不能超过100M，有50M的文件，就会警告了。所以上传的时候把编译的之后生成的东西去掉，对大文件进行拆分。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">du -h xxxx</span><br><span class="line">spilt -b 200M xxxx</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言第二版</title>
      <link href="/assembly/20190312/"/>
      <url>/assembly/20190312/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" />汇编语言第二版，照片版，有点坑，凑合看https://github.com/snmlm/Assembly-Language-Second-Edition<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Assembly-Language-Second-Edition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Books </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀、中缀、后缀表达式(逆波兰表达式)</title>
      <link href="/algorithm/20190507/"/>
      <url>/algorithm/20190507/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前缀表达式、中缀表达式、后缀表达式都是四则运算的表达方式,用以四则运算表达式求值,即数学表达式的求职。<a id="more"></a></p><h3 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中缀表达式就是常见的运算表达式，如(3+4)×5-6</p><h3 id="前缀表达式"><a href="#前缀表达式" class="headerlink" title="前缀表达式"></a>前缀表达式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如:- + 1 × + 2 3 4 5</p><h4 id="中缀转前缀"><a href="#中缀转前缀" class="headerlink" title="中缀转前缀"></a>中缀转前缀</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如:1+((2+3)×4)-5具体过程，如下表</p><table><thead><tr><th>扫描到的元素</th><th>S2(栈底-&gt;栈顶)</th><th>S1 (栈底-&gt;栈顶)</th><th>说明</th></tr></thead><tbody><tr><td>5</td><td>5</td><td>空</td><td>数字，直接入栈</td></tr><tr><td>-</td><td>5</td><td>-</td><td>s1为空，运算符直接入栈</td></tr><tr><td>)</td><td>5</td><td>-)</td><td>右括号直接入栈</td></tr><tr><td>4</td><td>5 4</td><td>-)</td><td>数字直接入栈</td></tr><tr><td>x</td><td>5 4</td><td>-)x</td><td>s1栈顶是右括号，直接入栈</td></tr><tr><td>)</td><td>5 4</td><td>-)x)</td><td>右括号直接入栈</td></tr><tr><td>3</td><td>5 4 3</td><td>-)x)</td><td>数字</td></tr><tr><td>+</td><td>5 4 3</td><td>-)x)+</td><td>s1栈顶是右括号，直接入栈</td></tr><tr><td>2</td><td>5 4 3 2</td><td>-)x)+</td><td>数字</td></tr><tr><td>(</td><td>5 4 3 2 +</td><td>-)x</td><td>左括号，弹出运算符直至遇到右括号</td></tr><tr><td>(</td><td>5 4 3 2 + x</td><td>-</td><td>同上</td></tr><tr><td>+</td><td>5 4 3 2 + x</td><td>-+</td><td>优先级与-相同，入栈</td></tr><tr><td>1</td><td>5 4 3 2 + x 1</td><td>-+</td><td>数字</td></tr><tr><td>到达最左端</td><td>5 4 3 2 + x 1 + -</td><td>空</td><td>s1剩余运算符</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果是:“- + 1 × + 2 3 4 5”</td><td></td><td></td><td></td></tr></tbody></table><h4 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果。</p><h3 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如:1 2 3 + 4 × + 5 -</p><h4 id="中缀转后缀"><a href="#中缀转后缀" class="headerlink" title="中缀转后缀"></a>中缀转后缀</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下：</p><table><thead><tr><th>扫描到的元素</th><th>s2(栈底-&gt;栈顶)</th><th>s1 (栈底-&gt;栈顶)</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>空</td><td>数字，直接入栈</td></tr><tr><td>+</td><td>1</td><td>+</td><td>s1为空，运算符直接入栈</td></tr><tr><td>(</td><td>1</td><td>+ (</td><td>左括号，直接入栈</td></tr><tr><td>(</td><td>1</td><td>+ ( (</td><td>同上</td></tr><tr><td>2</td><td>1 2</td><td>+ ( (</td><td>数字</td></tr><tr><td>+</td><td>1 2</td><td>+ ( ( +</td><td>s1栈顶为左括号，运算符直接入栈</td></tr><tr><td>3</td><td>1 2 3</td><td>+ ( ( +</td><td>数字</td></tr><tr><td>)</td><td>1 2 3 +</td><td>+ (</td><td>右括号，弹出运算符直至遇到左括号</td></tr><tr><td>×</td><td>1 2 3 +</td><td>+ ( ×</td><td>s1栈顶为左括号，运算符直接入栈</td></tr><tr><td>4</td><td>1 2 3 + 4</td><td>+ ( ×</td><td>数字</td></tr><tr><td>)</td><td>1 2 3 + 4 ×</td><td>+</td><td>右括号，弹出运算符直至遇到左括号</td></tr><tr><td>-</td><td>1 2 3 + 4 × +</td><td>-</td><td>-与+优先级相同，因此弹出+，再压入-</td></tr><tr><td>5</td><td>1 2 3 + 4 × + 5</td><td>-</td><td>数字</td></tr><tr><td>到达最右端</td><td>1 2 3 + 4 × + 5 -</td><td>空</td><td>s1中剩余的运算符</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此结果为“1 2 3 + 4 × + 5 -”</td><td></td><td></td><td></td></tr></tbody></table><h4 id="计算方式-1"><a href="#计算方式-1" class="headerlink" title="计算方式"></a>计算方式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大常见排序</title>
      <link href="/algorithm/20190423/"/>
      <url>/algorithm/20190423/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;十种常见排序算法可以分为两大类：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </p><a id="more"></a><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/t4Yf88B.png"><br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/NtSgA4y.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相关概念</p><ul><li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li><li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li><li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li><li>空间复杂度：是指算法在计算机<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内执行时所需存储空间的度量，它也是数据规模n的函数。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下排序默认为从小到大</li></ul><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><h4 id="动图"><a href="#动图" class="headerlink" title="动图"></a>动图</h4><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/LflQ4hR.gif"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int[] bubbleSort(int[] arr)&#123;</span><br><span class="line">    int temp &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; arr.length - 1 -i; j++) &#123;</span><br><span class="line">            if(arr[j]&gt;arr[j+1])&#123;&#x2F;&#x2F;相邻元素比较</span><br><span class="line">                &#x2F;&#x2F;元素交换</span><br><span class="line">                temp &#x3D; arr[j];</span><br><span class="line">                arr[j] &#x3D; arr[j+1];</span><br><span class="line">                arr[j+1] &#x3D; temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ol><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ol><h4 id="动图-1"><a href="#动图-1" class="headerlink" title="动图"></a>动图</h4><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/V6A4FXQ.gif"></p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int[] selectionSort(int[] arr)&#123;</span><br><span class="line">    int minIndex &#x3D; 0;</span><br><span class="line">    int temp &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;</span><br><span class="line">        minIndex &#x3D; i;</span><br><span class="line">        for (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">            if(arr[minIndex] &gt; arr[j])&#123;</span><br><span class="line">                minIndex &#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[minIndex];</span><br><span class="line">        arr[minIndex] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><h4 id="动图-2"><a href="#动图-2" class="headerlink" title="动图"></a>动图</h4><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/oOHqAtb.gif"></p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static int[] insertionSort(int[] arr)&#123;</span><br><span class="line">    int perIndex,current;&#x2F;&#x2F;默认是0</span><br><span class="line">    for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;&#x2F;&#x2F;从1开始</span><br><span class="line">        perIndex &#x3D; i-1;</span><br><span class="line">        current &#x3D; arr[i];</span><br><span class="line">        while(perIndex &gt; 0 &amp;&amp; arr[perIndex] &gt; current)&#123;</span><br><span class="line">            arr[perIndex+1] &#x3D; arr[perIndex];</span><br><span class="line">            perIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[perIndex+1] &#x3D; current;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ol><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><h4 id="动图-3"><a href="#动图-3" class="headerlink" title="动图"></a>动图</h4><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/FHvx8s2.gif"></p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static int[] shellSort(int[] arr) &#123;</span><br><span class="line">    int tempIndex,current;</span><br><span class="line">    for (int i &#x3D; arr.length % 2; i &gt; 0; i &#x3D; i % 2) &#123;</span><br><span class="line">        for (int j &#x3D; i; j &lt; arr.length; j++) &#123;</span><br><span class="line">            tempIndex &#x3D; j;</span><br><span class="line">            current &#x3D; arr[j];</span><br><span class="line">            while(tempIndex - i &gt;&#x3D; 0 &amp;&amp; current &lt; arr[tempIndex-i])&#123;</span><br><span class="line">                arr[tempIndex] &#x3D; arr[tempIndex-i];</span><br><span class="line">                tempIndex &#x3D; tempIndex - i;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[tempIndex] &#x3D; current;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。</p><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><ol><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ol><h4 id="动图-4"><a href="#动图-4" class="headerlink" title="动图"></a>动图</h4><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/bNjG7P0.gif"></p><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static int[] mergeSort(int[] arr) &#123;</span><br><span class="line">    if (arr.length &lt; 2)</span><br><span class="line">        return arr;</span><br><span class="line">    int[] temp &#x3D; new int[arr.length];</span><br><span class="line">    mergeSort_s(arr,0,arr.length-1,temp);</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void mergeSort_s(int[] arr, int left, int right, int[] temp) &#123;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        int mid &#x3D; arr.length % 2;</span><br><span class="line">        mergeSort_s(arr, left, mid, temp);&#x2F;&#x2F; 左边归并排序，使得左子序列有序</span><br><span class="line">        mergeSort_s(arr, mid + 1, right, temp);&#x2F;&#x2F; 右边归并排序，使得右子序列有序</span><br><span class="line">        merge(arr, left, mid, right, temp);&#x2F;&#x2F; 将两个有序子数组合并操作</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123;</span><br><span class="line">    int i &#x3D; left;&#x2F;&#x2F; 左序列指针</span><br><span class="line">    int j &#x3D; mid + 1;&#x2F;&#x2F; 右序列指针</span><br><span class="line">    int t &#x3D; 0;&#x2F;&#x2F; 临时数组指针</span><br><span class="line">    while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; right) &#123;</span><br><span class="line">        if (arr[i] &lt;&#x3D; arr[j]) &#123;</span><br><span class="line">            temp[t++] &#x3D; arr[i++];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            temp[t++] &#x3D; arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while (i &lt;&#x3D; mid) &#123;&#x2F;&#x2F; 将左边剩余元素填充进temp中</span><br><span class="line">        temp[t++] &#x3D; arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while (j &lt;&#x3D; right) &#123;&#x2F;&#x2F; 将右序列剩余元素填充进temp中</span><br><span class="line">        temp[t++] &#x3D; arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    t &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 将temp中的元素全部拷贝到原数组中</span><br><span class="line">    while (left &lt;&#x3D; right) &#123;</span><br><span class="line">        arr[left++] &#x3D; temp[t++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h3 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><h4 id="动图-5"><a href="#动图-5" class="headerlink" title="动图"></a>动图</h4><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/LiYKQqH.gif"></p><h4 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public static int[] quickSort(int[] arr) &#123;</span><br><span class="line">    return quickSort_s(arr, 0, arr.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static int[] quickSort_s(int[] arr, int left, int right) &#123;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        int partitionIndex &#x3D; partition(arr, left, right);</span><br><span class="line">        quickSort_s(arr,left,partitionIndex-1);</span><br><span class="line">        quickSort_s(arr,partitionIndex+1,right);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 分区操作</span><br><span class="line"> * </span><br><span class="line"> * @param arr</span><br><span class="line"> * @param left</span><br><span class="line"> * @param right</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static int partition(int[] arr, int left, int right) &#123;</span><br><span class="line">    int pivot &#x3D; left;&#x2F;&#x2F; 设定基准值（pivot）</span><br><span class="line">    int index &#x3D; pivot + 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - 1);</span><br><span class="line">    return index - 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(int[] arr, int left, int right) &#123;</span><br><span class="line">    int temp &#x3D; arr[left];</span><br><span class="line">    arr[left] &#x3D; arr[right];</span><br><span class="line">    arr[right] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。有大顶堆和小顶堆。</p><h4 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h4><ol><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ol><h4 id="动图-6"><a href="#动图-6" class="headerlink" title="动图"></a>动图</h4><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/sSkeVxn.gif"></p><h4 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static static void heapSort(int []arr)&#123;</span><br><span class="line">    &#x2F;&#x2F;1.构建大顶堆</span><br><span class="line">    for(int i&#x3D;arr.length&#x2F;2-1;i&gt;&#x3D;0;i--)&#123;</span><br><span class="line">        &#x2F;&#x2F;从第一个非叶子结点从下至上，从右至左调整结构</span><br><span class="line">        adjustHeap(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;2.调整堆结构+交换堆顶元素与末尾元素</span><br><span class="line">    for(int j&#x3D;arr.length-1;j&gt;0;j--)&#123;</span><br><span class="line">        swap(arr,0,j);&#x2F;&#x2F;将堆顶元素与末尾元素进行交换</span><br><span class="line">        adjustHeap(arr,0,j);&#x2F;&#x2F;重新对堆进行调整</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</span><br><span class="line"> * @param arr</span><br><span class="line"> * @param i</span><br><span class="line"> * @param length</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static static void adjustHeap(int []arr,int i,int length)&#123;</span><br><span class="line">    int temp &#x3D; arr[i];&#x2F;&#x2F;先取出当前元素i</span><br><span class="line">    for(int k&#x3D;i*2+1;k&lt;length;k&#x3D;k*2+1)&#123;&#x2F;&#x2F;从i结点的左子结点开始，也就是2i+1处开始</span><br><span class="line">        if(k+1&lt;length &amp;&amp; arr[k]&lt;arr[k+1])&#123;&#x2F;&#x2F;如果左子结点小于右子结点，k指向右子结点</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(arr[k] &gt;temp)&#123;&#x2F;&#x2F;如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span><br><span class="line">            arr[i] &#x3D; arr[k];</span><br><span class="line">            i &#x3D; k;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] &#x3D; temp;&#x2F;&#x2F;将temp值放到最终的位置</span><br><span class="line">&#125;</span><br><span class="line">public static void swap(int[] arr, int left, int right) &#123;</span><br><span class="line">    int temp &#x3D; arr[left];</span><br><span class="line">    arr[left] &#x3D; arr[right];</span><br><span class="line">    arr[right] &#x3D; temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数，即知道最大值和最小值。</p><h4 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h4><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ol><h4 id="动图-7"><a href="#动图-7" class="headerlink" title="动图"></a>动图</h4><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/9hAeYEl.gif"></p><h4 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int[] countingSort(int []arr,int min,int max)&#123;</span><br><span class="line">    int[] indexArr &#x3D; new int[max - min + 1];</span><br><span class="line">    &#x2F;&#x2F;0代表最小值，length代表最大值。</span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        indexArr[arr[i]-min] &#x3D; indexArr[arr[i]-min] + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int index &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; indexArr.length; i++) &#123;</span><br><span class="line">        while(indexArr[i] &gt; 0)&#123;</span><br><span class="line">            indexArr[i]--;</span><br><span class="line">            arr[index++] &#x3D; min + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h3 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）</p><h4 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h4><ol><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ol><h4 id="动图-8"><a href="#动图-8" class="headerlink" title="动图"></a>动图</h4><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/bI6BBDn.gif"></p><h4 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private static int[] bucketSort(int[] arr, int bucketSize)&#123;</span><br><span class="line">    if(arr.length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    int minValue &#x3D; arr[0];</span><br><span class="line">    int maxValue &#x3D; arr[0];</span><br><span class="line">    for (int value : arr) &#123;</span><br><span class="line">        if (value &lt; minValue) &#123;</span><br><span class="line">            minValue &#x3D; value;</span><br><span class="line">        &#125; else if (value &gt; maxValue) &#123;</span><br><span class="line">            maxValue &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;+1是针对除不尽的情况</span><br><span class="line">    int bucketCount &#x3D; (int) Math.floor((maxValue - minValue) &#x2F; bucketSize) + 1;</span><br><span class="line">    int[][] buckets &#x3D; new int[bucketCount][0];</span><br><span class="line">    &#x2F;&#x2F; 利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        int index &#x3D; (int) Math.floor((arr[i] - minValue) &#x2F; bucketSize);</span><br><span class="line">        buckets[index] &#x3D; arrAppend(buckets[index], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int arrIndex &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        int[] bucket &#x3D; buckets[i];</span><br><span class="line">        if (bucket.length &lt;&#x3D; 0) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 对每个桶进行排序，这里使用了计数也，需要知道最大值和最小值</span><br><span class="line">        bucket &#x3D; countingSort(bucket,minValue+i*bucketSize,minValue+(i+1)*bucketSize);</span><br><span class="line">        for (int value : bucket) &#123;</span><br><span class="line">            arr[arrIndex++] &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static int[] arrAppend(int[] arr, int value) &#123;</span><br><span class="line">    arr &#x3D; Arrays.copyOf(arr, arr.length + 1);</span><br><span class="line">    arr[arr.length - 1] &#x3D; value;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。可以充分的和计数排序相结合。</p><h3 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h4><ol><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ol><h4 id="动图-9"><a href="#动图-9" class="headerlink" title="动图"></a>动图</h4><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/3Fm14IR.gif"></p><h4 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param maxDigit 最大位数</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static int[] radixSort(int[] arr, int maxDigit)&#123;</span><br><span class="line">    int mod &#x3D; 10;</span><br><span class="line">    int dev &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; maxDigit; i++,dev*&#x3D;10) &#123;</span><br><span class="line">        &#x2F;&#x2F; 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span><br><span class="line">        int[][] counter &#x3D; new int[20][0];</span><br><span class="line">        for (int j &#x3D; 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            int bucket &#x3D; (arr[j]&#x2F;dev%mod)+mod;</span><br><span class="line">            counter[bucket] &#x3D; arrAppend(counter[bucket], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        int pos &#x3D; 0;</span><br><span class="line">        for (int[] bucket : counter) &#123;</span><br><span class="line">            for (int value : bucket) &#123;</span><br><span class="line">                arr[pos++] &#x3D; value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">private static int[] arrAppend(int[] arr, int value) &#123;</span><br><span class="line">    arr &#x3D; Arrays.copyOf(arr, arr.length + 1);</span><br><span class="line">    arr[arr.length - 1] &#x3D; value;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/algorithm/20190305/"/>
      <url>/algorithm/20190305/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。<a id="more"></a><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3></li><li>若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。</li></ul><p>这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p><h3 id="分治与动态规划"><a href="#分治与动态规划" class="headerlink" title="分治与动态规划"></a>分治与动态规划</h3><ul><li>共同点：二者都要求原问题具有最优子结构性质,都是将原问题分而治之,分解成若干个规模较小(小到很容易解决的程序)的子问题.然后将子问题的解合并,形成原问题的解.</li><li>不同点：分治法将分解后的子问题看成相互独立的，通过用递归来做。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;动态规划将分解后的子问题理解为相互间有联系,有重叠部分，需要记忆，通常用迭代来做。</p><h3 id="问题特征"><a href="#问题特征" class="headerlink" title="问题特征"></a>问题特征</h3><ul><li>最优子结构：当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</li><li>重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>描述最优解的结构</li><li>递归定义最优解的值</li><li>按自底向上的方式计算最优解的值</li><li>由计算出的结果构造一个最优解</li></ul><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><h4 id="题目01-基本背包问题"><a href="#题目01-基本背包问题" class="headerlink" title="题目01 基本背包问题"></a>题目01 基本背包问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用子问题定义状态：即<code>f[i][v]</code>表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：<code>f[i][v]=max&#123;f[i-1][v],f[i-1][v-c[i]]+w[i]&#125;</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为<code>v-c[i]</code>的背包中”，此时能获得的最大价值就是<code>f [i-1][v-c[i]]</code>再加上通过放入第i件物品获得的价值<code>w[i]</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意<code>f[i][v]</code>有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是<code>f[N] [V]</code>，而是<code>f[N][0..V]</code>的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项<code>f[i][v-1]</code>，这样就可以保证<code>f[N] [V]</code>就是最后的答案。至于为什么这样就可以，由你自己来体会了。 </p><h5 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上方法的时间和空间复杂度均为<code>O(N*V)</code>，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到<code>O(V)</code>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组<code>f[i][0..V]</code>的所有值。那么，如果只用一个数组<code>f [0..V]</code>，能不能保证第i次循环结束后<code>f[v]</code>中表示的就是我们定义的状态<code>f[i][v]</code>呢？<code>f[i][v]</code>是由<code>f[i-1][v]</code>和<code>f[i-1] [v-c[i]]</code>两个子问题递推而来，能否保证在推<code>f[i][v]</code>时（也即在第i次主循环中推<code>f[v]</code>时）能够得到<code>f[i-1][v]</code>和<code>f[i-1][v -c[i]]</code>的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推<code>f[v]</code>，这样才能保证推<code>f[v]时f[v-c[i]]</code>保存的是状态<code>f[i -1][v-c[i]]</code>的值。伪代码如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i&#x3D;1..N </span><br><span class="line">for v&#x3D;V..0 </span><br><span class="line">f[v]&#x3D;max&#123;f[v],f[v-c[i]]+w[i]&#125;; </span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的<code>f[v]=max&#123;f[v],f[v-c[i]]&#125;</code>一句恰就相当于我们的转移方程<code>f[i][v]=max&#123;f[i-1][v],f[i- 1][v-c[i]]&#125;</code>，因为现在的<code>f[v-c[i]]</code>就相当于原来的<code>f[i-1][v-c[i]]</code>。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了<code>f[i][v]</code>由<code>f[i][v-c[i]]</code>推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 </p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。</p><h4 id="题目02-完全背包问题"><a href="#题目02-完全背包问题" class="headerlink" title="题目02 完全背包问题"></a>题目02 完全背包问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </p><h5 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令<code>f[i][v]</code>表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：<code>f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;= v&#125;</code>。这跟01背包问题一样有<code>O(N*V)</code>个状态需要求解，但求解每个状态的时间则不是常数了，求解状态<code>f[i][v]</code>的时间是<code>O(v/c[i])</code>，总的复杂度是超过<code>O(VN)</code>的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。</p><h5 id="一个简单有效的优化"><a href="#一个简单有效的优化" class="headerlink" title="一个简单有效的优化"></a>一个简单有效的优化</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足<code>c[i]&lt;=c[j]</code>且<code>w[i]&gt;=w[j]</code>，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。</p><h5 id="转化为01背包问题求解"><a href="#转化为01背包问题求解" class="headerlink" title="转化为01背包问题求解"></a>转化为01背包问题求解</h5><p>既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选<code>V/c [i]</code>件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。</p><h5 id="更高效的转化方法"><a href="#更高效的转化方法" class="headerlink" title="更高效的转化方法"></a>更高效的转化方法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把第i种物品拆成费用为<code>c[i]*2^k</code>、价值为<code>w[i]*2^k</code>的若干件物品，其中k满足<code>c[i]*2^k&lt;V</code>。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成<code>O(log(V/c[i]))</code>件物品，是一个很大的改进。但我们有更优的<code>O(VN)</code>的算法。<code> * O(VN)</code>的算法这个算法使用一维数组，先看伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i&#x3D;1..N </span><br><span class="line">for v&#x3D;0..V </span><br><span class="line">f[v]&#x3D;max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态<code>f[i][v]</code>是由状态<code>f[i-1][v-c[i]]</code>递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果<code>f[i-1][v-c[i]]</code>。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果<code>f[i][v-c[i]]</code>，所以就可以并且必须采用v= 0..V的顺序循环。这就是这个简单的程序为何成立的道理。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：<code>f[i][v]=max&#123;f[i-1][v],f[i][v-c[i]]+w[i]&#125;</code>，将这个方程用一维数组实现，便得到了上面的伪代码。 </p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“<code>O(VN)</code>的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。 </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇总</title>
      <link href="/HZ/"/>
      <url>/HZ/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><a id="more"></a>## java### 基础类型<a href="#">Post not found: daily/20200508</a>byte（1），short（2），char（2），int（4），long（8），float（4），double（8），从左向右自动转换，从右向左强制转换会精度损失，要加0.5 四舍五入### 枚举enum单例模式的一种### 引用类型1、<a href="#">Post not found: daily/20200817 String</a>2、数组3、自定义对象&nbsp;&nbsp;&nbsp;&nbsp;a、runnable class（）主类（运行类）含有main方法，可以直接执行&nbsp;&nbsp;&nbsp;&nbsp;b、java bean（） （不含有main方法，构造方法，set get 方法）&nbsp;&nbsp;&nbsp;&nbsp;c、POJO对象（简单的java对象，只含有set get方法）### 强引用,软引用,弱引用,虚引用### 面向对象 1、封装（维护性）：隐藏成员变量和方法，隐藏共能实现的具体细节2、继承（可扩展性）：子类继承父类的变量或者方法，也可以定义自己的 <a href="#">Post not found: daily/20200701</a>3、多态（灵活性）：父类的引用指向子类的实力（上转型对象）### 运算符1、位运算符&nbsp;&nbsp;&nbsp;&nbsp;位运算在java速度是最快的2、运算符优先级，<a href="#">Post not found: daily/20190507</a>### 循环1、for2、foreach3、do while4、while5、递归&nbsp;&nbsp;&nbsp;&nbsp;a、构造方法不能递归、&nbsp;&nbsp;&nbsp;&nbsp;b、必须有出口，if判断，否则死循环（肯定内存溢出）&nbsp;&nbsp;&nbsp;&nbsp;c、次数不易过多，否则会出现内存溢出&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;递归解决问题的思想：（大->小）,将大问题拆成小问题6、goto(无用，字段保留)### 关键字1、transient（在对象序列化的时候，如果某个属性不想被序列化就是该关键字修饰）2、abstract：&nbsp;&nbsp;&nbsp;&nbsp;a、修饰类（被他修饰的类为抽象类）&nbsp;&nbsp;&nbsp;&nbsp;b、修饰方法（权限：public protected，抽象方法不能有方法体）3、final：&nbsp;&nbsp;&nbsp;&nbsp;a、修饰类：不能有子类&nbsp;&nbsp;&nbsp;&nbsp;b、修饰方法：不能被重写 （不能修饰抽象方法）&nbsp;&nbsp;&nbsp;&nbsp;c、修饰变量：常量（要赋初始值）&nbsp;&nbsp;&nbsp;&nbsp;d、finally <a href="#">Post not found: daily/20200702</a>&nbsp;&nbsp;&nbsp;&nbsp;e、finalize() <a href="#">Post not found: daily/GcAndFinalize</a>4、implements：实现接口5、static：&nbsp;&nbsp;&nbsp;&nbsp;a、修饰类：（内部类）&nbsp;&nbsp;&nbsp;&nbsp;b、静态变量是属于类的，对象共享&nbsp;&nbsp;&nbsp;&nbsp;c、修饰方法：静态方法只能调用的静态的东西6、instanceof：&nbsp;&nbsp;&nbsp;&nbsp;a instanceof A：判断对象a是不是类A及其子类创建的实力### 对象的序列化和反序列化1、序列化：将对象以二进制的形式存储到硬盘中2、反序列化：将以二进制形式的对象读取到内存中要求：被序列化的对象必须要实现Serializable（标记接口）接口transient标记不被序列化的字段，SerializableID没有的话，反序列化会失败### 泛型1、泛型类2、泛型接口3、泛型方法4、泛型引用&nbsp;&nbsp;&nbsp;&nbsp;a、extends&nbsp;&nbsp;&nbsp;&nbsp;b、supper### Collection&lt;E&gt;1、List&nbsp;&nbsp;&nbsp;&nbsp;a、ArrayList：实现了RandomAccess接口，for循环比foreach快，数组实现，无参构造，初始0，add的时候才会初始为10，阀值是当前上限，扩充为x+(x>>1)，约为1.5倍，有参构造跟0比较，大于0，初始填值，小于0，报错IllegalArgumentException，remove的时候注意数据移动，倒叙删除，迭代器，转Set，<a href="#">Post not found: daily/20190417</a>&nbsp;&nbsp;&nbsp;&nbsp;b、Linkedlist：双向链表实现2、Set&nbsp;&nbsp;&nbsp;&nbsp;a、HashSet：对象必须重写hashCode方法，对象必须重写equals方法，链表实现&nbsp;&nbsp;&nbsp;&nbsp;b、TreeSet：对象必须实现Comparable接口的子类型，二叉树实现3、Queue&nbsp;&nbsp;&nbsp;&nbsp;没有实现的阻塞接口的LinkedList：实现了java.util.Queue接口和java.util.AbstractQueue接口### Map&lt;K,V&gt;1、HashMap&nbsp;&nbsp;&nbsp;&nbsp;<a href="#">Post not found: daily/20190501</a>2、TreeMap&nbsp;&nbsp;&nbsp;&nbsp;自带红黑树（R-B tree）### 工具类1、Arrays&nbsp;&nbsp;&nbsp;&nbsp;对数组的工具类2、Collections（实现Collection的集合）&nbsp;&nbsp;&nbsp;&nbsp;a、binarySearch-折半查找&nbsp;&nbsp;&nbsp;&nbsp;b、sort-排序，集合实现Comparable接口，默认ascll码比较。可重写Comparator&nbsp;&nbsp;&nbsp;&nbsp;c、copy-浅拷贝&nbsp;&nbsp;&nbsp;&nbsp;d、emptyXXX()-得到空容器&nbsp;&nbsp;&nbsp;&nbsp;e、max/min-获取最大/小元素，集合实现Comparable接口，默认ascll码比较。可重写Comparator&nbsp;&nbsp;&nbsp;&nbsp;f、replaceAll-新值替换旧值&nbsp;&nbsp;&nbsp;&nbsp;g、reverse-反转，集合实现Comparable接口，默认ascll码比较。可重写Comparator&nbsp;&nbsp;&nbsp;&nbsp;h、shuffle-随机乱序，实现用Random，伪随机，真随机可以参考时间&nbsp;&nbsp;&nbsp;&nbsp;i、syncronizedXXX-将线程不安全集合变成线程安全集合，装潢模式，创建一个syncronizedXXX新对象，内容指向原数据，所有方法添加syncronized关键字。常用于arraylist&nbsp;&nbsp;&nbsp;&nbsp;j、unmodifiableXXX-将可以修改的容器变成不可变容器，不变模式，创建一个unmodifiableXXX新对象，内容指向原数据，新对象所有修改数据的方法直接返回异常UnsupportedOperationException。常用于arraylist### 其他容器1、Vector&nbsp;&nbsp;&nbsp;&nbsp;Stack以Vector实现2、Dictonary&nbsp;&nbsp;&nbsp;&nbsp;已被map替代，过时接口。使用时必须静态使用3、BitSet&nbsp;&nbsp;&nbsp;&nbsp;long数组实现。不能存重复数据，按位处理。### 类加载1、类加载器（ClassLoader）&nbsp;&nbsp;&nbsp;&nbsp;a、加载：通过一个类的全限定名获取该类的二进制流，将该二进制流中的静态存储结构转化为方法去运行时数据结构，在内存中生成该类的 Class 对象，作为该类的数据访问入口&nbsp;&nbsp;&nbsp;&nbsp;b、加载&nbsp;&nbsp;&nbsp;&nbsp;c、连接-验证：文件格式验证：验证字节流是否符合 Class 文件的规范，元数据验证:对字节码描述的信息进行语义分析，字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证，符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行&nbsp;&nbsp;&nbsp;&nbsp;d、连接-准备：准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 &nbsp;&nbsp;&nbsp;&nbsp;e、连接-解析：该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后&nbsp;&nbsp;&nbsp;&nbsp;f、初始化：初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java &nbsp;&nbsp;&nbsp;&nbsp;g、使用&nbsp;&nbsp;&nbsp;&nbsp;h、卸载：停止之后，自动卸载。2、PDM（父亲委托机制）&nbsp;&nbsp;&nbsp;&nbsp;a、根加载器&nbsp;&nbsp;&nbsp;&nbsp;b、扩展加载器&nbsp;&nbsp;&nbsp;&nbsp;c、系统加载器3、获取Class对象方式&nbsp;&nbsp;&nbsp;&nbsp;a、类.class&nbsp;&nbsp;&nbsp;&nbsp;b、对象.getClass()&nbsp;&nbsp;&nbsp;&nbsp;c、Class.forName("类的完全限定名")### 反射1、Class类操作&nbsp;&nbsp;&nbsp;&nbsp;a、asSubclass(Class<U>clazz)-把传递的类的对象转换成代表其子类的对象&nbsp;&nbsp;&nbsp;&nbsp;b、Cast-把对象转换成代表类或是接口的对象&nbsp;&nbsp;&nbsp;&nbsp;c、getClassLoader()-获得类的加载器&nbsp;&nbsp;&nbsp;&nbsp;d、getClasses()-返回一个数组，数组中包含该类中所有公共类和接口类的对象&nbsp;&nbsp;&nbsp;&nbsp;e、getDeclaredClasses()-返回一个数组，数组中包含该类中所有类和接口类的对象&nbsp;&nbsp;&nbsp;&nbsp;f、getName()-获得类的完整路径名字&nbsp;&nbsp;&nbsp;&nbsp;g、getPackage()-获得类的包&nbsp;&nbsp;&nbsp;&nbsp;h、getSimpleName()-获得类的名字&nbsp;&nbsp;&nbsp;&nbsp;i、getSuperclass()-获得当前类继承的父类的名字&nbsp;&nbsp;&nbsp;&nbsp;j、getInterfaces()-获得当前类实现的类或是接口&nbsp;&nbsp;&nbsp;&nbsp;k、forName(String className)-根据类名返回类的对象&nbsp;&nbsp;&nbsp;&nbsp;l、newInstance()-创建类的实例2、Constructor类&nbsp;&nbsp;&nbsp;&nbsp;newInstance(Object...args)3、Field类&nbsp;&nbsp;&nbsp;&nbsp;set(Object obj，Object value)4、Method类&nbsp;&nbsp;&nbsp;&nbsp;invoke(Object obj，Object...args)### XML1、解析方式&nbsp;&nbsp;&nbsp;&nbsp;a、SAX&nbsp;&nbsp;&nbsp;&nbsp;b、DOM&nbsp;&nbsp;&nbsp;&nbsp;c、St2、dom4j### 异常1、实现Throwable&nbsp;&nbsp;&nbsp;&nbsp;a、Error&nbsp;&nbsp;&nbsp;&nbsp;b、Exception&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、检查异常&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、RuntimeException&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、自定义异常，继承Exception或其子类### I/O1、两种设计模式2、字节流3、字符流4、BIO（blocking I/O）-同步并堵塞5、NIO（no-blocking I/O）同步非堵塞6、AIO（NIO2）（Asynchronous I/O）异步非堵塞## 数据结构### 排序<a href="#">Post not found: daily/20190423</a># 数据库# 框架]]></content>
      
      
      
        <tags>
            
            <tag> 汇总 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>试题</title>
      <link href="/daily/questions/"/>
      <url>/daily/questions/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><ul><li>开发中JAVA用了比较多的数据结构有哪些？</li><li>谈谈你对HashMap的理解，底层的基本实现。HashMap怎么解决碰撞问题的？这些数据结构中是线程安全的吗？concurren包的问题？</li><li>JVM，类加载过程，里面执行的哪些操作？GC和内存管理，平时tomcat里面有没有进行过相关的配置</li><li>http协议，get和post基本区别，tcp/ip协议，三次握手，窗口滑动机制？</li><li>哪些数据库，存储引擎有哪些，悲观锁，乐观锁，使用场景，分布式集群实现原理。</li><li>springmvc和mybatis的工作原理，底层源码</li><li>redis的存储类型、事务、使用场景</li></ul><a id="more"></a><ul><li>Dubbo超时重试，Dubbo超时时间设置</li><li>如何保障请求执行顺序</li><li>分布式事务与分布式锁（扣款不要出现负数）</li><li>分布式session设置</li><li>执行某操作，前50次成功，第51次失败，a全部回滚，b前50次提交，第51次抛异常，ab场景分别如何设置Spring（传播特性）</li><li>Zookeeper有哪些作用</li><li>JVM内存模型</li><li>数据库垂直和水平拆分</li><li>MyBatis如何分页；如何设置缓存；MySQL分页</li><li>熟悉IO，NIO区别，阻塞和非阻塞的区别</li><li>分布式session一致性</li><li>分布式接口的幂等性设计，不能重复扣款</li></ul><ul><li><p>项目架构图</p></li><li><p>JVM老年代和新生代的臂力</p></li><li><p>YGC和FGC发生的具体场景</p></li><li><p>jstack，jmap，jutil分别的意义？如何线上排查JVM的相关问题</p></li><li><p>线城市的构造类的方法的5个参数的具体意义</p></li><li><h3 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h3></li><li><p>Object 1</p></li><li><p>String 1</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System.gc()与Object.finalize()的区别</title>
      <link href="/java/basics/20200902/"/>
      <url>/java/basics/20200902/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><p><code>finalize()</code>是由JVM自动调用的，你可以用<code>System.gc()</code>，但JVM不一定会立刻执行，JVM感觉内存空间有限时，才会开始执行<code>finalize()</code>,至于新的对象创建个数和被收集个数不同是因为收集的对象只和JVM的垃圾收集策略有关。</p><a id="more"></a><h3 id="finalize-函数是干嘛的-Java不是有Garbage-Collection-以下简称gc-来负责回收内存吗"><a href="#finalize-函数是干嘛的-Java不是有Garbage-Collection-以下简称gc-来负责回收内存吗" class="headerlink" title="finalize()函数是干嘛的?Java不是有Garbage Collection(以下简称gc)来负责回收内存吗?"></a>finalize()函数是干嘛的?Java不是有Garbage Collection(以下简称gc)来负责回收内存吗?</h3>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10条好建议</title>
      <link href="/daily/TenGoodAdvice/"/>
      <url>/daily/TenGoodAdvice/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="想清楚，再动手写代码"><a href="#想清楚，再动手写代码" class="headerlink" title="想清楚，再动手写代码"></a>想清楚，再动手写代码</h3><ul><li>刚入行的新手，为了展示自己的能力，拿到需求迫不及待地就开始上手写代码，大忌！<a id="more"></a></li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/wRUmLbk.png"></p><h3 id="不交流，就会头破血流"><a href="#不交流，就会头破血流" class="headerlink" title="不交流，就会头破血流"></a>不交流，就会头破血流</h3><ul><li>不爱说话和沟通，需求都理解错误了，最后做出来才发现，只能加班返工。</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/HMiLZkZ.png"></p><h3 id="文档没人看，但还是要写"><a href="#文档没人看，但还是要写" class="headerlink" title="文档没人看，但还是要写"></a>文档没人看，但还是要写</h3><ul><li>文档的作用大部分时候不是用来沟通的，是用来做记录的，大部分需求还是通过口头沟通，但是不写文档做记录，后续就容易扯皮。</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/ZmWoGCG.png"></p><h3 id="一定要写注释"><a href="#一定要写注释" class="headerlink" title="一定要写注释"></a>一定要写注释</h3><ul><li>时间久了，你会连自己的代码都看不懂。</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/FtsgPgL.png"></p><h3 id="别指望需求会稳定"><a href="#别指望需求会稳定" class="headerlink" title="别指望需求会稳定"></a>别指望需求会稳定</h3><ul><li>产品需求是根据商业需求不断调整的，改需求是再正常不过的事，别抱怨。</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/VfGQem2.png"></p><h3 id="业务高于技术"><a href="#业务高于技术" class="headerlink" title="业务高于技术"></a>业务高于技术</h3><ul><li>如果技术不为公司商业做服务，那将毫无价值，公司赚钱才是硬道理。</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/yBSdRiK.png"></p><h3 id="不要心存侥幸"><a href="#不要心存侥幸" class="headerlink" title="不要心存侥幸"></a>不要心存侥幸</h3><ul><li>你隐约感觉会出bug的地方，就一定会出bug。</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/CTIukgG.png"></p><h3 id="自己先测几遍"><a href="#自己先测几遍" class="headerlink" title="自己先测几遍"></a>自己先测几遍</h3><ul><li>不要写完就扔给测试人员去测，经自己手的东西，要保证质量。</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/mGSpOgM.png"></p><h3 id="尽可能自己解决问题"><a href="#尽可能自己解决问题" class="headerlink" title="尽可能自己解决问题"></a>尽可能自己解决问题</h3><ul><li>遇到不懂的问题，要先尽力解决，别动不动就截个图扔在别人求帮忙，上司和同事不是来给你擦屁股的，但是真的搞砸了就要尽快求助。</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/ifh3Ioo.png"></p><h3 id="慎用新技术"><a href="#慎用新技术" class="headerlink" title="慎用新技术"></a>慎用新技术</h3><ul><li>新技术是好东西，但没有百分百把握，自作主张用了，多半是作死。</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/jZskaTa.png"></p>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java Object</title>
      <link href="/java/basics/20200901/"/>
      <url>/java/basics/20200901/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>Object类，所有类的父类，也成超级类。<br>在java.lang包下<br>java.lang包包含着Java最基础和核心的类，在编译时会自动导入。</p><a id="more"></a><p>Object类没有定义属性，一共有13个方法</p><h3 id="public-Object"><a href="#public-Object" class="headerlink" title="public Object();"></a>public Object();</h3><ul><li>Java中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数，作为所有类的基类，Object类自然要反映出此特性，在源码中，未给出Object类构造函数定义，但实际上，此构造函数是存在的。</li></ul><h3 id="private-static-native-void-registerNatives"><a href="#private-static-native-void-registerNatives" class="headerlink" title="private static native void registerNatives();"></a>private static native void registerNatives();</h3><ul><li><code>registerNatives</code>函数前面有<code>native</code>关键字修饰，Java中，用<code>native</code>关键字修饰的函数表明该方法的实现并不是在Java中去完成，而是由C/C++去完成，并被编译成了.dll，由Java去调用。例如：对于<code>java.lang.Object.registerNatives</code>，对应的C函数命名为<code>Java_java_lang_Object_registerNatives</code>。</li><li>也就是说<code>registerNatives</code>的方法在C/C++的dll中，jvm运行后，<code>registerNatives</code>的实体方法会映射到java中，并在java中使用，但是本方法是私有静态的，无法子类继承去实现调用，所以在这句代码后有一个静态代码块去调用：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>为了加深对java本地方法的理解，在网上找到了该方法的C源码部分，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static JNINativeMethod methods[] &#x3D; </span><br><span class="line">&#123;</span><br><span class="line">    &#123;&quot;hashCode&quot;,    &quot;()I&quot;,                    (void *)&amp;JVM_IHashCode&#125;,</span><br><span class="line">    &#123;&quot;wait&quot;,        &quot;(J)V&quot;,                   (void *)&amp;JVM_MonitorWait&#125;,</span><br><span class="line">    &#123;&quot;notify&quot;,      &quot;()V&quot;,                    (void *)&amp;JVM_MonitorNotify&#125;,</span><br><span class="line">    &#123;&quot;notifyAll&quot;,   &quot;()V&quot;,                    (void *)&amp;JVM_MonitorNotifyAll&#125;,</span><br><span class="line">    &#123;&quot;clone&quot;,       &quot;()Ljava&#x2F;lang&#x2F;Object;&quot;,   (void *)&amp;JVM_Clone&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">JNIEXPORT void JNICALL</span><br><span class="line">Java_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)</span><br><span class="line">&#123;</span><br><span class="line">    (*env)-&gt;RegisterNatives(env, cls,methods, sizeof(methods)&#x2F;sizeof(methods[0]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>因为要用<code>registerNatives</code>去初始化其他方法，做对应的映射。这样理解起来会更容易。</li></ul><h3 id="protected-native-Object-clone-throws-CloneNotSupportedException"><a href="#protected-native-Object-clone-throws-CloneNotSupportedException" class="headerlink" title="protected native Object clone() throws CloneNotSupportedException;"></a>protected native Object clone() throws CloneNotSupportedException;</h3><ul><li><code>clone</code>也是一个<code>native</code>方法，可以知道<code>clone</code>不是一个原生方法。</li><li>Java术语表述为：<code>clone</code>函数返回的是一个引用，指向的是新的<code>clone</code>出来的对象，此对象与原对象分别占用不同的堆空间。</li><li><code>clone</code>运用的时候存在问题，<code>object</code>的<code>clone()</code>方法直接是调用不了的，提示出<code>The method clone() from the type Object is not visible</code><br>（类型对象的方法克隆（）不可见），子类直接调用<code>clone</code>的话，虽然能调用，但是会报错<code>CloneNotSupportedException</code>，意为无法支持拷贝，子类必须继承<code>Cloneable</code>接口才行。</li><li><code>Cloneable</code>接口是一个标记接口，接口内无任何方法，跟变量。</li></ul><blockquote><p>拷贝有深拷贝和浅拷贝之分：<br>深拷贝是对象中的所有东西进行拷贝，拷贝对象内的非基本类型的属性，并不是指向同一引用，而是创建了新对象。<br>浅拷贝中的非基本类型的对象，指向的是同一引用。</p></blockquote><ul><li>拷贝时需实现<code>Cloneable</code>接口，并重写<code>clone</code>方法，根据方法写的编写的功能，实现浅拷贝和深拷贝。</li><li>由于native方法的效率一般来说都是远高于java的非<code>native</code>方法，这也解释了为什么要用<code>clone</code>方法，而不是先<code>new</code>一个对象，然后把对象进行赋值，虽然也算是实现了拷贝。</li></ul><h3 id="public-final-native-Class-lt-gt-getClass"><a href="#public-final-native-Class-lt-gt-getClass" class="headerlink" title="public final native Class&lt;?&gt; getClass();"></a>public final native Class&lt;?&gt; getClass();</h3><ul><li><code>getClass()</code>也是一个native方法，返回的是此<code>Object</code>对象的类对象/运行时类对象<code>Class&lt;?&gt;</code>。效果与<code>Object.class</code>相同。</li><li>首先解释下”类对象”的概念：在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，<code>Class</code>，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于<code>Class</code>类的对象。为与经常意义上的对象相区分，在此称之为”类对象”。</li></ul><h3 id="public-boolean-equals-Object-obj"><a href="#public-boolean-equals-Object-obj" class="headerlink" title="public boolean equals(Object obj);"></a>public boolean equals(Object obj);</h3><ul><li>在object中看来，<code>==</code>和<code>equals</code>没区别。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj)&#123;</span><br><span class="line">    return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>==</code>是比较引用或者是地址，<code>equals</code>是比较内容。比较片面，这个要看具体的比较规则，重写此方法。</li></ul><h3 id="public-native-int-hashCode"><a href="#public-native-int-hashCode" class="headerlink" title="public native int hashCode();"></a>public native int hashCode();</h3><ul><li>即严格的数学逻辑表示为： 两个对象相等 &lt;=&gt;  <code>equals()</code>相等  =&gt; <code>hashCode()</code>相等。因此，重写<code>equlas()</code>方法必须重写<code>hashCode()</code>方法，以保证此逻辑严格成立，同时可以推理出：<code>hasCode()</code>不相等 =&gt; <code>equals()</code>不相等 &lt;=&gt; 两个对象不相等。</li></ul><blockquote><p>其中<code>hesCode()</code>相等推不出<code>equals()</code>相等</p></blockquote><ul><li>用于集合中遍历，不需要重头到尾遍历，减少遍历时间。</li></ul><h3 id="public-String-toString"><a href="#public-String-toString" class="headerlink" title="public String toString();"></a>public String toString();</h3><p>toString()方法相信大家都经常用到，即使没有显式调用，但当我们使用System.out.println(obj)时，其内部也是通过toString()来实现的。<br>getClass()返回对象的类对象，getClassName()以String形式返回类对象的名称（含包名）。Integer.toHexString(hashCode())则是以对象的哈希码为实参，以16进制无符号整数形式返回此哈希码的字符串表示形式。</p><h3 id="public-final-native-void-notify"><a href="#public-final-native-void-notify" class="headerlink" title="public final native void notify();"></a>public final native void notify();</h3><ul><li>随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个<code>IllegalMonitorStateException</code>异常。</li></ul><h3 id="public-final-native-void-notifyAll"><a href="#public-final-native-void-notifyAll" class="headerlink" title="public final native void notifyAll();"></a>public final native void notifyAll();</h3><ul><li>解除所有那些在该对象上调用wait方法的线程的阻塞状态。该方法只能在同步方法或同步块内部调用。如果当前线程不是锁的持有者，该方法抛出一个<code>IllegalMonitorStateException</code>异常。</li></ul><h3 id="public-final-void-wait-throws-InterruptedException"><a href="#public-final-void-wait-throws-InterruptedException" class="headerlink" title="public final void wait() throws InterruptedException;"></a>public final void wait() throws InterruptedException;</h3><ul><li>此方法调用<code>public final native void wait(long timeout) throws InterruptedException</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final void wait() throws InterruptedException &#123;</span><br><span class="line">    wait(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="public-final-native-void-wait-long-timeout-throws-InterruptedException"><a href="#public-final-native-void-wait-long-timeout-throws-InterruptedException" class="headerlink" title="public final native void wait(long timeout) throws InterruptedException;"></a>public final native void wait(long timeout) throws InterruptedException;</h3><ul><li>等待时间为毫秒级。</li></ul><h3 id="public-final-void-wait-long-timeout-int-nanos-throws-InterruptedException"><a href="#public-final-void-wait-long-timeout-int-nanos-throws-InterruptedException" class="headerlink" title="public final void wait(long timeout,int nanos) throws InterruptedException;"></a>public final void wait(long timeout,int nanos) throws InterruptedException;</h3><ul><li>等待时间为毫秒级，<code>nanos</code>为附加时间，如果附加时间不在0-999999之间或<code>timeout</code>小于0，都会抛出<code>InterruptedException</code>异常，最终的停止时间为<code>time</code>+1;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;</span><br><span class="line">    if (timeout &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (nanos &gt; 0) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proteced-void-finalize"><a href="#proteced-void-finalize" class="headerlink" title="proteced void finalize();"></a>proteced void finalize();</h3><p>可以看一下<a href="/2018/10/11/GcAndFinalize">sysout.gc()和finalize的区别</a></p><ul><li>用于销毁或者说是回收资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>for与foreach用法的区别</title>
      <link href="/java/basics/20200903/"/>
      <url>/java/basics/20200903/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="for-or-foreach"><a href="#for-or-foreach" class="headerlink" title="for or foreach"></a>for or foreach</h3><ul><li>当集合是实现了RandomAccess(随机存储接口),也就意味着，数据是随机访问的，例如arraylist，则尽量用for(int i = 0; i &lt; size; i++) 来遍历。</li><li>反过来，如果List是Sequence List，例如linkedlist，则最好用迭代器来进行迭代。</li><li>数组特殊，for比foreach快</li></ul>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读java源码的顺序</title>
      <link href="/java/basics/20200831/"/>
      <url>/java/basics/20200831/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><p>标题为包名，后面序号为优先级1-4，优先级递减</p><h3 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h3><ul><li>Object 1</li><li>String 1<a id="more"></a></li><li>AbstractStringBuilder 1</li><li>StringBuffer 1</li><li>StringBuilder 1</li><li>Boolean 2</li><li>Byte 2</li><li>Double 2</li><li>Float 2</li><li>Integer 2</li><li>Long 2</li><li>Short 2</li><li>Thread 2</li><li>ThreadLocal 2</li><li>Enum 3</li><li>Throwable 3</li><li>Error 3</li><li>Exception 3</li><li>Class 4</li><li>ClassLoader 4</li><li>Compiler 4</li><li>System 4</li><li>Package 4</li><li>Void 4</li></ul><h3 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h3><ul><li>AbstractList 1</li><li>AbstractMap 1</li><li>AbstractSet 1</li><li>ArrayList 1</li><li>LinkedList 1</li><li>HashMap 1</li><li>Hashtable 1</li><li>HashSet 1</li><li>LinkedHashMap 1</li><li>LinkedHashSet 1</li><li>TreeMap 1</li><li>TreeSet 1</li><li>Vector 2</li><li>Queue 2</li><li>Stack 2</li><li>SortedMap 2</li><li>SortedSet 2</li><li>Collections 3</li><li>Arrays 3</li><li>Comparator 3</li><li>Iterator 3</li><li>Base64 4</li><li>Date 4</li><li>EventListener 4</li><li>Random 4</li><li>SubList 4</li><li>Timer 4</li><li>UUID 4</li><li>WeakHashMap 4</li></ul><h3 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h3><ul><li>ConcurrentHashMap 1</li><li>Executor 2</li><li>AbstractExecutorService 2</li><li>ExecutorService 2</li><li>ThreadPoolExecutor 2</li><li>BlockingQueue 2</li><li>AbstractQueuedSynchronizer 2</li><li>CountDownLatch 2</li><li>FutureTask 2</li><li>Semaphore 2</li><li>CyclicBarrier 2</li><li>CopyOnWriteArrayList 3</li><li>SynchronousQueue 3</li><li>BlockingDeque 3</li><li>Callable 4</li></ul><h3 id="java-util-concurrent-atomic"><a href="#java-util-concurrent-atomic" class="headerlink" title="java.util.concurrent.atomic"></a>java.util.concurrent.atomic</h3><ul><li>AtomicBoolean 2</li><li>AtomicInteger 2</li><li>AtomicLong 2</li><li>AtomicReference 3</li></ul><h3 id="java-lang-reflect"><a href="#java-lang-reflect" class="headerlink" title="java.lang.reflect"></a>java.lang.reflect</h3><ul><li>Field 2</li><li>Method 2</li></ul><h3 id="java-lang-annotation"><a href="#java-lang-annotation" class="headerlink" title="java.lang.annotation"></a>java.lang.annotation</h3><ul><li>Annotation 3</li><li>Target 3</li><li>Inherited 3</li><li>Retention 3</li><li>Documented 4</li><li>ElementType 4</li><li>Native 4</li><li>Repeatable 4</li></ul><h3 id="java-util-concurrent-locks"><a href="#java-util-concurrent-locks" class="headerlink" title="java.util.concurrent.locks"></a>java.util.concurrent.locks</h3><ul><li>Lock 2</li><li>Condition 2</li><li>ReentrantLock 2</li><li>ReentrantReadWriteLock 2</li></ul><h3 id="java-io"><a href="#java-io" class="headerlink" title="java.io"></a>java.io</h3><ul><li>File 3</li><li>InputStream   3</li><li>OutputStream  3</li><li>Reader  4</li><li>Writer  4</li></ul><h3 id="java-nio"><a href="#java-nio" class="headerlink" title="java.nio"></a>java.nio</h3><ul><li>Buffer 3</li><li>ByteBuffer 4</li><li>CharBuffer 4</li><li>DoubleBuffer 4</li><li>FloatBuffer 4</li><li>IntBuffer 4</li><li>LongBuffer 4</li><li>ShortBuffer 4</li></ul><h3 id="java-sql"><a href="#java-sql" class="headerlink" title="java.sql"></a>java.sql</h3><ul><li>Connection 3</li><li>Driver 3</li><li>DriverManager 3</li><li>JDBCType 3</li><li>ResultSet 4</li><li>Statement 4</li></ul><h3 id="java-net"><a href="#java-net" class="headerlink" title="java.net"></a>java.net</h3><ul><li>Socket 3</li><li>ServerSocket 3</li><li>URI 4</li><li>URL 4</li><li>URLEncoder 4</li></ul><h1 id="阅读笔记简版"><a href="#阅读笔记简版" class="headerlink" title="阅读笔记简版"></a>阅读笔记简版</h1><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ul><li>wait(), notify(), notifyAll(), wait(timeout)</li><li>hashCode(), equals()</li><li>clone()</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li>char[] value</li><li>int hash</li><li>equals(), startWith(), endWith(), replace</li></ul><h3 id="AbstractStringBuilder"><a href="#AbstractStringBuilder" class="headerlink" title="AbstractStringBuilder"></a>AbstractStringBuilder</h3><ul><li>char[] value</li><li>int count</li><li>扩容：翻倍，不够取所需最小</li></ul><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><ul><li>继承AbstractStringBuilder</li><li>synchronized方法保证线程安全</li><li>char[] toStringCache</li><li>StringBuilder 继承AbstractStringBuilder</li></ul><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul><li>Object[] elementData</li><li>int size</li><li>默认大小10</li><li>扩容：翻倍，不够取所需最小</li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><ul><li>Node {E item, Node prev, Node next}</li><li>int size</li><li>Node first</li><li>Node last</li><li>linkFirst(), linkLast(), linkBefore(), unLinkFirst(), unLinkLast(), unLink(), indexOf()</li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li>Node{int hash, K key, V value, Node next}</li><li>默认容量16，负载因子0.75f</li><li>int size, modCount, threshold, float loadFactor</li><li>Node[] table</li><li>Set entrySet</li><li>put():根据key算hash，根据容量和hash算index，table[index]没有直接添加到数组中，table[index]有，若index位置同一个key则更新，否则遍历next是否有，有则更新，无则新增，最后根据thread与size判断是否扩容。注：扩容时容量翻倍，重新算hash复制到新数组</li><li>get()类似</li></ul><blockquote><p>注：先比较hash，若相等在比较equals</p></blockquote><h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><ul><li>结构实现与HashMap基本一致</li><li>通过synchronized方法保证线程安全</li></ul><h3 id="HashSet：委托给HashMap，其Value是同一个默认对象"><a href="#HashSet：委托给HashMap，其Value是同一个默认对象" class="headerlink" title="HashSet：委托给HashMap，其Value是同一个默认对象"></a>HashSet：委托给HashMap，其Value是同一个默认对象</h3><h3 id="LinkedHashMap继承HashMap"><a href="#LinkedHashMap继承HashMap" class="headerlink" title="LinkedHashMap继承HashMap"></a>LinkedHashMap继承HashMap</h3><ul><li>Entry{HashMap.Node, Entry before, after}</li><li>Entry head, tail</li><li>重写newNode()添加节点时，除像HashMap中添加外，保存before、after信息</li></ul><h3 id="LinkedHashSet继承HashSet：不知道如何实现的顺序？"><a href="#LinkedHashSet继承HashSet：不知道如何实现的顺序？" class="headerlink" title="LinkedHashSet继承HashSet：不知道如何实现的顺序？"></a>LinkedHashSet继承HashSet：不知道如何实现的顺序？</h3><h3 id="AbstractMap维护EntrySet，AbstractSet维护Iterator，AbstractList维护Iterator"><a href="#AbstractMap维护EntrySet，AbstractSet维护Iterator，AbstractList维护Iterator" class="headerlink" title="AbstractMap维护EntrySet，AbstractSet维护Iterator，AbstractList维护Iterator"></a>AbstractMap维护EntrySet，AbstractSet维护Iterator，AbstractList维护Iterator</h3><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ul><li>JDK1.7及以前<ul><li>Segment[] ,HashEntry[] , HashEntry{hash, k, v,next}</li><li>根据key算hash，根据hash和Segment的大小算位置，每个segment拥有一个自己的HashEntry[]</li><li>get()：不加锁，volatile类型</li><li>put(): 对相应segment加锁</li><li>size()：各HashEntry[] 之和，先不加锁算两遍，若一致则返回，若不一致则加锁重新计算</li></ul></li><li>JDK1.8<ul><li>Node{hash, key, value, next}</li><li>Node[] table</li><li>大多数操作类似于HashMap，不同CAS方式设置，根据key算hash，在根据hash和容量算index，对table[index]加锁，从而达到更大的并发量</li><li>get(): 同HashMap</li><li>put(): 对table[index]加锁</li></ul></li></ul><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li>红黑树，即自平衡二叉查找树，时间复杂度O(logn)</li><li>Entry{K k, V v, Entry parent, left, right, boolean color}</li><li>Entry root，int size， int modeCount</li></ul><h3 id="TreeSet：委托TreeMap实现"><a href="#TreeSet：委托TreeMap实现" class="headerlink" title="TreeSet：委托TreeMap实现"></a>TreeSet：委托TreeMap实现</h3>]]></content>
      
      
      <categories>
          
          <category> 知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客+spfk主题+LiveRe评论+Github pages</title>
      <link href="/daily/Hexo_spfk_LiveRe_GithubPages/"/>
      <url>/daily/Hexo_spfk_LiveRe_GithubPages/</url>
      
        <content type="html"><![CDATA[ <meta name="referrer" content="no-referrer" /><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>刚接触Blog，觉得很新鲜，选择一个免费空间来写。</p><a id="more"></a><p><a href="https://github.com/">Github</a>是一个全世界程序员聚集的地方，大家相互分享自己写的代码，提升别人，也提升自己。<br>先说说Github pages服务搭建博客的好处：</p><ul><li>免费</li><li>免费</li><li>免费</li></ul><p>再说说Hexo的优点：</p><ul><li>生成纯静态网页，访问速度快</li><li>没有数据库，迁移很方便</li><li>免费</li></ul><p>在评论系统上选用LiveRe：</p><ul><li>大佬级的disqus评论系统在墙外（沉默一会），需要vpn</li><li>多说、网易云已躺</li><li>搜狐畅言需要域名备案，免费的我怎么可能有域名，所以直接忽略</li><li>原生评论系统？？？hexo没有数据库，怎么弄。。。</li><li>gitment是github的，没弄明白</li><li>友言，登陆不上</li></ul><p>看来看去，LiveRe还能用，虽然bug比较多，网络连接比较差。爱折腾的我们，会找到更好的。</p><h3 id="安装Git-Bash"><a href="#安装Git-Bash" class="headerlink" title="安装Git Bash"></a>安装Git Bash</h3><p>我的是windows环境，所以下载windows版本并安装就可以了。<br/></p><ul><li><a href="https://gitforwindows.org/">下载地址</a></li><li>下载exe，打开之后，一路下一步就好了</li><li>安装好后，打开gitbash</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/0Piax8M.png"></p><ul><li>找不到gitbash的小伙伴，右键空白处就能看到</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/4Vl2Alk.png"></p><ul><li>或者在所有程序中找到Git文件夹</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/IRIO9Mr.png"></p><ul><li>查看当前安装的版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/AczxU7z.png"></p><h3 id="安装NodeJs"><a href="#安装NodeJs" class="headerlink" title="安装NodeJs"></a>安装NodeJs</h3><p>Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧</p><ul><li><a href="https://nodejs.org/en/">下载地址</a>（说明：LTS为长期支持版，Current为当前最新版）</li><li>安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选<code>Add to PATH</code> ,这样你就不用自己去配置电脑上环境变量了，装完在按 <code>win + r</code> 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的自行问度娘吧。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/aDLESxv.png"></p><h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>安装上面两个软件后，后面的东西就不需要我们自己手动下载了，因为用gitbash中npm工具就能完成。</p><ul><li>首先需要找个地方来存放你的blog，在电脑的某个地方创建文件夹。</li><li>在gitbash中用<code>cd</code>进入该文件中，并执行命令,默认安装在c盘下，想修改安装路径的小伙伴，请自行百度。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g hexo</span><br></pre></td></tr></table></figure><ul><li>安装后查看版本,命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/wZviLTe.png"></p><ul><li>随后我们进行blog的初始化，命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/2PnsrRt.png"></p><ul><li>说明一下各个文件的作用：<ul><li>node_modules：是依赖包</li><li>public：存放的是生成的页面</li><li>scaffolds：命令生成文章等的模板</li><li>source：用命令创建的各种文章</li><li>themes：主题</li><li>_config.yml：整个博客的配置</li><li>db.json：source解析所得到的</li><li>package.json：项目所需模块项目的配置信息</li></ul></li><li>到这一步，架子算是搭好了，剩下的就是一些个性化的配置了</li></ul><h3 id="搭桥到github"><a href="#搭桥到github" class="headerlink" title="搭桥到github"></a>搭桥到github</h3><p>把创建好的blog项目部署到github上并用github page</p><ul><li>首先需要有github账号，如果没有，请自行百度，注册很简单。</li><li>有了账号，并登陆后创建一个repo,名称为<code>yourname.github.io</code>,其中yourname是你github的名称，操作如下：</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/ChdyWrM.png"></p><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/CgGsKyy.png"></p><ul><li>点击<code>Create repository</code>即可</li><li>回到gitbash中，配置github账户信息(<code>YourName</code>和<code>YourEmail</code>填写你们自己的)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;YourName&quot;</span><br><span class="line">git config --global user.email &quot;YourEmail&quot;</span><br></pre></td></tr></table></figure><ul><li>创建ssh</li><li>在gitbash中输入以下命令，需要输入密码,生成ssh密钥。然后进入C:\Users\用户名.ssh,进入此文件夹，找到<code>id_rsa.pub</code>文件，查看里面的内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot;</span><br></pre></td></tr></table></figure><ul><li>登陆github：</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/HW6wNvt.png"><br><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/RWn2wyh.png"></p><ul><li>点击<code>New SSH key</code></li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/P04VMJ8.png"></p><ul><li>title随便起，key值填入id_rsa.pub文件内的内容，点击<code>Add SSH key</code>即可</li><li>在gitbash中校验是否添加成功,命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="把blog关联到github中"><a href="#把blog关联到github中" class="headerlink" title="把blog关联到github中"></a>把blog关联到github中</h3><ul><li>打开blog项目，修改<code>_config.yml</code>文件中的一些配置,在文档字下面添加下面的代码，冒号后面有一个英文的空格,</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: git@github.com:YourgithubName&#x2F;YourgithubName.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><ul><li><p>回到gitbash中，进入你的本地blog目录，执行下面命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>hexo 3.0</code>把服务器独立成个别模块，需要单独安装：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-server</span><br></pre></td></tr></table></figure></li><li><p>打开浏览器，输入：<code>http://localhost:4000</code></p></li><li><p>你就可以看到hexo自带主题的页面了</p></li></ul><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><ul><li>先安装插件,只有安装这个，才能部署到github中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ul><li>执行命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><blockquote><p><code>hexo d</code>的时候，会让输入生成ssh时候输入的密码。</p></blockquote><ul><li>部署成功后，访问<code>http://yourgithubname.github.io</code>,就可以看见了</li></ul><h3 id="修改主题为spfk"><a href="#修改主题为spfk" class="headerlink" title="修改主题为spfk"></a>修改主题为spfk</h3><ul><li>hexo默认的是主题是<code>landscape</code>,我用的是spfk的主题。</li><li>在gitbash中进入你的blog所在的文件夹，输入以下命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;luuman&#x2F;hexo-theme-spfk.git themes&#x2F;spfk</span><br></pre></td></tr></table></figure><ul><li>下载完成后，修改blog下的<code>_confing.yml</code>文件，将<code>theme</code>属性修改成<code>spfk</code>,改成其他主题，操作类似</li><li>如果主题需要更新的话，在gitbash中,进入主题所在文件夹，在<code>blog\themes</code>中，名字对应的文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><ul><li>更换完后，重新加载和部署即可</li></ul><h3 id="添加LiveRe评论系统"><a href="#添加LiveRe评论系统" class="headerlink" title="添加LiveRe评论系统"></a>添加LiveRe评论系统</h3><ul><li>首先进入<a href="https://livere.com/">LiveRe</a></li><li>进行注册，注册完成</li><li>点击安装，选择<code>City版</code>，喜欢付费的小伙伴，可以选择<code>Premium版</code>，点击<code>现在安装</code></li><li>根据自身的需求进行一些设置</li><li>绑定网址，生成代码</li><li>在管理界面左侧找到代码管理，把一般网站里的代码粘贴出来，命名为<code>livere.ejs</code></li><li>放到<code>blog\themes\spfk\layout\_partial\comments</code></li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/9D3XRNo.png"></p><ul><li>由于spfk主题下没有LiveRe评论系统的，所以要手动进行添加</li><li>打开文件<code>hexo\themes\spfk\layout\_partial</code>下的<code>article.ejs</code>文件</li></ul><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/r3QFah0.png"></p><ul><li>找到<code>if (!index &amp;&amp; post.comments)&#123;</code>这里添加以下代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%  if (theme.livere.on) &#123; %&gt;</span><br><span class="line">    &lt;%- partial(&#39;comments&#x2F;livere&#39;) %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/YnPSlWX.png"></p><ul><li>打开spfk主题配置文件<code>hexo\themes\spfk</code>下的<code>_config.yml</code>添加以下代码,<code>Yourid</code>的值时LiveRe代码中的<code>data-uid</code>的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">livere:</span><br><span class="line">    on: true</span><br><span class="line">    livere_uid: Yourid</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snmlm/resources/master/picture/3Sqc0NV.png"></p><ul><li>由于主题中还有其他的评论系统，把其他评论系统全部注释掉即可</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><ul><li>执行编译和部署命令，将整合过后的项目部署到github上</li><li>自己的小博客大功告成</li></ul><h3 id="打完收工"><a href="#打完收工" class="headerlink" title="打完收工"></a>打完收工</h3>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
